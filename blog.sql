-- MySQL dump 10.13  Distrib 8.0.34, for Win64 (x86_64)
--
-- Host: 114.132.41.159    Database: blog
-- ------------------------------------------------------
-- Server version	5.7.36

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `tb_admin_user`
--

DROP TABLE IF EXISTS `tb_admin_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_admin_user` (
  `admin_user_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '管理员id',
  `login_user_name` varchar(50) NOT NULL COMMENT '管理员登陆名称',
  `login_password` varchar(50) NOT NULL COMMENT '管理员登陆密码',
  `nick_name` varchar(50) NOT NULL COMMENT '管理员显示昵称',
  `locked` tinyint(4) DEFAULT '0' COMMENT '是否锁定 0未锁定 1已锁定无法登陆',
  PRIMARY KEY (`admin_user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_admin_user`
--

LOCK TABLES `tb_admin_user` WRITE;
/*!40000 ALTER TABLE `tb_admin_user` DISABLE KEYS */;
INSERT INTO `tb_admin_user` VALUES (1,'admin','6bdd5503d07e502fd413517ad6c1926a','LYR',0);
/*!40000 ALTER TABLE `tb_admin_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_blog`
--

DROP TABLE IF EXISTS `tb_blog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_blog` (
  `blog_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '博客表主键id',
  `blog_title` varchar(200) NOT NULL COMMENT '博客标题',
  `blog_sub_url` varchar(200) NOT NULL COMMENT '博客自定义路径url',
  `blog_cover_image` varchar(200) NOT NULL COMMENT '博客封面图',
  `blog_content` mediumtext NOT NULL COMMENT '博客内容',
  `blog_category_id` int(11) NOT NULL COMMENT '博客分类id',
  `blog_category_name` varchar(50) NOT NULL COMMENT '博客分类(冗余字段)',
  `blog_tags` varchar(200) NOT NULL COMMENT '博客标签',
  `blog_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '0-草稿 1-发布',
  `blog_views` bigint(20) NOT NULL DEFAULT '0' COMMENT '阅读量',
  `enable_comment` tinyint(4) NOT NULL DEFAULT '0' COMMENT '0-允许评论 1-不允许评论',
  `is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  `update_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`blog_id`)
) ENGINE=InnoDB AUTO_INCREMENT=46 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_blog`
--

LOCK TABLES `tb_blog` WRITE;
/*!40000 ALTER TABLE `tb_blog` DISABLE KEYS */;
INSERT INTO `tb_blog` VALUES (1,'我是LYR','about','http://114.132.41.159/upload/20240519_01592383.png','# 自我介绍\n\n我叫LYR，大三学生一枚~\n\n# 联系方式\n\n邮箱：3329482804@qq.com\n\nQQ：3329482804\n\n电话：13138777533\n\n微信：13138777533\n\nGithub：[https://github.com/iceliyr](https://github.com/iceliyr \"https://github.com/iceliyr\")\n\nGitee：[https://gitee.com/leeyiru](https://gitee.com/leeyiru \"https://gitee.com/leeyiru\")\n\n\n个人主要学习java后端内容，以下是一些岗位技术要求，可以选择自己喜欢的职业学习。\n\n# JAVA后端\n\n## 已学习技术栈\n\n熟悉计算机操作系统，如：进程管理、同步，内存分配、回收、扩展，文件系统，磁盘调度等；\n\n熟悉计算机网络，如：TCP五层网络模型，IP、ARP、TCP、UDP、HTTP、HTTPS、DNS等协议；\n\n熟悉数据结构与算法，如：栈，链表，树，图，哈希表等数据结构，贪心，分治，回溯，动态规划等算法；\n\n熟悉面向对象编程思想，如：SOLID设计原则，常用的单例、工厂、代理、策略、模板等设计模式；\n\n熟悉JAVA基础，如：集合，lambda，反射，注解，异常处理，流处理，IO，网络编程等；\n\n了解JVM，如：类生命周期，类加载器，双亲委派机制，运行时数据区，垃圾回收机制，GC调优，内存调优等；\n\n了解JUC，如：线程创建、等待、阻塞、中断，JMM，volatile，threadlocal，原子类，读写锁、公平锁、AQS等；\n\n熟悉使用SpringIOC/DI、SpringMVC、SpringAOP、Interceptor、Filter、Mybatis-plus、SpringBoot等框架技术；\n\n熟悉MYSQL和MyCat,如：表设计，联表查询，innoDB，索引，锁，事务，sql优化，分库分表，读写分离等；\n\n熟悉使用Redis，如：缓存穿透、击穿、缓存，分布式锁等；\n\n熟悉使用Maven、Git、Docker等开发工具；熟悉Linux操作系统，可以使用常用命令完成开发任务；\n\n了解Springcloud的相关技术，如：Consul、Nacos、OpenFeign、resilience4j、Gateway、Sentinel、Seata；\n\n了解使用消息队列RabbitMQ，如：可靠性，延迟队列，高可用等；\n\n## 基础技术栈\n\n熟悉计算机操作系统，如：进程管理、同步，内存分配、回收、扩展，文件系统，磁盘调度等；\n\n熟悉计算机网络，如：TCP五层网络模型，IP、ARP、TCP、UDP、HTTP、HTTPS、DNS等协议；\n\n熟悉数据结构与算法，如：栈，链表，树，图，哈希表等数据结构，贪心，分治，回溯，动态规划等算法；\n\n熟悉面向对象编程思想，如：SOLID设计原则，常用的单例、工厂、代理、策略、模板等设计模式；\n\n熟悉JAVA基础，如：集合，lambda，反射，注解，异常处理，流处理，IO，网络编程等；\n\n了解JVM，如：类生命周期，类加载器，双亲委派机制，运行时数据区，垃圾回收机制，GC调优，内存调优等；\n\n了解JUC，如：线程创建、等待、阻塞、中断，JMM，volatile，threadlocal，原子类，读写锁、公平锁、AQS等；\n\n熟悉使用SpringIOC/DI、SpringMVC、SpringAOP、Interceptor、Filter、Mybatis-plus、SpringBoot等框架技术；\n\n熟悉MYSQL和MyCat,如：表设计，联表查询，innoDB，索引，锁，事务，sql优化，分库分表，读写分离等；\n\n熟悉使用Redis，如：缓存穿透、击穿、缓存，分布式锁等；\n\n熟悉使用Maven、Git、Docker等开发工具；熟悉Linux操作系统，可以使用常用命令完成开发任务；\n\n了解Springcloud的相关技术，如：Consul、Nacos、OpenFeign、resilience4j、Gateway、Sentinel、Seata；\n\n了解使用消息队列RabbitMQ，如：可靠性，延迟队列，高可用等；\n\n## 完整技术栈\n\n熟悉计算机操作系统，如：进程管理、同步，内存分配、回收、扩展，文件系统，磁盘调度等；\n\n熟悉计算机网络，如：TCP五层网络模型，IP、ARP、TCP、UDP、UDP、HTTP、HTTPS、DNS等协议；\n\n熟悉数据结构与算法，如：栈，链表，树，图，哈希表等数据结构，贪心，分治，回溯，动态规划等算法；\n\n熟悉面向对象编程思想，如：SOLID设计原则，常用的单例、工厂、代理、策略、模板等设计模式；\n\n熟悉JAVA基础，如：集合，lambda，反射，注解，异常处理，流处理，IO，**NIO**，网络编程等；\n\n了解JVM，如：类生命周期，双亲委派机制，运行时数据区，垃圾回收机制，即时编译，GC、内存、性能调优等；\n\n了解JUC，如：线程创建、等待、阻塞、中断，JMM，volatile，threadlocal，原子类，读写锁、公平锁、AQS等；\n\n了解JavaWeb基础，如：Tomcat、Servlet、XML、JSON等；\n\n熟悉使用SpringIOC/DI、SpringMVC、SpringAOP、Filter、Interceptor、Mybatis-plus、SpringBoot等框架技术；\n\n熟悉MYSQL和MyCat,如：表设计，联表查询，innoDB，索引，锁，事务，sql优化，分库分表，读写分离等；\n\n熟悉使用Redis，如：缓存穿透、击穿、缓存，分布式锁等；\n\n熟悉使用Maven、git等开发工具，熟悉Linux操作系统，可以使用常用命令完成开发任务；\n\n熟悉使用docker、**k8s**；\n\n**熟悉Netty异步编程；**\n\n**熟悉使用rpc框架技术Dubbo；**\n\n熟悉Springcloud的相关技术，如：Consul、Nacos、OpenFeign、resilience4j、Gateway、Sentinel、Seata；\n\n熟悉使用消息队列RabbitMQ、**RocketMQ**，如：可靠性，延迟队列，高可用等；\n\n熟悉使用消息队列**Kafka**，如：；\n\n# 大数据开发\n\n\n# 大数据分析\n\n熟悉至少一门编程语言，如JAVA、PYTHON、C、C++等；\n\n有数据分析经验者优先，包括不限于Hadoop、Hive、ELK、Lucence、Spark、Flink、Tensorflow等\n\n# 前端\n\n## web\n\nhtml、css、js；\n\njquery、ajax、axios；\n\nnode.js；\n\nvue2、vue3；\n\n## 微信小程序\n\n微信小程序\n\n## 安卓开发\n\n\n# 测试\n\n\n# 维护\n\n\n# 产品经理',26,'作者','作者',1,1270,0,0,'2024-05-16 08:08:08','2018-11-12 00:31:15'),(7,'绿叶随笔介绍','blog','http://114.132.41.159/upload/20240519_01575231.jpg','# 项目环境\n\n**后端**\n\nJDk17、Springboot3.1.0、Mybatis-plus3.5.3.1、Mysql.5.7.36\n\n**前端**\n\nThymeleaf、Bootstrap、Jquery、AJax\n\n\n\n# 项目地址\n\n[https://github.com/iceliyr/my-blog](https://github.com/iceliyr/my-blog \"https://github.com/iceliyr/my-blog\")\n\n\n\n# 项目介绍\n\n本项目为个人博客系统，功能包括文章发布、文章分类、文章标签、文章评论、个人项目介绍、学习网站推荐、作者介绍、后台管理（文章、评论、网站管理）等功能。\n\n\n\n# 项目功能\n\n**后台登录**\n\n使用拦截器拦截后台请求，只有通过前端传入账号密码及通过（hutool工具）验证码验证后，方可进入后台管理界面进行处理数据。\n\n**文章发布、分类、标签**\n\n后台管理使用md编写评论，使用Atlassian CommonMark 库，用于解析和处理 Markdown 格式的文本，并保存到数据库，然后在转化为html文本块，其中涉及到图片上传功能（将图片通过javaIO保存到本地，并保存地址到数据库，前端通过接口访问地址即可获得），功能还使用了图片封面上传、文章分类、文章标签（通过多表连接）。\n\n**评论添加、审核、发布**\n\n在文章上添加评论，通过文章id与评论连接，在每次访问评论后，通过多表连接，获取文章的每一个评论显示。\n\n**学习网站推荐的发布**\n\n后台管理发布信息，并添加分类，然后保存到数据库。\n\n\n\n# 项目未来计划\n\n**阶段一：使用sa-token进行权限验证，便于游客查阅后台管理**\n\n**阶段二：使用redis，提高访问效率**\n\n**阶段三：增加社区功能，方便用户交流**\n\n**阶段四：使用spring cloud升级项目**\n\n\n\n# 数据库关系图\n\n![](http://114.132.41.159/upload/20240519_01550474.png)',26,'作者','博客',1,588,0,0,'2024-05-16 15:36:13','2024-05-16 15:36:13'),(9,'Docker基础','','http://114.132.41.159/upload/20240517_15291945.jpg','## 基础知识\n\n官网：[Docker: Accelerated Container Application Development](https://www.docker.com/)\n\n黑马笔记：https://b11et3un53m.feishu.cn/wiki/MWQIw4Zvhil0I5ktPHwcoqZdnec\n\n笔记：https://www.runoob.com/docker/docker-tutorial.html\n\n原理：https://zhuanlan.zhihu.com/p/187505981\n\n### 定义\n\nDocker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。\n\n### 镜像与容器\n\n当我们利用Docker安装应用时，Docker会自动搜索并下载应用镜像（image）。镜像不仅包含应用本身，还包含应用运行所需要的环境、配置、系统函数库。Docker会在运行镜像时创建一个隔离环境，称为容器（container）。镜像仓库：存储和管理镜像的平台，Docker官方维护了一个公共仓库：Docker Hub。\n\n\n##### Docker：\n\nDocker可以帮助我们下载应用镜像，创建并运行镜像的容器，从而快速部署应用\n\n##### 镜像：\n\n将应用所需的函数库、依赖、配置等与应用一起打包得到的就是镜像\n\n##### 容器：\n\n为每个镜像的应用进程创建的隔离运行环境就是容器\n\n##### 镜像仓库：\n\n存储和管理镜像的服务就是镜像仓库，DockerHub是目前最大的镜像仓库，其中包含各种常见的应用镜像\n\n### 基本原理\n\n在主机上运行的 Docker 容器实际上是基于 Docker 引擎的虚拟化技术创建和运行的。下面是 Docker 容器在主机上运行的基本过程：\n\n1. **镜像拉取或构建**： 首先，你需要有一个 Docker 镜像。你可以从 Docker Hub 或其他镜像仓库拉取现有的镜像，也可以通过编写 Dockerfile 并使用 `docker build` 命令构建自定义镜像。\n2. **创建容器**： 使用 `docker run` 命令来创建并运行容器。在创建容器时，Docker 引擎会在主机上分配一定资源（如 CPU、内存等），并在其中启动容器实例。\n3. **命名空间和控制组**： Docker 利用 Linux 内核的命名空间和控制组（cgroups）技术来实现容器的隔离。每个容器都有自己独立的命名空间，包括文件系统、网络、进程、用户等，这使得容器内的进程看起来像在一个独立的操作系统环境中运行一样。\n4. **启动应用程序**： 在容器内部，Docker 引擎会启动你在镜像中定义的应用程序或服务。这可能涉及到执行特定的命令、运行后台服务等。\n5. **运行时监控**： Docker 引擎会监控容器的运行状态，包括资源使用情况、日志输出等。你可以使用 `docker logs` 命令查看容器的日志信息，使用 `docker stats` 命令查看容器的资源使用情况。\n6. **与主机通信**： 容器内的应用程序可以与主机上的其他容器或主机系统进行通信。Docker 提供了多种网络模式和端口映射功能，使得容器可以与外部世界进行通信。\n7. **持久化数据**： 如果需要，在容器内部可以挂载主机上的文件系统或数据卷，以便持久化存储应用程序的数据。\n8. **停止和删除容器**： 当应用程序运行结束或者不再需要时，可以使用 `docker stop` 命令停止容器，并使用 `docker rm` 命令删除容器。这会释放主机资源，并清理容器相关的资源。\n\n总的来说，Docker 容器在主机上运行的过程就是将应用程序与其依赖项打包到一个隔离的环境中，并在其中运行，使得应用程序的部署和管理变得更加简单和可靠。\n\n## 基础应用\n\n### 安装配置\n\n安装配置docker：Centos7：[安装Docker](https://b11et3un53m.feishu.cn/wiki/Rfocw7ctXij2RBkShcucLZbrn2d)\n\n### docker基础命令\n\n官网文档：https://docs.docker.com\n\n常用文档：[Docker常用命令大全](https://cloud.tencent.com/developer/article/2093710)\n\n##### docker inspect \n\n用于获取有关 Docker 对象（如容器、镜像、网络等）的详细信息，可以通过该命令来查看 Docker 对象的配置、状态、挂载点等信息\n\n##### docker \n\n### 基础操作指令\n\n\n#### docker build\n\n构建自己的镜像\n\n#### docker save\n\n保存为压缩文件\n\n语法：docker save -o 文件名 镜像:版本\n\n#### docker load\n\n压缩文件部署容器\n\n\n#### docker images\n\n查看docker镜像\n\n#### docker pull\n\n拉取镜像\n\n#### docker push\n\n提交镜像\n\n#### docker rmi\n\n用于删除一个或多个本地镜像\n\n语法如下：\n\n```\ndocker rmi [OPTIONS] IMAGE [IMAGE...]\n```\n\nOPTIONS：可以使用一些选项来控制删除行为，例如 -f, --force 强制删除镜像\n\nIMAGE：要删除的镜像的名称或 ID\n\n#### docker run\n\n启动镜像\n\n实例：\n\n```\ndocker run -d \\\n--name mysql \\\n-p 3306:3306 \\\n-e TZ=Asia/Shanghai \\\n-e MYSQL_ROOT_PASSWORD=123 \\\nmysql\n```\n\ndocker run ：创建并运行一个容器，-d 是让容器在后台运行\n\n--name mysql ：给容器起个名字，必须唯一\n\n-p 3306:3306 ：设置端口映射\n\n-e KEY=VALUE ：是设置环境变量\n\n-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；\n\n-i：以交互模式运行容器，通常与 -t 同时使用；\n\n-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；\n\n也即启动交互式容器(前台有伪终端，等待交互)；\n\n-P: 随机端口映射，大写P\n\nmysql ：指定运行的镜像的名字，镜像名称一般分两部分组成：[repository]:[tag]，其中repository就是镜像名tag是镜像的版本，默认最新版\n\n#### docker start\n\n开始镜像\n\n#### docker stop\n\n停止镜像\n\n\n#### docker logs\n\n查看运行日志\n\n\n#### docker ps\n\n列出 Docker 容器\n\n##### 查看运行状态\n\n\n##### 查看停止状态\n\ndocker ps -a --filter \"status=exited\"\n\n#### docker rm\n\n用于删除一个或多个已经停止的容器\n\n语法如下：\n\n```\ndocker rm [OPTIONS] CONTAINER [CONTAINER...]\n```\n\nOPTIONS：可以使用一些选项来控制删除行为，例如 -f, --force 强制删除运行中的容器\n\nCONTAINER：要删除的容器的名称或 ID\n\n\n#### docker exec\n\n用于在运行中的容器内部执行命令。它的基本语法为：\n\n```\nCopy Codedocker exec [OPTIONS] CONTAINER COMMAND [ARG...]\n```\n\n- `[OPTIONS]`：可选参数，用于指定执行命令的一些选项，例如 `-i`（交互式执行）、`-t`（分配一个伪终端）等\n- `CONTAINER`：要在其中执行命令的容器的名称或 ID\n- `COMMAND`：要在容器内执行的命令\n- `[ARG...]`：可选参数，传递给要执行的命令的参数\n\n开启内部命令：docker exec -it mysql bash\n\n\n### 搜索docker容器应用\n\n网站：https://hub.docker.com\n\n### 数据卷挂载\n\n数据卷（volume）是一个虚拟目录，是容器内目录与宿主机目录之间映射的桥梁\n\n\n| **命令**              | **说明**             | **文档地址**          |\n| --------------------- | -------------------- | --------------------- |\n| docker volume create  | 创建数据卷           | docker volume create  |\n| docker volume ls      | 查看所有数据卷       | docker volume ls      |\n| docker volume rm      | 删除指定数据卷       | docker volume rm      |\n| docker volume inspect | 查看某个数据卷的详情 | docker volume inspect |\n| docker volume prune   | 清除数据卷           | docker volume prune   |\n\n\n### 本地目录挂载\n\n在执行docker run命令时，使用 -v 本地目录 : 容器内目录 可以完成本地目录挂载\n\n本地目录必须以“/”或 \"./\" 开头，如果直接以名称开头，会被识别为数据卷而非本地目录：\n\n​	-v mysql : /var/lib/mysql 会被识别为一个数据卷叫mysql	\n\n​	-v ./mysql : /var/lib/mysql 会被识别为当前目录下的mysql目录\n\n##### 案例（mysql）：\n\n基于宿主机目录实现MySQL数据目录、配置文件、初始化脚本的挂载\n\n挂载/root/mysql/data到容器内的/var/lib/mysql目录\n\n挂载/root/mysql/init到容器内的/docker-entrypoint-initdb.d目录，携带课前资料准备的SQL脚本\n\n挂载/root/mysql/conf到容器内的/etc/mysql/conf.d目录，携带课前资料准备的配置文件\n\n```\ndocker run -d \\  -v /root/mysql/data:/var/lib/mysql \\  -v /root/mysql/init:/docker-entrypoint-initdb.d \\  -v /root/mysql/conf:/etc/mysql/conf.d \\  --name mysql_container \\  -e MYSQL_ROOT_PASSWORD=my-secret-pw \\  mysql:latest\n```\n\n### 自定义镜像\n\n#### 镜像结构\n\n镜像中包含了应用程序所需要的运行环境、函数库、配置、以及应用本身等各种文件，这些文件分层打包而成\n\n#### Dockerfile\n\n就是一个文本文件，其中包含一个个的指令(Instruction)，用指令来说明要执行什么操作来构建镜像。将来Docker可以根据Dockerfile帮我们构建镜像。\n\n常见指令如下：https://docs.docker.com/engine/reference/builder\n\n| **指令**   | **说明**                                     | **示例**                                                     |\n| ---------- | -------------------------------------------- | ------------------------------------------------------------ |\n| FROM       | 指定基础镜像                                 | FROM centos:6                                                |\n| ENV        | 设置环境变量，可在后面指令使用               | ENV key value                                                |\n| COPY       | 拷贝本地文件到镜像的指定目录                 | COPY ./jre11.tar.gz /tmp                                     |\n| RUN        | 执行Linux的shell命令，一般是安装过程的命令   | RUN tar -zxvf /tmp/jre11.tar.gz && EXPORTS path=/tmp/jre11:$path |\n| EXPOSE     | 指定容器运行时监听的端口，是给镜像使用者看的 | EXPOSE 8080                                                  |\n| ENTRYPOINT | 镜像中应用的启动命令，容器运行时调用         | ENTRYPOINT java -jar xx.jar                                  |\n\n##### 构建命令：docker build -t 镜像名 Dockerfile目录\n\n#### 自定义镜像基础步骤\n\n1、创建项目\n\n2、将文件压缩并发送到docker的主机\n\n3、创建Dockerfile文件（尽量与项目文件同目录）\n\n4、使用docker build加载为镜像\n\n\n5、运行项目\n\n\n### 自定义网络\n\n#### docker的网络连接\n\n使用网桥，docker创建一个局域网，所有容器有自己的ip地址\n\n#### 命令\n\n| **命令**                  | **说明**                 | **文档地址**              |\n| ------------------------- | ------------------------ | ------------------------- |\n| docker network create     | 创建一个网络             | docker network create     |\n| docker network ls         | 查看所有网络             | docker network ls         |\n| docker network rm         | 删除指定网络             | docker network rm         |\n| docker network prune      | 清除未使用的网络         | docker network prune      |\n| docker network connect    | 使指定容器连接加入某网络 | docker network connect    |\n| docker network disconnect | 使指定容器连接离开某网络 | docker network disconnect |\n| docker network inspect    | 查看网络详细信息         | docker network inspect    |\n\n##### 创建一个网络\n\ndocker network create lyr(创建一个新的网段)\n##### 容器连接到指定网络\n\n运行后连接（不会覆盖旧的，直接添加新的）\n\ndocker network connect lyr 109b8f2e37a7\n\n运行时连接\n\ndocker run -d --name dd -p 8080:8080 --network=lyr docker-demo\n\n## 部署应用\n\n### 部署MYSQL\n\n```\ndocker run -d \\\n--name mysql \\\n-p 3306:3306 \\\n-e TZ=Asia/Shanghai \\\n-e MYSQL_ROOT_PASSWORD=123 \\\nmysql\n```\n\n### 部署java应用\n\n### DockerCompase\n\nDocker Compose通过一个单独的docker-compose.yml 模板文件（YAML 格式）来定义一组相关联的应用容器，帮助我们实现多个相互关联的Docker容器的快速部署。\n\n#### dockerCompase与docker run区别\n\n#### 示例：\n\n```\nversion: \"3.8\"\n\nservices:\n  mysql:\n    image: mysql\n    container_name: mysql\n    ports:\n      - \"3306:3306\"\n    environment:\n      TZ: Asia/Shanghai\n      MYSQL_ROOT_PASSWORD: 123\n    volumes:\n      - \"./mysql/conf:/etc/mysql/conf.d\"\n      - \"./mysql/data:/var/lib/mysql\"\n      - \"./mysql/init:/docker-entrypoint-initdb.d\"\n    networks:\n      - new\n  hmall:\n    build:\n       context: .\n       dockerfile: Dockerfile\n    container_name: hmall\n    ports:\n      - \"8080:8080\"\n    networks:\n      - new\n    depends_on:\n      - mysql\n  nginx:\n    image: nginx\n    container_name: nginx\n    ports:\n      - \"18080:18080\"\n      - \"18081:18081\"\n    volumes:\n      - \"./nginx/nginx.conf:/etc/nginx/nginx.conf\"\n      - \"./nginx/html:/etc/nginx/html\"\n    depends_on:\n      - hmall\n    networks:\n      - new\nnetworks:\n  new:\n    name: hmall\n\n```\n\n#### docker compose的命令格式\n\ndocker compose [OPTIONS] [COMMAND]\n\n| **参数或指令** | **说明**                     |      |\n| -------------- | ---------------------------- | ---- |\n| options:       |                              |      |\n| -f             | 指定compose文件的路径和名称  |      |\n| -p             | 指定project名称              |      |\n| command:       |                              |      |\n| up             | 创建并启动所有service容器    |      |\n| down           | 停止并移除所有容器、网络     |      |\n| ps             | 列出所有启动的容器           |      |\n| logs           | 查看指定容器的日志           |      |\n| stop           | 停止容器                     |      |\n| start          | 启动容器                     |      |\n| restart        | 重启容器                     |      |\n| top            | 查看运行的进程               |      |\n| exec           | 在指定的运行中容器中执行命令 |      |\n\n#### 步骤：\n\n0、开发构建，创建\n\n1、创建docker镜像\n\n2、创建docker-compase.yml文件\n\n3、docker compase命令',27,'开发工具','docker',1,81,0,0,'2024-05-17 01:32:07','2024-05-17 01:32:07'),(10,'Git基础','','http://114.132.41.159/upload/20240517_15293436.png','## Git基础\n\n### 版本控制类型\n\n意义：可以记录文件修改历史记录，从而让用户能够查看历史版本，方便版本切换\n\n**集中式版本控制工具**：CVS、SVN(Subversion)、VSS\n\n- 特点：有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新\n\n- 优点：每个人都可以在一定程度上看到项目中的其他人正在做些什么；而管理员也可以轻松掌控每个开发者的权限，并且管理一个集中化的版本控制系统，要远比在各个客户端上维护本地数据库来得轻松容易\n\n- 缺点：如果服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作\n\n**分布式版本控制工具**：Git、Mercurial、Bazaar、Darcs\n\n- 客户端提取的不是最新版本的文件快照，而是把代码仓库完整地镜像下来（本地库）\n\n- 这样任何一处协同工作用的文件发生故障，事后都可以用其他客户端的本地仓库进行恢复（因为每个客户端的每一次文件提取操作，实际上都是一次对整个文件仓库的完整备份）\n\n- 解决了集中式版本控制系统的缺陷\n\n  - 服务器断网的情况下也可以进行开发（因为版本控制是在本地进行的）\n\n  - 每个客户端保存的也都是整个完整的项目（包含历史记录，更加安全）\n\n\n\n## Git本地仓库语法\n\n### Git安装\n\n[Git 详细安装教程](https://blog.csdn.net/mukes/article/details/115693833)\n\n[Git - 安装 Git (git-scm.com)](https://git-scm.com/book/zh/v2/起步-安装-Git)\n\n### 细节/注意事项\n\n1、盘路径：如c盘：/c/\n\n2、仓库内可以使用任意linux命令\n\n### 状态切换命令\n\n#### 配置身份\n\n- 配置用户名：git config --global [user.name](http://user.name/) 用户名\n\n- 配置邮箱：git config --global user.email 邮箱地址\n\n\n#### 初始化仓库（git init）\n\n- 进入某个仓库：cd  仓库路径\n\n- 初始化本地库：git init!\n\n- 删除仓库\n\n  - 删除  .git 目录\n\n- 查看本地库状态（git status）\n\n  - git status\n  - 红色为未添加到暂存区（增删改都会改变）\n  - 绿色为已添加到暂存区\n  - 提交仓库后信息（表示干净）\n#### 暂存区\n\n- 添加到暂存区（git add）\n\n  - 一个文件：git add 文件名\n\n  - 一个目录：git add 目录名\n\n  - 所有文件：git add .\n\n- 从暂存区删除（git rm --cached）\n  - git rm --cached 文件名\n\n#### 本地仓库\n\n提交本地库（git commit -m）\n\n- 提交所有文件：git commit -m \"提交信息\"\n- 提交一个文件：git commit -m  \"日志信息\"   文件名\n\n### 版本控制命令\n\n##### 查看版本\n\n- git reflog 查看版本信息\n- git log 查看版本详细信息\n##### 版本切换\n\n- git reset --hard 版本号\n### 分支操作命令\n\n#### 概念：\n\n- 在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支\n\n- 使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行\n\n- 对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本（分支底层其实也是指针的引用）\n\n#### 作用：\n\n- 同时并行推进多个功能开发，提高开发效率\n\n- 各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响（失败的分支删除重新开始即可）\n\n#### 基本分支命令\n\n##### 操作\n\n- 仓库开始位于master\n\n- 创建完分支后就可以使用该分支了，且该分支状态是原来分支的状态（代码一样）\n\n##### 创建分支：\n\n```\ngit branch 分支名\n```\n\n##### 删除分支\n\n已合并分支\n\n```\ngit branch -d <branch_name>\n```\n\n强制删除一个尚未合并的分支\n\n```\ngit branch -D <branch_name>\n```\n\n\n##### 查看分支：\n\ngit branch -v\n\n\n##### 切换分支：\n\ngit checkout 分支名\n\n#### 合并分支\n\ngit merge 分支名\n\n##### 细节\n\n- 如果不提交事务，则任一修改文件，所有文件都会变化\n\n- 合并分支发生冲突解决后，只会改变合并那个分支，而不会改变其他分支\n\n##### 普通\n\n- 把指定的分支合并到当前分支上：git merge 分支名\n\n\n##### MERGING\n\n两个分支在同一个文件的同一个位置有两套完全不同的修改\n\n**步骤**\n\n1、出现冲突（进入冲突界面）\n2、查看问题：git  status\n\n3、解决问题\n\n（1）把冲突代码修改\n\n（2）提交事务（记住不要带文件名）\n\n### Git归纳\n\n#### 区域\n\n**工作目录**（Working Directory）：也称为工作树，是你当前正在操作的项目文件所在的目录。在工作目录中，你可以添加、修改和删除文件，这些操作都会直接影响到你的项目。工作目录是你进行实际开发工作的地方。（切换版本跟分支会改变工作目录）\n\n**暂存区**（Staging Area）：也称为索引（Index），是介于工作目录和版本库之间的缓冲区域。在暂存区，你可以暂存（Stage）将要提交的文件更改，以备下一步的提交。暂存区让你能够选择性地提交文件，只提交你想要的更改，而不是所有修改。（所有版本的暂存区都是一样的，也就是说，暂存区独立于仓库）\n\n**版本库**（Repository）：也称为仓库，是Git用来存储项目的所有历史记录和元数据的地方。版本库包含项目的所有提交历史，每个提交都包含了项目的完整快照以及与之相关的元数据信息，如作者、提交时间等。版本库通常分为本地版本库和远程版本库，本地版本库位于你的计算机上，而远程版本库位于远程服务器上，用于协作和备份。（就是一个保存多个版本的仓库）\n\n#### 版本切换\n\n（1）未修改，切换版本，不影响代码\n\n（2）已修改，且提交，切换版本，不影响代码\n\n（3）已修改，未提交，切换版本\n\n​	新建文件：会一起保存到工作目录和暂存区，切换时，新增文件会一起切换\n\n​	修改文件：丢失修改，不影响切换版本\n\n​	删除文件：丢失删除，不影响切换版本\n\n#### 分支切换\n\n（1）未修改，切换分支，不影响代码\n\n（2）已修改，且提交，切换分支，不影响代码\n\n（3）已修改，未提交，切换分支\n\n​	新建文件：会一起保存到工作目录和暂存区，切换时，新增文件会一起切换\n\n​	修改文件：丢失修改，不影响切换\n\n​	删除文件：丢失删除，不影响切换\n\n#### 分支合并\n\n（1）分支合并的是合并最新版本\n\n**！！！！  总之，在切换版本、分支时，要记住提交事务，把暂存区清空 ！！！！**\n\n\n\n## Git远程仓库语法\n\n#### 远程信息\n\n##### 查看远程仓库\n\n- 查看所有远程仓库：`git remote -v`\n- 查看特定远程仓库的详细信息（如 URL）：`git remote show <remote-name>`\n\n##### 添加远程仓库\n\n- 添加一个名为 `origin` 的远程仓库（通常用于首次克隆后的新仓库）：`git remote add origin <url>`\n- 添加一个具有其他名称的远程仓库：`git remote add <remote-name> <url>`\n\n##### 删除远程仓库\n\n- 删除名为 `origin` 的远程仓库：`git remote remove origin`\n- 删除名为 `<remote-name>` 的远程仓库：`git remote remove <remote-name>`\n\n##### 设置远程仓库的 URL\n\n- 更改名为 `origin` 的远程仓库的 URL：`git remote set-url origin <new-url>`\n- 更改名为 `<remote-name>` 的远程仓库的 URL：`git remote set-url <remote-name> <new-url>`\n\n##### 获取远程仓库的分支列表\n\n- 获取 `origin` 的所有分支列表：`git branch -r`\n- 获取 `<remote-name>` 的所有分支列表：`git branch -r -a | grep <remote-name>/`\n\n##### 跟踪远程分支\n\n- 使用 `--track` 选项在创建本地分支时自动跟踪远程分支：`git checkout --track origin/<branch-name>` 或 `git checkout -b <local-branch-name> origin/<branch-name>`\n- 更改已存在的本地分支以跟踪远程分支：`git branch -u origin/<branch-name>`\n\n\n\n#### 远程 》本地\n\n##### 从远程仓库拉取代码\n\n- 从 `origin` 的 `master` 分支拉取最新代码并合并到当前分支（如果当前分支与 `master` 分支相同，则直接拉取并更新）：`git pull origin master`\n- 从 `<remote-name>` 的 `<branch-name>` 分支拉取最新代码并合并到当前分支：`git pull <remote-name> <branch-name>`\n\n##### 克隆远程仓库\n\n- 克隆一个远程仓库到本地：`git clone <url>`\n- 克隆并指定一个不同的本地目录名：`git clone <url> <directory-name>`\n\n##### 拉取并合并远程分支到当前分支\n\n但通常建议使用 `git pull`\n\n- `git fetch origin <branch-name>:<local-branch-name>`：拉取远程分支到本地，但不会自动合并。\n- 接着，你可以使用 `git merge <local-branch-name>` 来合并这个分支。\n\n\n\n#### 本地 》远程\n\n##### 推送代码到远程仓库\n\n- 将当前分支的最新更改推送到 `origin` 的 `master` 分支：`git push origin master`\n- 将 `<branch-name>` 分支的最新更改推送到 `<remote-name>`：`git push <remote-name> <branch-name>`\n- 如果远程分支尚不存在，可以使用 `-u` 或 `--set-upstream` 选项设置上游（upstream）分支，以便后续的 `git pull` 和 `git push` 命令可以省略远程仓库和分支名称：`git push -u origin <branch-name>`\n\n### 注意事项\n\n#### 推送分支\n\n如果远程分支不存在，直接推送新分支不影响\n\n如果分支存在了，应该先拉取分支，然后再本地分支修改合并，然后推送到远程仓库\n\n#### 拉取分支\n\n如果本地目录还没有仓库，可以拉取任意仓库分支\n\n拉取分支时，最好只拉取一次，或者只有一个分支\n\n如果拉取多个分支到一个本地仓库，那么这几个分支应该是由一个主分支分的（即每一个分支有关联）\n\n拉取多个分支时，分支应该有共同祖先\n\n\n\n## GitHub\n\n### 创建远程仓库\n\n1\n\n<img src=\"https://api2.mubu.com/v3/document_image/d5469b41-a88b-4532-a4cd-14b97d9ab198-18846868.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n2\n\n<img src=\"https://api2.mubu.com/v3/document_image/85c58d8f-cea7-4fd2-9af8-0f8059c6b2da-18846868.jpg\" alt=\"img\" style=\"zoom:50%;\" />\n\n### 删除远程仓库\n\n1、点击settings\n\n\n2、拉到最底下，点击 Delete this repository\n\n### 创建远程仓库别名\n\n- 1、复制远程库名字\n\n- 2、在git中起别名（注意，需要在git仓库中）\n### 推送本地分支到远程仓库\n\n### 克隆远程仓库到本地\n\n- 1、复制远程仓库地址\n- 2、git获取\n- 3、自动实现：拉取代码、初始化本地仓库、创建别名',27,'开发工具','git',1,64,0,0,'2024-05-17 14:14:08','2024-05-17 14:14:08'),(11,'IDEA快捷键','','http://114.132.41.159/admin/dist/img/rand/23.jpg','### 常用的快捷键：\n\n| 快捷键组合                  | 实现效果                                            |\n| --------------------------- | --------------------------------------------------- |\n| psvm + Tab键 / main + Tab键 | public static void main(String[] args)              |\n| sout + Tab键                | System.out.println()                                |\n| Ctrl + X                    | 删除当前行                                          |\n| Ctrl +D                     | 复制当前行                                          |\n| Alt+Insert(或右键Generate)  | 生成代码(如get,set方法,构造函数等)                  |\n| Ctrl+Alt+T                  | 生成try catch （或者 Alt+enter选择）                |\n| CTRL+ALT+T                  | 把选中的代码放在 TRY{} IF{} ELSE{} 里               |\n| Ctr+shift+U                 | 实现大小写之间的转化                                |\n| ALT+回车                    | 导入包,自动修正                                     |\n| CTRL+ALT+L                  | 格式化代码                                          |\n| CTRL+ALT+I                  | 自动缩进                                            |\n| CTRL+E                      | 最近更改的代码                                      |\n| fori                        | 生成for (int i = 0; i < ; i++) {}                   |\n| Alt + <–左右–>键            | 实现窗口左右更换（多窗口）                          |\n| Ctrl + 鼠标点击             | 快速找到成员变量的出处                              |\n| Shift+F6                    | 重构/重命名 (包、类、方法、变量、甚至注释等)        |\n| CTRL+Q                      | 查看当前方法的声明                                  |\n| Ctrl+Alt+V                  | 自动创建变量（new 对象();之后选择按快捷键）         |\n| Ctrl+O                      | 重写方法                                            |\n| Ctrl+I                      | 实现方法                                            |\n| ALT+/                       | 代码提示                                            |\n| Ctrl+Shift+R                | 在当前项目中替换指定内容                            |\n| Ctrl+E                      | 最近编辑的文件列表                                  |\n| Ctrl+P                      | 显示方法参数信息                                    |\n| Ctrl+Shift+Insert           | 查看历史复制记录，idea可以保留历史复制的 100 条记录 |\n\n### sout相关：\n\n| 生成控制台的相关快捷键 | 描述                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| sout + Tab键           | 生成System.out.println();，输出到控制台语句并换行。          |\n| souf + Tab键           | 生成System.out.printf(\"\");,输出一个格式化字符串到控制台。    |\n| soutm + Tab键          | 生成System.out.println(\"类名.方法名\");，输出当前 类和方法名 到控制台。 |\n| soutp + Tab键          | 生成System.out.println(所有方法参数名+值);，输出当前 方法的参数名和值 到控制台。 |\n\n### 查找\n\n| 快捷键                 | 介绍                         |\n| ---------------------- | ---------------------------- |\n| Ctrl + F               | 在当前文件进行文本查找       |\n| Ctrl + R               | 在当前文件进行文本替换       |\n| Shift + Ctrl + F       | 在项目进行文本查找           |\n| Shift + Ctrl + R       | 在项目进行文本替换           |\n| Shift + Shift          | 快速搜索                     |\n| Ctrl + N               | 查找class                    |\n| Ctrl + Shift + N       | 查找文件                     |\n| Ctrl + Shift + Alt + N | 查找symbol（查找某个方法名） |\n\n### 跳转切换\n\n| 快捷键           | 介绍                  |\n| ---------------- | --------------------- |\n| Ctrl + E         | 最近文件              |\n| Ctrl + Tab       | 切换文件              |\n| Ctrl + Alt + ←/→ | 跳转历史光标所在处    |\n| Alt + ←/→ 方向键 | 切换子tab             |\n| Ctrl + G         | go to（跳转指定行号） |\n\n### 编码相关\n\n| 快捷键                      | 介绍                                                         |\n| --------------------------- | ------------------------------------------------------------ |\n| Ctrl + W                    | 快速选中                                                     |\n| (Shift + Ctrl) + Alt + J    | 快速选中同文本                                               |\n| Ctrl + C/Ctrl + X/Ctrl + D  | 快速复制或剪切                                               |\n| 多行选中 Tab / Shift + Tab  | tab                                                          |\n| Ctrl + Y                    | 删除整行                                                     |\n| 滚轮点击变量/方法/类        | 快速进入变量/方法/类的定义处                                 |\n| Shift + 点击Tab             | 快速关闭tab                                                  |\n| Ctrl + Z 、Ctrl + Shift + Z | 后悔药，撤销/取消撤销                                        |\n| Ctrl + Shift + enter        | 自动收尾，代码自动补全                                       |\n| Alt + enter                 | IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 |\n| Alt + ↑/↓                   | 方法快速跳转                                                 |\n| F2                          | 跳转到下一个高亮错误 或 警告位置                             |\n| Alt + Insert                | 代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等 |\n| Ctrl + Shift + L            | 格式化代码                                                   |\n| Shift + F6                  | 快速修改方法名、变量名、文件名、类名等                       |\n| Ctrl + F6                   | 快速修改方法签名                                             |\n\n### 代码阅读相关\n\n| 快捷键                     | 介绍                               |\n| -------------------------- | ---------------------------------- |\n| Ctrl + P                   | 方法参数提示显示                   |\n| Ctrl + Shift + i           | 就可以在当前类里再弹出一个窗口出来 |\n| Alt + F7                   | 可以列出变量在哪些地方被使用了     |\n| 光标在子类接口名，Ctrl + u | 跳到父类接口                       |\n| Alt + F1 + 1， esc         |                                    |\n| (Shift) + Ctrl + +/-       | 代码块折叠                         |\n| Ctrl + Shift + ←/→         | 移动窗口分割线                     |\n| Ctrl + (Alt) + B           | 跳转方法定义/实现                  |\n| Ctrl + H                   | 类的层级关系                       |\n| Ctrl + F12                 | Show Members 类成员快速显示        |\n\n### 版本管理相关\n\n| 快捷键       | 介绍             |\n| ------------ | ---------------- |\n| Ctrl + D     | Show Diff        |\n| (Shift) + F7 | （上）下一处修改 |',27,'开发工具','工具使用',1,90,0,0,'2024-05-17 16:02:42','2024-05-17 16:02:42'),(12,'JVM基础','','http://114.132.41.159/admin/dist/img/rand/9.jpg','# 1、JVM基础\n\nhttps://lisxpq12rl7.feishu.cn/wiki/ZaKnwhhhmiDu9ekUnRNcv2iNnof\n\n## 1.1 什么是JVM\n\nJVM 全称是 Java Virtual Machine，中文译名 Java虚拟机。JVM 本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件。\n\nJava源代码执行流程如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392597-280.png)\n\n分为三个步骤：\n\n1、编写Java源代码文件。\n\n2、使用Java编译器（javac命令）将源代码编译成Java字节码文件。\n\n3、使用Java虚拟机加载并运行Java字节码文件，此时会启动一个新的进程。\n\n## 1.2 JVM的功能\n\n- 1 - 解释和运行\n- 2 - 内存管理\n- 3 - 即时编译\n\n### 1.2.1 解释和运行\n\n当Java程序运行时，JVM会将Java字节码文件加载到内存中，并逐条解释执行其中的指令。这种解释执行的方式使得Java程序具有跨平台性，因为不同的操作系统只需要提供不同的JVM实现即可运行相同的Java程序。\n\n对字节码文件中的指令，实时的解释成机器码，让计算机执行。\n\n字节码文件中包含了字节码指令，计算器无法直接执行，Java虚拟机会将字节码文件中的字节码指令实时地解释成机器码，机器码是计算机可以运行的指令。\n\n![img](./7.1、JVM基础篇.assets/1715579392350-1.png)\n\n### 1.2.2 内存管理\n\n- 自动为对象、方法等分配内存\n- 自动的垃圾回收机制，回收不再使用的对象\n\nJava虚拟机会帮助程序员为对象分配内存，同时将不用的对象使用垃圾回收器回收掉，这是对比C和C++这些语言的一个优势。在C/C++语言中，对象的回收需要程序员手动去编写代码完成，如果遗漏了这段删除对象的代码，这个对象就会永远占用内存空间，不会再回收。所以JVM的这个功能降低了程序员编写代码的难度。\n\n### 1.2.3 即时编译\n\n对热点代码进行优化，提升执行效率。即时编译可以说是提升Java程序性能最核心的手段。\n\n为了提高Java程序的执行效率，JVM引入了即时编译（JIT）技术。JIT编译器在运行时将那些经常运行的代码块（热点代码）编译成与平台相关的机器语言，从而提高程序的执行效率。与传统的编译器事先编译不同，JIT编译器在运行时进行编译，因此可以针对特定的运行环境进行优化。\n\n#### Java性能低的主要原因和跨平台特性\n\nJava语言如果不做任何的优化，性能其实是不如C和C++语言的。主要原因是：\n\n在程序运行过程中，Java虚拟机需要将字节码指令实时地解释成计算机能识别的机器码，这个过程在运行时可能会反复地执行，所以效率较低。\n\n![img](./7.1、JVM基础篇.assets/1715579392350-2.png)\n\nC和C++语言在执行过程中，只需要将源代码编译成可执行文件，就包含了计算机能识别的机器码，无需在运行过程中再实时地解释，所以性能较高。\n\n![img](./7.1、JVM基础篇.assets/1715579392350-3.png)\n\nJava为什么要选择一条执行效率比较低的方式呢？主要是为了实现跨平台的特性。Java的字节码指令，如果希望在不同平台（操作系统+硬件架构），比如在windows或者linux上运行。可以使用同一份字节码指令，交给windows和linux上的Java虚拟机进行解释，这样就可以获得不同平台上的机器码了。这样就实现了Write Once，Run Anywhere 编写一次，到处运行 的目标。\n\n![img](./7.1、JVM基础篇.assets/1715579392350-4.png)\n\n但是C/C++语言，如果要让程序在不同平台上运行，就需要将一份源代码在不同平台上分别进行编译，相对来说比较麻烦。\n\n再回到即时编译，在JDK1.1的版本中就推出了即时编译去优化对应的性能。\n\n![img](./7.1、JVM基础篇.assets/1715579392350-5.png)\n\n虚拟机在运行过程中如果发现某一个方法甚至是循环是热点代码（被非常高频调用），即时编译器会优化这段代码并将优化后的机器码保存在内存中，如果第二次再去执行这段代码。Java虚拟机会将机器码从内存中取出来直接进行调用。这样节省了一次解释的步骤，同时执行的是优化后的代码，效率较高。\n\nJava通过即时编译器获得了接近C/C++语言的性能，在某些特定的场景下甚至可以实现超越。\n\n## 1.3 JVM的类型\n\n### 1.3.1 Java虚拟机规范\n\n- 《Java虚拟机规范》由Oracle制定，内容主要包含了Java虚拟机在设计和实现时需要遵守的规范，主要包含class字节码文件的定义、类和接口的加载和初始化、指令集等内容。\n- 《Java虚拟机规范》是对虚拟机设计的要求，而不是对Java设计的要求，也就是说虚拟机可以运行在其他的语言比如Groovy、Scala生成的class字节码文件之上。\n- 官网地址：https://docs.oracle.com/javase/specs/index.html\n\n### 1.3.2 Java的常见类型\n\n平时我们最常用的，就是Hotspot虚拟机。\n\n| 名称                       | 作者    | 支持版本                  | 社区活跃度（github star） | 特性                                                         | 适用场景                             |\n| -------------------------- | ------- | ------------------------- | ------------------------- | ------------------------------------------------------------ | ------------------------------------ |\n| HotSpot (Oracle JDK版)     | Oracle  | 所有版本                  | 高(闭源)                  | 使用最广泛，稳定可靠，社区活跃JIT支持Oracle JDK默认虚拟机    | 默认                                 |\n| HotSpot (Open JDK版)       | Oracle  | 所有版本                  | 中(16.1k)                 | 同上开源，Open JDK默认虚拟机                                 | 默认对JDK有二次开发需求              |\n| GraalVM                    | Oracle  | 11, 17,19企业版支持8      | 高（18.7k）               | 多语言支持高性能、JIT、AOT支持                               | 微服务、云原生架构需要多语言混合编程 |\n| Dragonwell JDK龙井         | Alibaba | 标准版 8,11,17扩展版11,17 | 低(3.9k)                  | 基于OpenJDK的增强高性能、bug修复、安全性提升JWarmup、ElasticHeap、Wisp特性支持 | 电商、物流、金融领域对性能要求比较高 |\n| Eclipse OpenJ9 (原 IBM J9) | IBM     | 8,11,17,19,20             | 低(3.1k)                  | 高性能、可扩展JIT、AOT特性支持                               | 微服务、云原生架构                   |\n\n### 1.3.3 HotSpot的发展历程\n\n##### 初出茅庐 - 1999年4月  \n\n源自1997年收购的SmallTalk语言的虚拟机，HotSpot虚拟机初次在JDK中使用。在JDK1.2中作为附加功能存在，\n\nJDK1.3之后作为默认的虚拟机。\n\n##### 野蛮生长 - 2006年12月\n\nJDK 6发布，并在虚拟机层面做了大量的优化，这些优化对后续虚拟机的发展产生了深远的影响。\n\n##### 稳步前进 - 2009-2013\n\nJDK7中首次推出了G1垃圾收集器。收购了Sun公司之后，吸纳了JRockIt虚拟机的一些设计思想，JDK8中引入了JMC等工具，去除了永久代。\n\n##### 百家争鸣 - 2018-2019\n\nJDK11优化了G1垃圾收集器的性能,同时推出了ZGC新一代的垃圾回收器，JDK12推出Shenan-doah垃圾回收器。\n\n##### 拥抱云原生 - 2019-至今\n\n以Hotspot为基础的GraalVM虚拟机诞生，不仅让解决了单体应用中多语言整合的难题，同时也提升了这些语言运行时的效率。极高的性能、极快的启动速度也更适用于当下的云原生架构。\n\n## 1.4 Java生态框架\n\n![img](./7.1、JVM基础篇.assets/f1a6827a-d993-4e03-95c8-f8fd784d6afe-18846868-1715671919992-1.jpg)\n\n#### JDK发展历程\n\n2000年，JDK 1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。\n2002年，JDK 1.4发布，古老的Classic虚拟机退出历史舞台。\n2003年年底，Java平台的Scala正式发布，同年Groovy也加入了 Java阵营。\n2006年，JDK 6发布。同年，Java开源并建立了 OpenJDK。顺理成章，Hotspot虚拟机也成为了 OpenJDK中的默认虚拟机。\n2007年，Java平台迎来了新伙伴Clojure。\n2008 年，Oracle 收购了 BEA,得到了 JRockit 虚拟机。\n2009年，Twitter宣布把后台大部分程序从Ruby迁移到Scala，这是Java平台的又一次大规模应用。\n2010年，Oracle收购了Sun，获得Java商标和最具价值的HotSpot虚拟机。此时，Oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit.  JCP组织管理：Java语言\n2011年，JDK7发布。在JDK 1.7u4中，正式启用了新的垃圾回收器G1。\n2017年，JDK9发布。将G1设置为默认GC，替代CMS (被标记为Deprecated)\n同年，IBM的J9开源，形成了现在的Open J9社区\n2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元\n同年，JDK11发布，LTS版本的JDK,发布革命性的ZGC,调整JDK授权许可\n2019年，JDK12发布，加入RedHat领导开发的Shenandoah GC\n\n#### Oracle与OpenJDK之间的主要区别\n\n1. Oracle JDK版本将每三年发布一次LTS版本，而OpenJDK版本每三个月发布一次。\n2. Oracle JDK将更多地关注稳定性，它重视更多的企业级用户，而OpenJDK经常发布以支持其他性能，这可能会导致不稳定。\n3. Oracle JDK支持长期发布的更改，而Open JDK仅支持计划和完成下一个发行版。\n4. Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。 使用Oracle平台时会产生一些许可影响。如Oracle 宣布的那样，在没有商业许可的情况下，在2019年1月之后发布的Oracle Java SE 8的公开更新将无法用于商业，商业或生产用途。但是，OpenJDK是完全开源的，可以自由使用。\n5. Oracle JDK的构建过程基于OpenJDK，因此OpenJDK与Oracle JDK之间没有技术差异。\n6. 顶级公司正在使用Oracle JDK，例如Android Studio，Minecraft和IntelliJ IDEA开发工具，其中Open JDK不太受欢迎。\n7. Oracle JDK具有Flight Recorder，Java Mission Control和Application Class-Data Sharing功能，Open JDK具有Font Renderer功能，这是OpenJDK与Oracle JDK之间的显着差异。\n8. Oracle JDK具有良好的GC选项和更好的渲染器，而OpenJDK具有更少的GC选项，并且由于其包含自己的渲染器的分布，因此具有较慢的图形渲染器选项。\n9. 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能。\n10. 与OpenJDK相比，Oracle JDK的开源社区较少，OpenJDK社区用户的表现优于Oracle JDK发布的功能，以提高性能。\n11. 如果使用Oracle JDK会产生许可影响，而OpenJDK没有这样的问题，并且可以以任何方式使用，以满足完全开源和免费使用。\n12. Oracle JDK在运行JDK时不会产生任何问题，而OpenJDK在为某些用户运行JDK时会产生一些问题。\n13. 根据使用方的使用和许可协议，现有应用程序可以从Oracle JDK迁移到Open JDK，反之亦然。\n14. Oracle JDK将从其10.0.X版本将收费，用户必须付费或必须依赖OpenJDK才能使用其免费版本。\n15. Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本。\n16. Oracle JDK以前的1.0版以前的版本是由Sun开发的，后来被Oracle收购并为其他版本维护，而OpenJDK最初只基于Java SDK或JDK版本7。\n17. Oracle JDK发布时大多数功能都是开源的，其中一些功能免于开源，并且根据Sun的许可授权，而OpenJDK发布了所有功能，如开源和免费。\n18. Oracle JDK完全由Oracle公司开发，而Open JDK项目由IBM，Apple，SAP AG，Redhat等顶级公司加入和合作。\n\n## 1.5 JVM组成框架\n\n![image-20240403000639342](./7.1、JVM基础篇.assets/image-20240403000639342-1715671919992-2.png)\n\n![img](./7.1、JVM基础篇.assets/024c674e-5c88-4b39-b2d5-e948e91c814e-18846868-1712127848702-3-1715671919992-3.jpg)\n\n![image-20240403154753322](./7.1、JVM基础篇.assets/image-20240403154753322-1715671919992-4.png)\n\n![image-20240403153528645](./7.1、JVM基础篇.assets/image-20240403153528645-1715671919992-5.png)\n\n\n\n**最上层**：javac编译器将编译好的字节码class文件，通过java 类装载器执行机制，把对象或class文件存放在 jvm划分内存区域。\n**中间层**：称为Runtime Data Area，主要是在Java代码运行时用于存放数据的，从左至右为方法区(永久代、元数据区)、堆(共享,GC回收对象区域)、栈、程序计数器、寄存器、本地方法栈(私有)。\n**最下层**：解释器、JIT(just in time)编译器和 GC（Garbage Collection，垃圾回收器）\n\n**类加载子系统**：核心组件类加载器，负责将字节码文件中的内容加载到内存中。\n\n**运行时数据区**：JVM管理的内存，创建出来的对象、类的信息等等内容都会放在这块区域中。\n\n**执行引擎**：包含了即时编译器、解释器、垃圾回收器，执行引擎使用解释器将字节码指令解释成机器码，使用即时编译器优化性能，使用垃圾回收器回收不再使用的对象。\n\n**本地接口**：调用本地使用C/C++编译好的方法，本地方法在Java中声明时，都会带上native关键字，如下图所示。\n\n![img](./7.1、JVM基础篇.assets/1715579392350-7.png)\n\n## 1.6 JVM功能框架\n\n![image-20240514153726631](./7.1、JVM基础篇.assets/image-20240514153726631.png)\n\n# 2、字节码文件详解\n\n## 2.2 字节码文件的组成\n\n### 2.2.1 以正确的姿势打开文件\n\n字节码文件中保存了源代码编译之后的内容，以二进制的方式存储，无法直接用记事本打开阅读。\n\n通过NotePad++使用十六进制插件查看class文件：\n\n![img](./7.1、JVM基础篇.assets/1715579392350-8.png)\n\n无法解读出文件里包含的内容，推荐使用 jclasslib工具查看字节码文件。 Github地址： https://github.com/ingokegel/jclasslib\n\n安装方式：找到 资料\\工具\\jclasslib_win64_6_0_4.exe 安装即可\n\n![img](./7.1、JVM基础篇.assets/1715579392351-9.png)\n\n### 2.2.2 字节码文件的组成\n\n字节码文件总共可以分为以下几个部分：\n\n- **基础信息**：魔数、字节码文件对应的Java版本号、访问标识(public final等等)、父类和接口信息\n- **常量池：** 保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用\n- **字段：** 当前类或接口声明的字段信息\n  - 字节码中的字段指的是类或接口中声明的变量，用于存储对象的状态或数据。字段在字节码中用 `field_info` 结构表示，其中包含字段的名称、类型、访问标志等信息。字节码指令可以通过字段的名称或索引来读取或写入字段的值。\n  - 字段表示类或接口中声明的变量，用于存储对象的状态或数据。\n\n- **方法：** 当前类或接口声明的方法信息，核心内容为方法的字节码指令\n- **属性：** 类的属性，比如源码的文件名、内部类的列表等\n  - 字节码中的属性是一种用于附加额外信息于类、字段、方法或代码段的机制。属性在字节码中用 `attribute_info` 结构表示，常见的属性包括源文件信息、行号表、局部变量表、异常表等。属性提供了额外的元数据，用于调试、优化或其他用途。\n  - 属性表示与类、字段、方法或代码段相关的附加信息。\n\n\n#### 2.2.2.1 基本信息\n\n基本信息包含了jclasslib中能看到的两块内容：\n\n![img](./7.1、JVM基础篇.assets/1715579392351-10.png)\n\n##### Magic魔数\n\n每个Java字节码文件的前四个字节是固定的，用16进制表示就是0xcafebabe。文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改不影响文件的内容。软件会使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错。\n\n比如常见的文件格式校验方式如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392351-11.png)\n\nJava字节码文件中，将文件头称为magic魔数。Java虚拟机会校验字节码文件的前四个字节是不是0xcafebabe，如果不是，该字节码文件就无法正常使用，Java虚拟机会抛出对应的错误。\n\n##### 主副版本号\n\n主副版本号指的是编译字节码文件时使用的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1使用了45.0-45.3，JDK1.2是46之后每升级一个大版本就加1；副版本号是当主版本号相同时作为区分不同版本的标识，一般只需要关心主版本号。\n\n1.2之后大版本号计算方法就是 : 主版本号 – 44，比如主版本号52就是JDK8。\n\n![img](./7.1、JVM基础篇.assets/1715579392351-12.png)\n\n版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容。如果使用较低版本的JDK去运行较高版本JDK的字节码文件，无法使用会显示如下错误：\n\n![img](./7.1、JVM基础篇.assets/1715579392351-13.png)\n\n有两种方案：\n\n1.升级JDK版本，将图中使用的JDK6升级至JDK8即可正常运行，容易引发其他的兼容性问题，并且需要大量的测试。\n\n2.将第三方依赖的版本号降低或者更换依赖，以满足JDK版本的要求。建议使用这种方案\n\n##### 其他基础信息\n\n其他基础信息包括访问标识、类和接口索引，如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392351-14.png)\n\n#### 2.2.2.2 常量池\n\n字节码文件中常量池的作用：避免相同的内容重复定义，节省空间。如下图，常量池中定义了一个字符串，字符串的字面量值为123。\n\n![img](./7.1、JVM基础篇.assets/1715579392351-15.png)\n\n比如在代码中，编写了两个相同的字符串“我爱北京天安门”，字节码文件甚至将来在内存中使用时其实只需要保存一份，此时就可以将这个字符串以及字符串里边包含的字面量，放入常量池中以达到节省空间的作用。\n\n```Java\nString str1 = \"我爱北京天安门\";\nString str2 = \"我爱北京天安门\";\n```\n\n常量池中的数据都有一个编号，编号从1开始。比如“我爱北京天安门”这个字符串，在常量池中的编号就是7。在字段或者字节码指令中通过编号7可以快速的找到这个字符串。\n\n字节码指令中通过编号引用到常量池的过程称之为符号引用。\n\n![img](./7.1、JVM基础篇.assets/1715579392351-16.png)\n\n#### 2.2.2.3 字段\n\n字段中存放的是当前类或接口声明的字段信息。\n\n如下图中，定义了两个字段a1和a2，这两个字段就会出现在字段这部分内容中。同时还包含字段的名字、描述符（字段的类型）、访问标识（public/private static final等）。\n\n![img](./7.1、JVM基础篇.assets/1715579392351-17.png)\n\n#### 2.2.2.4 方法\n\n字节码中的方法区域是存放**字节码****指令**的核心位置，字节码指令的内容存放在方法的Code属性中。\n\n![img](./7.1、JVM基础篇.assets/1715579392351-18.png)\n\n通过分析方法的字节码指令，可以清楚地了解一个方法到底是如何执行的。先来看如下案例：\n\n```Java\nint i = 0;\nint j = i + 1;\n```\n\n这段代码编译成字节码指令之后是如下内容：\n\n![img](./7.1、JVM基础篇.assets/1715579392351-19.png)\n\n要理解这段字节码指令是如何执行的，我们需要先理解两块内存区域：操作数栈和局部变量表。\n\n**操作数栈**是用来存放临时数据的内容，是一个栈式的结构，先进后出。\n\n**局部变量****表**是存放方法中的局部变量，包含方法的参数、方法中定义的局部变量，在编译期就已经可以确定方法有多少个局部变量。\n\n1、iconst_0，将常量0放入操作数栈。此时栈上只有0。\n\n![img](./7.1、JVM基础篇.assets/1715579392351-20.png)\n\n2、istore_1会从操作数栈中，将栈顶的元素弹出来，此时0会被弹出，放入局部变量表的1号位置。局部变量表中的1号位置，在编译时就已经确定是局部变量i使用的位置。完成了对局部变量i的赋值操作。\n\n![img](./7.1、JVM基础篇.assets/1715579392351-21.png)\n\n3、iload_1将局部变量表1号位置的数据放入操作数栈中，此时栈中会放入0。\n\n![img](./7.1、JVM基础篇.assets/1715579392351-22.png)\n\n4、iconst_1会将常量1放入操作数栈中。\n\n![img](./7.1、JVM基础篇.assets/1715579392352-23.png)\n\n5、iadd会将操作数栈顶部的两个数据相加，现在操作数栈上有两个数0和1，相加之后结果为1放入操作数栈中，此时栈上只有一个数也就是相加的结果1。\n\n![img](./7.1、JVM基础篇.assets/1715579392352-24.png)\n\n6、istore_2从操作数栈中将1弹出，并放入局部变量表的2号位置，2号位置是j在使用。完成了对局部变量j的赋值操作。\n\n![img](./7.1、JVM基础篇.assets/1715579392352-25.png)\n\n7、return语句执行，方法结束并返回。\n\n![img](./7.1、JVM基础篇.assets/1715579392352-26.png)\n\n同理，同学们可以自行分析下i++和++i的字节码指令执行的步骤。\n\ni++的字节码指令如下，其中iinc 1 by 1指令指的是将局部变量表1号位置增加1，其实就实现了i++的操作。\n\n![img](./7.1、JVM基础篇.assets/1715579392352-27.png)\n\n而++i只是对两个字节码指令的顺序进行了更改：\n\n![img](./7.1、JVM基础篇.assets/1715579392352-28.png)\n\n##### 面试题：\n\n问：int i = 0; i = i++; 最终i的值是多少？\n\n答：答案是0，我通过分析字节码指令发现，i++先把0取出来放入临时的操作数栈中，\n\n接下来对i进行加1，i变成了1，最后再将之前保存的临时值0放入i，最后i就变成了0。\n\n#### 2.2.2.5 属性\n\n属性主要指的是类的属性，比如源码的文件名、内部类的列表等。\n\n![img](./7.1、JVM基础篇.assets/1715579392352-29.png)\n\n### 2.2.3 玩转字节码常用工具\n\n#### 2.2.3.1 javap\n\njavap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件内容。\n\n直接输入javap查看所有参数。输入`javap -v` 字节码文件名称 查看具体的字节码信息。如果jar包需要先使用 `jar –xvf` 命令解压。\n\n![img](./7.1、JVM基础篇.assets/1715579392352-30.png)\n\n#### 2.2.3.2 jclasslib插件\n\njclasslib也有Idea插件版本，建议开发时使用Idea插件版本，可以在代码编译之后实时看到字节码文件内容。\n\n安装方式：\n\n1、打开idea的插件页面，搜索jclasslib\n\n![img](./7.1、JVM基础篇.assets/1715579392352-31.png)\n\n2、选中要查看的源代码文件，选择 视图(View) - Show Bytecode With Jclasslib\n\n![img](./7.1、JVM基础篇.assets/1715579392352-32.png)\n\n右侧会展示对应源代码编译后的字节码文件内容：\n\n![img](./7.1、JVM基础篇.assets/1715579392352-33.png)\n\n> tips:\n>\n> 1、一定要选择文件再点击视图(view)菜单，否则菜单项不会出现。\n>\n> 2、文件修改后一定要重新编译之后，再点击刷新按钮。\n\n#### 2.2.3.3 Arthas\n\nArthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率。 官网：https://arthas.aliyun.com/doc/ Arthas的功能列表如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392352-34.png)\n\n**安装方法：**\n\n1、将 资料/工具/arthas-boot.jar 文件复制到任意工作目录。\n\n2、使用`java -jar arthas-boot.jar ` 启动程序。\n\n3、输入需要Arthas监控的进程id。\n\n![img](./7.1、JVM基础篇.assets/1715579392352-35.png)\n\n4、输入命令即可使用。\n\n**dump**\n\n命令详解：https://arthas.aliyun.com/doc/dump.html\n\ndump命令可以将字节码文件保存到本地，如下将`java.lang.String` 的字节码文件保存到了/tmp/output目录下：\n\n```Bash\n$ dump -d /tmp/output java.lang.String\n\n HASHCODE  CLASSLOADER  LOCATION\n null                   /tmp/output/java/lang/String.class\nAffect(row-cnt:1) cost in 138 ms.\n```\n\n**jad**\n\n命令详解：https://arthas.aliyun.com/doc/jad.html\n\njad命令可以将类的字节码文件进行反编译成源代码，用于确认服务器上的字节码文件是否是最新的，如下将demo.MathGame的源代码进行了显示。\n\n```Java\n$ jad --source-only demo.MathGame\n/*\n * Decompiled with CFR 0_132.\n */\npackage demo;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\n\npublic class MathGame {\n    private static Random random = new Random();\n    public int illegalArgumentCount = 0;\n...\n```\n\n## 2.3、类的生命周期\n\n类的生命周期描述了一个类加载、使用、卸载的整个过程。整体可以分为：\n\n- 加载\n- 连接，其中又分为验证、准备、解析三个子阶段\n- 初始化\n- 使用\n- 卸载\n\n![img](./7.1、JVM基础篇.assets/1715579392352-36.png)\n\n### 2.3.1 加载阶段\n\n1、加载(Loading)阶段第一步是类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息，程序员可以使用Java代码拓展的不同的渠道。\n\n- 从本地磁盘上获取文件\n- 运行时通过动态代理生成，比如Spring框架\n- Applet技术通过网络获取字节码文件\n\n2、类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中，方法区中生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息。\n\n![img](./7.1、JVM基础篇.assets/1715579392352-37.png)\n\n4、Java虚拟机同时会在堆上生成与方法区中数据类似的java.lang.Class对象，作用是在Java代码中去获取类的信息以及存储静态字段的数据（JDK8及之后）。\n\n![img](./7.1、JVM基础篇.assets/1715579392352-38.png)\n\n### 2.3.2 连接阶段\n\n连接阶段分为三个子阶段:\n\n- 验证，验证内容是否满足《Java虚拟机规范》。\n- 准备，给静态变量赋初值。\n- 解析，将常量池中的符号引用替换成指向内存的直接引用。\n\n![img](./7.1、JVM基础篇.assets/1715579392352-39.png)\n\n#### 验证\n\n验证的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与。主要包含如下四部分，具体详见《Java虚拟机规范》：\n\n1、文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-40.png)\n\n2、元信息验证，例如类必须有父类（super不能为空）。\n\n3、验证程序执行指令的语义，比如方法内的指令执行中跳转到不正确的位置。\n\n4、符号引用验证，例如是否访问了其他类中private的方法等。\n\n对版本号的验证，在JDK8的源码中如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392353-41.png)\n\n编译文件的主版本号不能高于运行环境主版本号，如果主版本号相等，副版本号也不能超过。\n\n#### 准备\n\n准备阶段为静态变量（static）分配内存并设置初值，每一种基本数据类型和引用数据类型都有其初值。\n\n| **数据类型**     | **初始值**   |\n| ---------------- | ------------ |\n| **int**          | **0**        |\n| **long**         | **0L**       |\n| **short**        | **0**        |\n| **char**         | **‘\\u0000’** |\n| **byte**         | **0**        |\n| **boolean**      | **false**    |\n| **double**       | **0.0**      |\n| **引用数据类型** | **null**     |\n\n如下代码：\n\n```Java\npublic class Student{\n\npublic static int value = 1;\n\n}\n```\n\n在准备阶段会为value分配内存并赋初值为0，在初始化阶段才会将值修改为1。\n\n> final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。\n>\n> 如下例子中，变量加上final进行修饰，在准备阶段value值就直接变成1了，因为final修饰的变量后续不会发生值的变更。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-42.png)\n\n来看这个案例：\n\n```Java\npublic class HsdbDemo {\n    public static final int i = 2;\n    public static void main(String[] args) throws IOException, InstantiationException, IllegalAccessException {\n        HsdbDemo hsdbDemo = new HsdbDemo();\n        System.out.println(i);\n        System.in.read();\n    }\n}\n```\n\n从字节码文件也可以看到，编译器已经确定了该字段指向了常量池中的常量2：\n\n![img](./7.1、JVM基础篇.assets/1715579392353-43.png)\n\n#### 解析\n\n解析阶段主要是将常量池中的符号引用替换为直接引用，符号引用就是在字节码文件中使用编号来访问常量池中的内容。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-44.png)\n\n直接引用不在使用编号，而是使用内存中地址进行访问具体的数据。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-45.png)\n\n### 2.3.3 初始化阶段\n\n初始化阶段会执行字节码文件中clinit（class init 类的初始化）方法的字节码指令，包含了静态代码块中的代码，并为静态变量赋值。\n\n如下代码编译成字节码文件之后，会生成三个方法：\n\n```Java\npublic class Demo1 {\n\n    public static int value = 1;\n    static {\n        value = 2;\n    }\n   \n    public static void main(String[] args) {\n\n    }\n}\n```\n\n![img](./7.1、JVM基础篇.assets/1715579392353-46.png)\n\n- init方法，会在对象初始化时执行\n- main方法，主方法\n- clinit方法，类的初始化阶段执行\n\n继续来看clinit方法中的字节码指令：\n\n1、iconst_1，将常量1放入操作数栈。此时栈中只有1这个数。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-47.png)\n\n2、putstatic指令会将操作数栈上的数弹出来，并放入堆中静态变量的位置，字节码指令中#2指向了常量池中的静态变量value，在解析阶段会被替换成变量的地址。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-48.png)\n\n3、后两步操作类似，执行value=2，将堆上的value赋值为2。\n\n如果将代码的位置互换：\n\n```Java\npublic class Demo1 {\n    static {\n        value = 2;\n    }\n   \n    public static int value = 1;\n   \n    public static void main(String[] args) {\n\n    }\n}\n```\n\n字节码指令的位置也会发生变化：\n\n![img](./7.1、JVM基础篇.assets/1715579392353-49.png)\n\n这样初始化结束之后，最终value的值就变成了1而不是2。\n\n以下几种方式会导致类的初始化：\n\n1.访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化。\n\n2.调用Class.forName(String className)。\n\n3.new一个该类的对象时。\n\n4.执行Main方法的当前类。\n\n添加-XX:+TraceClassLoading 参数可以打印出加载并初始化的类\n\n#### 面试题1：\n\n如下代码的输出结果是什么？\n\n```Java\npublic class Test1 {\n    public static void main(String[] args) {\n        System.out.println(\"A\");\n        new Test1();\n        new Test1();\n    }\n\n    public Test1(){\n        System.out.println(\"B\");\n    }\n\n    {\n        System.out.println(\"C\");\n    }\n\n    static {\n        System.out.println(\"D\");\n    }\n}\n```\n\n分析步骤：\n\n1、执行main方法之前，先执行clinit指令。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-50.png)\n\n指令会输出D\n\n2、执行main方法的字节码指令。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-51.png)\n\n指令会输出A\n\n3、创建两个对象，会执行两次对象初始化的指令。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-52.png)\n\n这里会输出CB，源代码中输出C这行，被放到了对象初始化的一开始来执行。\n\n所以最后的结果应该是DACBCB\n\n#### clinit不会执行的几种情况\n\n如下几种情况是不会进行初始化指令执行的：\n\n1.无静态代码块且无静态变量赋值语句。\n\n2.有静态变量的声明，但是没有赋值语句。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-53.png)\n\n3.静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-54.png)\n\n#### 面试题2：\n\n如下代码的输出结果是什么？\n\n```Java\npublic class Demo01 {\n    public static void main(String[] args) {\n        new B02();\n        System.out.println(B02.a);\n    }\n}\n\nclass A02{\n    static int a = 0;\n    static {\n        a = 1;\n    }\n}\n\nclass B02 extends A02{\n    static {\n        a = 2;\n    }\n}\n```\n\n分析步骤：\n\n1、调用new创建对象，需要初始化B02，优先初始化父类。\n\n2、执行A02的初始化代码，将a赋值为1。\n\n3、B02初始化，将a赋值为2。\n\n##### 变化\n\n将`new B02();`注释掉会怎么样？\n\n分析步骤：\n\n1、访问父类的静态变量，只初始化父类。\n\n2、执行A02的初始化代码，将a赋值为1。\n\n#### 补充练习题\n\n分析如下代码执行结果:\n\n```Java\npublic class Test2 {\n    public static void main(String[] args) {\n        Test2_A[] arr = new Test2_A[10];\n\n    }\n}\n\nclass Test2_A {\n    static {\n        System.out.println(\"Test2 A的静态代码块运行\");\n    }\n}\n```\n\n数组的创建不会导致数组中元素的类进行初始化。\n\n```Java\npublic class Test4 {\n    public static void main(String[] args) {\n        System.out.println(Test4_A.a);\n    }\n}\n\nclass Test4_A {\n    public static final int a = Integer.valueOf(1);\n\n    static {\n        System.out.println(\"Test3 A的静态代码块运行\");\n    }\n}\n```\n\nfinal修饰的变量如果赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化。\n\n# 2、类加载器\n\n## 2.4、类加载器\n\n### 2.4.1 什么是类加载器\n\n类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术，类加载器只参与加载过程中的字节码获取并加载到内存这一部分。\n\n![img](./7.1、JVM基础篇.assets/1715579392353-55.png)\n\n类加载器会通过二进制流的方式获取到字节码文件的内容，接下来将获取到的数据交给Java虚拟机，虚拟机会在方法区和堆上生成对应的对象保存字节码信息。\n\n### 2.4.2 类加载器的分类\n\n类加载器分为两类，一类是Java代码中实现的，一类是Java虚拟机底层源码实现的。\n\n- 虚拟机底层实现：源代码位于Java虚拟机的源码中，实现语言与虚拟机底层语言一致，比如Hotspot使用C++。主要目的是保证Java程序运行中基础类被正确地加载，比如java.lang.String，Java虚拟机需要确保其可靠性。\n- JDK中默认提供或者自定义：JDK中默认提供了多种处理不同渠道的类加载器，程序员也可以自己根据需求定制，使用Java语言。所有Java中实现的类加载器都需要继承ClassLoader这个抽象类。\n\n类加载器的设计JDK8和8之后的版本差别较大，首先来看JDK8及之前的版本，这些版本中默认的类加载器有如下几种：\n\n![img](./7.1、JVM基础篇.assets/1715579392354-56.png)\n\n类加载器的详细信息可以通过Arthas的classloader命令查看：\n\n> `classloader` - 查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource\n\n![img](./7.1、JVM基础篇.assets/1715579392354-57.png)\n\n- BootstrapClassLoader是启动类加载器，numberOfInstances是类加载器的数量只有1个，loadedCountTotal是加载类的数量1861个。\n- ExtClassLoader是扩展类加载器\n- AppClassLoader是应用程序类加载器\n\n### 2.4.3 启动类加载器\n\n- 启动类加载器（Bootstrap ClassLoader）是由Hotspot虚拟机提供的、使用C++编写的类加载器。\n- 默认加载Java安装目录/jre/lib下的类文件，比如rt.jar，tools.jar，resources.jar等。\n\n运行如下代码：\n\n```Java\n/**\n * 启动程序类加载器案例\n */\npublic class BootstrapClassLoaderDemo {\n    public static void main(String[] args) throws IOException {\n        ClassLoader classLoader = String.class.getClassLoader();\n        System.out.println(classLoader);\n\n        System.in.read();\n    }\n}\n```\n\n这段代码通过String类获取到它的类加载器并且打印，结果是`null`。这是因为启动类加载器在JDK8中是由C++语言来编写的，在Java代码中去获取既不适合也不安全，所以才返回`null`\n\n在Arthas中可以通过`sc -d 类名`的方式查看加载这个类的类加载器详细的信息，比如：\n\n![img](./7.1、JVM基础篇.assets/1715579392354-58.png)\n\n通过上图可以看到，java.lang.String类的类加载器是空的，Hash值也是null。\n\n#### 用户扩展基础jar包\n\n如果用户想扩展一些比较基础的jar包，让启动类加载器加载，有两种途径：\n\n- **放入jre/lib下进行扩展**。不推荐，尽可能不要去更改JDK安装目录中的内容，会出现即时放进去由于文件名不匹配的问题也不会正常地被加载。\n- **使用参数进行扩展。**推荐，使用-Xbootclasspath/a:jar包目录/jar包名 进行扩展，参数中的/a代表新增。\n\n如下图，在IDEA配置中添加虚拟机参数，就可以加载`D:/jvm/jar/classloader-test.jar`这个jar包了。\n\n![img](./7.1、JVM基础篇.assets/1715579392354-59.png)\n\n### 2.4.4 扩展类加载器和应用程序类加载器\n\n- 扩展类加载器和应用程序类加载器都是JDK中提供的、使用Java编写的类加载器。\n- 它们的源码都位于sun.misc.Launcher中，是一个静态内部类。继承自URLClassLoader。具备通过目录或者指定jar包将字节码文件加载到内存中。\n\n继承关系图如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392354-60.png)\n\n- ClassLoader类定义了具体的行为模式，简单来说就是先从本地或者网络获得字节码信息，然后调用虚拟机底层的方法创建方法区和堆上的对象。这样的好处就是让子类只需要去实现如何获取字节码信息这部分代码。\n- SecureClassLoader提供了证书机制，提升了安全性。\n- URLClassLoader提供了根据URL获取目录下或者指定jar包进行加载，获取字节码的数据。\n- 扩展类加载器和应用程序类加载器继承自URLClassLoader，获得了上述的三种能力。\n\n#### 扩展类加载器\n\n扩展类加载器（Extension Class Loader）是JDK中提供的、使用Java编写的类加载器。默认加载Java安装目录/jre/lib/ext下的类文件。\n\n![img](./7.1、JVM基础篇.assets/1715579392354-61.png)\n\n如下代码会打印ScriptEnvironment类的类加载器。ScriptEnvironment是nashorn框架中用来运行javascript语言代码的环境类，他位于nashorn.jar包中被扩展类加载器加载\n\n```Java\n/**\n * 扩展类加载器\n */\npublic class ExtClassLoaderDemo {\n    public static void main(String[] args) throws IOException {\n        ClassLoader classLoader = ScriptEnvironment.class.getClassLoader();\n        System.out.println(classLoader);\n    }\n}\n```\n\n打印结果如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392354-62.png)\n\n通过扩展类加载器去加载用户jar包：\n\n- **放入/jre/lib/ext下进行扩展**。不推荐，尽可能不要去更改JDK安装目录中的内容。\n- **使用参数进行扩展使用参数进行扩展**。推荐，使用-Djava.ext.dirs=jar包目录 进行扩展,这种方式会覆盖掉原始目录，可以用;(windows):(macos/linux)追加上原始目录\n\n如下图中：\n\n![img](./7.1、JVM基础篇.assets/1715579392354-63.png)\n\n使用`引号`将整个地址包裹起来，这样路径中即便是有空格也不需要额外处理。路径中要包含原来ext文件夹，同时在最后加上扩展的路径。\n\n####  应用程序加载器\n\n应用程序类加载器会加载classpath下的类文件，默认加载的是项目中的类以及通过maven引入的第三方jar包中的类。\n\n如下案例中，打印出`Student`和`FileUtils`的类加载器：\n\n```Java\n/**\n * 应用程序类加载器案例\n */\npublic class AppClassLoaderDemo {\n    public static void main(String[] args) throws IOException, InterruptedException {\n        //当前项目中创建的Student类\n        Student student = new Student();\n        ClassLoader classLoader = Student.class.getClassLoader();\n        System.out.println(classLoader);\n\n        //maven依赖中包含的类\n        ClassLoader classLoader1 = FileUtils.class.getClassLoader();\n        System.out.println(classLoader1);\n\n        Thread.sleep(1000);\n        System.in.read();\n\n    }\n}\n```\n\n输出结果如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392354-64.png)\n\n这两个类均由应用程序类加载器加载。\n\n类加载器的加载路径可以通过classloader –c hash值 查看：\n\n![img](./7.1、JVM基础篇.assets/1715579392354-65.png)\n\n## 2.5、双亲委派机制\n\n双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，\n\n再由顶向下进行加载。\n\n![img](./7.1、JVM基础篇.assets/1715579392354-66.png)\n\n详细流程：\n\n每个类加载器都有一个父类加载器。父类加载器的关系如下，启动类加载器没有父类加载器：\n\n![img](./7.1、JVM基础篇.assets/1715579392354-67.png)\n\n在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。\n\n#### 案例1：\n\n比如com.itheima.my.A假设在启动类加载器的加载目录中，而应用程序类加载器接到了加载类的任务。\n\n1、应用程序类加载器首先判断自己加载过没有，没有加载过就交给父类加载器 - 扩展类加载器。\n\n![img](./7.1、JVM基础篇.assets/1715579392354-68.png)\n\n2、扩展类加载器也没加载过，交给他的父类加载器 - 启动类加载器。\n\n![img](./7.1、JVM基础篇.assets/1715579392354-69.png)\n\n3、启动类加载器发现已经加载过，直接返回。\n\n![img](./7.1、JVM基础篇.assets/1715579392354-70.png)\n\n#### 案例2：\n\nB类在扩展类加载器加载路径中，同样应用程序类加载器接到了加载任务，按照案例1中的方式一层一层向上查找，发现都没有加载过。那么启动类加载器会首先尝试加载。它发现这类不在它的加载目录中，向下传递给扩展类加载器。\n\n![img](./7.1、JVM基础篇.assets/1715579392354-71.png)\n\n扩展类加载器发现这个类在它加载路径中，加载成功并返回。\n\n![img](./7.1、JVM基础篇.assets/1715579392355-72.png)\n\n如果第二次再接收到加载任务，同样地向上查找。扩展类加载器发现已经加载过，就可以返回了。\n\n![img](./7.1、JVM基础篇.assets/1715579392355-73.png)\n\n#### 双亲委派机制的作用\n\n1.保证类加载的安全性。通过双亲委派机制避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。\n\n2.避免重复加载。双亲委派机制可以避免同一个类被多次加载。\n\n#### 如何指定加载类的类加载器？\n\n在Java中如何使用代码的方式去主动加载一个类呢？\n\n方式1：使用Class.forName方法，使用当前类的类加载器去加载指定的类。\n\n方式2：获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载。\n\n例如：\n\n![img](./7.1、JVM基础篇.assets/1715579392355-74.png)\n\n#### 三个面试题\n\n1、如果一个类重复出现在三个类加载器的加载位置，应该由谁来加载？\n\n启动类加载器加载，根据双亲委派机制，它的优先级是最高的\n\n2、String类能覆盖吗，在自己的项目中去创建一个java.lang.String类，会被加载吗？\n\n不能，会返回启动类加载器加载在rt.jar包中的String类。\n\n3、**类的双亲委派机制是什么？**\n\n- 当一个类加载器去加载某个类的时候，会自底向上查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由顶向下进行加载。\n- 应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器。\n- 双亲委派机制的好处有两点：第一是避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。第二是避免一个类重复地被加载。\n\n## 2.6、打破双亲委派机制\n\n打破双亲委派机制历史上有三种方式，但本质上只有第一种算是真正的打破了双亲委派机制：\n\n- 自定义类加载器并且重写loadClass方法。Tomcat通过这种方式实现应用之间类隔离，《面试篇》中分享它的做法。\n- 线程上下文类加载器。利用上下文类加载器加载类，比如JDBC和JNDI等。\n- Osgi框架的类加载器。历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载，目前很少使用。\n\n#### 自定义类加载器\n\n一个Tomcat程序中是可以运行多个Web应用的，如果这两个应用中出现了相同限定名的类，比如Servlet类，Tomcat要保证这两个类都能加载并且它们应该是不同的类。如果不打破双亲委派机制，当应用类加载器加载Web应用1中的MyServlet之后，Web应用2中相同限定名的MyServlet类就无法被加载了。\n\n![img](./7.1、JVM基础篇.assets/1715579392355-75.png)\n\nTomcat使用了自定义类加载器来实现应用之间类的隔离。 每一个应用会有一个独立的类加载器加载对应的类。\n\n![img](./7.1、JVM基础篇.assets/1715579392355-76.png)\n\n那么自定义加载器是如何能做到的呢？首先我们需要先了解，双亲委派机制的代码到底在哪里，接下来只需要把这段代码消除即可。\n\nClassLoader中包含了4个核心方法，双亲委派机制的核心代码就位于loadClass方法中。\n\n```Java\npublic Class<?> loadClass(String name)\n类加载的入口，提供了双亲委派机制。内部会调用findClass   重要\n\nprotected Class<?> findClass(String name)\n由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。重要\n\nprotected final Class<?> defineClass(String name, byte[] b, int off, int len)\n做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中\n\nprotected final void resolveClass(Class<?> c)\n执行类生命周期中的连接阶段\n```\n\n1、入口方法：\n\n![img](./7.1、JVM基础篇.assets/1715579392355-77.png)\n\n2、再进入看下：\n\n![img](./7.1、JVM基础篇.assets/1715579392355-78.png)\n\n如果查找都失败，进入加载阶段，首先会由启动类加载器加载，这段代码在`findBootstrapClassOrNull`中。如果失败会抛出异常，接下来执行下面这段代码：\n\n![img](./7.1、JVM基础篇.assets/1715579392355-79.png)\n\n父类加载器加载失败就会抛出异常，回到子类加载器的这段代码，这样就实现了加载并向下传递。\n\n3、最后根据传入的参数判断是否进入连接阶段：\n\n![img](./7.1、JVM基础篇.assets/1715579392355-80.png)\n\n接下来实现打破双亲委派机制：\n\n```Java\npackage classloader.broken;//package com.itheima.jvm.chapter02.classloader.broken;\n\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.security.ProtectionDomain;\nimport java.util.regex.Matcher;\n\n/**\n * 打破双亲委派机制 - 自定义类加载器\n */\n\npublic class BreakClassLoader1 extends ClassLoader {\n\n    private String basePath;\n    private final static String FILE_EXT = \".class\";\n\n    //设置加载目录\n    public void setBasePath(String basePath) {\n        this.basePath = basePath;\n    }\n\n    //使用commons io 从指定目录下加载文件\n    private byte[] loadClassData(String name)  {\n        try {\n            String tempName = name.replaceAll(\"\\\\.\", Matcher.quoteReplacement(File.separator));\n            FileInputStream fis = new FileInputStream(basePath + tempName + FILE_EXT);\n            try {\n                return IOUtils.toByteArray(fis);\n            } finally {\n                IOUtils.closeQuietly(fis);\n            }\n\n        } catch (Exception e) {\n            System.out.println(\"自定义类加载器加载失败，错误原因：\" + e.getMessage());\n            return null;\n        }\n    }\n\n    //重写loadClass方法\n    @Override\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        //如果是java包下，还是走双亲委派机制\n        if(name.startsWith(\"java.\")){\n            return super.loadClass(name);\n        }\n        //从磁盘中指定目录下加载\n        byte[] data = loadClassData(name);\n        //调用虚拟机底层方法，方法区和堆区创建对象\n        return defineClass(name, data, 0, data.length);\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IOException {\n        //第一个自定义类加载器对象\n        BreakClassLoader1 classLoader1 = new BreakClassLoader1();\n        classLoader1.setBasePath(\"D:\\\\lib\\\\\");\n\n        Class<?> clazz1 = classLoader1.loadClass(\"com.itheima.my.A\");\n         //第二个自定义类加载器对象\n        BreakClassLoader1 classLoader2 = new BreakClassLoader1();\n        classLoader2.setBasePath(\"D:\\\\lib\\\\\");\n\n        Class<?> clazz2 = classLoader2.loadClass(\"com.itheima.my.A\");\n\n        System.out.println(clazz1 == clazz2);\n\n        Thread.currentThread().setContextClassLoader(classLoader1);\n\n        System.out.println(Thread.currentThread().getContextClassLoader());\n\n        System.in.read();\n     }\n}\n```\n\n##### 自定义类加载器父类怎么是AppClassLoader呢？\n\n默认情况下自定义类加载器的父类加载器是应用程序类加载器：\n\n![img](./7.1、JVM基础篇.assets/1715579392355-81.png)\n\n以Jdk8为例，ClassLoader类中提供了构造方法设置parent的内容：\n\n![img](./7.1、JVM基础篇.assets/1715579392355-82.png)\n\n这个构造方法由另外一个构造方法调用，其中父类加载器由getSystemClassLoader方法设置，该方法返回的是AppClassLoader。\n\n![img](./7.1、JVM基础篇.assets/1715579392355-83.png)\n\n##### 两个自定义类加载器加载相同限定名的类，不会冲突吗？\n\n不会冲突，在同一个Java虚拟机中，只有相同类加载器+相同的类限定名才会被认为是同一个类。\n\n在Arthas中使用sc –d 类名的方式查看具体的情况。\n\n如下代码：\n\n```Java\n public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IOException {\n        //第一个自定义类加载器对象\n        BreakClassLoader1 classLoader1 = new BreakClassLoader1();\n        classLoader1.setBasePath(\"D:\\\\lib\\\\\");\n\n        Class<?> clazz1 = classLoader1.loadClass(\"com.itheima.my.A\");\n         //第二个自定义类加载器对象\n        BreakClassLoader1 classLoader2 = new BreakClassLoader1();\n        classLoader2.setBasePath(\"D:\\\\lib\\\\\");\n\n        Class<?> clazz2 = classLoader2.loadClass(\"com.itheima.my.A\");\n\n        System.out.println(clazz1 == clazz2);\n     }\n```\n\n打印的应该是false，因为两个类加载器不同，尽管加载的是同一个类名，最终Class对象也不是相同的。\n\n通过Arthas看：\n\n![img](./7.1、JVM基础篇.assets/1715579392355-84.png)\n\n也会出现两个不同的A类。\n\n#### 线程上下文类加载器\n\n利用上下文类加载器加载类，比如JDBC和JNDI等。\n\n我们来看下JDBC的案例：\n\n1、JDBC中使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动。\n\n```Java\npackage classloader.broken;//package com.itheima.jvm.chapter02.classloader.broken;\n\nimport com.mysql.cj.jdbc.Driver;\n\nimport java.sql.*;\n\n/**\n * 打破双亲委派机制 - JDBC案例\n */\n\npublic class JDBCExample {\n    // JDBC driver name and database URL\n    static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\";\n    static final String DB_URL = \"jdbc:mysql:///bank1\";\n\n    //  Database credentials\n    static final String USER = \"root\";\n    static final String PASS = \"123456\";\n\n    public static void main(String[] args) {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = DriverManager.getConnection(DB_URL, USER, PASS);\n            stmt = conn.createStatement();\n            String sql;\n            sql = \"SELECT id, account_name FROM account_info\";\n            ResultSet rs = stmt.executeQuery(sql);\n\n            //STEP 4: Extract data from result set\n            while (rs.next()) {\n                //Retrieve by column name\n                int id = rs.getInt(\"id\");\n                String name = rs.getString(\"account_name\");\n\n                //Display values\n                System.out.print(\"ID: \" + id);\n                System.out.print(\", Name: \" + name + \"\\n\");\n            }\n            //STEP 5: Clean-up environment\n            rs.close();\n            stmt.close();\n            conn.close();\n        } catch (SQLException se) {\n            //Handle errors for JDBC\n            se.printStackTrace();\n        } catch (Exception e) {\n            //Handle errors for Class.forName\n            e.printStackTrace();\n        } finally {\n            //finally block used to close resources\n            try {\n                if (stmt != null)\n                    stmt.close();\n            } catch (SQLException se2) {\n            }// nothing we can do\n            try {\n                if (conn != null)\n                    conn.close();\n            } catch (SQLException se) {\n                se.printStackTrace();\n            }//end finally try\n        }//end try\n    }//end main\n}//end FirstExample\n```\n\n2、DriverManager类位于rt.jar包中，由启动类加载器加载。\n\n![img](./7.1、JVM基础篇.assets/1715579392355-85.png)\n\n3、依赖中的mysql驱动对应的类，由应用程序类加载器来加载。\n\n![img](./7.1、JVM基础篇.assets/1715579392355-86.png)\n\n在类中有初始化代码：\n\n![img](./7.1、JVM基础篇.assets/1715579392355-87.png)\n\nDriverManager属于rt.jar是启动类加载器加载的。而用户jar包中的驱动需要由应用类加载器加载，*这就违反了双亲委派机制*。（这点存疑，一会儿再讨论）\n\n那么问题来了，DriverManager怎么知道jar包中要加载的驱动在哪儿？\n\n1、在类的初始化代码中有这么一个方法`LoadInitialDrivers`：\n\n![img](./7.1、JVM基础篇.assets/1715579392355-88.png)\n\n2、这里使用了SPI机制，去加载所有jar包中实现了Driver接口的实现类。\n\n![img](./7.1、JVM基础篇.assets/1715579392355-89.png)\n\n3、SPI机制就是在这个位置下存放了一个文件，文件名是接口名，文件里包含了实现类的类名。这样SPI机制就可以找到实现类了。\n\n![img](./7.1、JVM基础篇.assets/1715579392356-90.png)\n\n![img](./7.1、JVM基础篇.assets/1715579392356-91.png)\n\n4、SPI中利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象。\n\n![img](./7.1、JVM基础篇.assets/1715579392356-92.png)\n\n总结：\n\n![img](./7.1、JVM基础篇.assets/1715579392356-93.png)\n\n##### JDBC案例中真的打破了双亲委派机制吗？\n\n最早这个论点提出是在周志明《深入理解Java虚拟机》中，他认为打破了双亲委派机制，这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，所以打破了双亲委派机制。\n\n但是如果我们分别从DriverManager以及驱动类的加载流程上分析，JDBC只是在DriverManager加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依然遵循双亲委派机制。\n\n所以我认为这里没有打破双亲委派机制，只是用一种巧妙的方法让启动类加载器加载的类，去引发的其他类的加载。\n\n#### Osgi框架的类加载器\n\n历史上，OSGi模块化框架。它存在同级之间的类加载器的委托加载。OSGi还使用类加载器实现了热部署的功能。热部署指的是在服务不停止的情况下，动态地更新字节码文件到内存中。\n\n![img](./7.1、JVM基础篇.assets/1715579392356-94.png)\n\n由于这种机制使用已经不多，所以不再过多讨论OSGi，着重来看下热部署在实际项目中的应用。\n\n#### 案例：使用阿里arthas不停机解决线上问题\n\n**背景：**\n\n小李的团队将代码上线之后，发现存在一个小bug，但是用户急着使用，如果重新打包再发布需要一个多小时的时间，所以希望能使用arthas尽快的将这个问题修复。\n\n**思路：**\n\n1. 在出问题的服务器上部署一个 arthas，并启动。\n2. jad --source-only 类全限定名 > 目录/文件名.java      jad 命令反编译，然后可以用其它编译器，比如 vim 来修改源码\n3. mc –c 类加载器的hashcode 目录/文件名.java -d 输出目录\n\n​      mc 命令用来编译修改过的代码\n\n1.  retransform class文件所在目录/xxx.class\n\n​      用 retransform 命令加载新的字节码\n\n**详细流程：**\n\n1、这段代码编写有误，在枚举中的类型判断上使用了`==` 而不是`equals`。\n\n![img](./7.1、JVM基础篇.assets/1715579392356-95.png)\n\n2、枚举中是这样定义的，1001是普通用户，1002是VIP用户：\n\n![img](./7.1、JVM基础篇.assets/1715579392356-96.png)\n\n3、由于代码有误，导致传递1001参数时，返回的是收费用户的内容。\n\n![img](./7.1、JVM基础篇.assets/1715579392356-97.png)\n\n4、`jad --source-only 类全限定名 > 目录/文件名.java` 使用 jad 命令反编译，然后可以用其它编译器，比如 vim 来修改源码\n\n![img](./7.1、JVM基础篇.assets/1715579392356-98.png)\n\n这里直接双击文件使用finalShell编辑：\n\n![img](./7.1、JVM基础篇.assets/1715579392356-99.png)\n\n5、`mc –c 类加载器的hashcode 目录/文件名.java -d 输出目录` 使用mc 命令用来编译修改过的代码\n\n![img](./7.1、JVM基础篇.assets/1715579392356-100.png)\n\n6、`retransform class文件所在目录/xxx.class` 用 retransform 命令加载新的字节码\n\n![img](./7.1、JVM基础篇.assets/1715579392356-101.png)\n\n7、测试：\n\n![img](./7.1、JVM基础篇.assets/1715579392356-102.png)\n\n**注意事项：**\n\n1、程序重启之后，字节码文件会恢复，除非将class文件放入jar包中进行更新。\n\n2、使用retransform不能添加方法或者字段，也不能更新正在执行中的方法。\n\n## 2.7、JDK9之后的类加载器\n\nJDK8及之前的版本中，扩展类加载器和应用程序类加载器的源码位于rt.jar包中的sun.misc.Launcher.java。\n\n![img](./7.1、JVM基础篇.assets/1715579392356-103.png)\n\n由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。\n\n1.启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中。\n\n   Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。\n\n   启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。\n\n2、扩展类加载器被替换成了平台类加载器（Platform Class Loader）。\n\n​     平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。\n\n# 3、运行时数据区\n\nJava虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区。《Java虚拟机规范》中规定了每一部分的作用。\n\n![img](./7.1、JVM基础篇.assets/1715579392356-104.png)\n\n### 3.1 程序计数器\n\n程序计数器（Program Counter Register）也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址。\n\n![img](./7.1、JVM基础篇.assets/1715579392356-105.png)\n\n一个程序计数器的具体案例：\n\n在加载阶段，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的偏移量转换成内存地址。每一条字节码指令都会拥有一个内存地址。\n\n![img](./7.1、JVM基础篇.assets/1715579392356-106.png)\n\n在代码执行过程中，程序计数器会记录下一行字节码指令的地址。执行完当前指令之后，虚拟机的执行引擎根据程序计数器执行下一行指令。这里为了简单起见，使用偏移量代替，真实内存中执行时保存的应该是地址。\n\n比如当前执行的是偏移量为0的指令，那么程序计数器中保存的就是下一条的地址（偏移量1）。\n\n![img](./7.1、JVM基础篇.assets/1715579392357-107.png)\n\n一路向下执行\n\n![img](./7.1、JVM基础篇.assets/1715579392357-108.png)\n\n一直执行到方法的最后一行指令，此时方法执行return语句，当前方法执行结束，程序计数器中会放入方法出口的地址（栈中讲解，简单来说就是这个B方法结束了，A调用了B，那么要回到A方法）\n\n![img](./7.1、JVM基础篇.assets/1715579392357-109.png)\n\n所以，程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。不管是分支、跳转、异常，只需要在程序计数器中放入下一行要执行的指令地址即可。\n\n在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU切换前解释执行到那一句指令并继续解释运行。\n\n![img](./7.1、JVM基础篇.assets/1715579392357-110.png)\n\n#### 程序计数器会出现内存溢出吗？\n\n内存溢出指的是程序在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能提供的内存上限。由于每个线程只存储一个固定长度的内存地址，程序计数器是不会发生内存溢出的。程序员无需对程序计数器做任何处理。\n\n### 3.2 Java虚拟机栈\n\nJava虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，先进后出（First In Last Out）,每一个方法的调用使用一个栈帧（Stack Frame）来保存。\n\n```Java\npublic class MethodDemo {   \n    public static void main(String[] args) {        \n         study();    \n     }\n\n    public static void study(){\n        eat();\n\n        sleep();\n    }   \n    \n    public static void eat(){       \n         System.out.println(\"吃饭\");   \n    }    \n    \n    public static void sleep(){        \n        System.out.println(\"睡觉\");    \n        }\n  }\n```\n\nmain方法执行时，会创建main方法的栈帧：\n\n![img](./7.1、JVM基础篇.assets/1715579392357-111.png)\n\n接下来执行study方法，会创建study方法的栈帧\n\n![img](./7.1、JVM基础篇.assets/1715579392357-112.png)\n\n进入eat方法，创建eat方法的栈帧\n\n![img](./7.1、JVM基础篇.assets/1715579392357-113.png)\n\neat方法执行完之后，会弹出它的栈帧：\n\n![img](./7.1、JVM基础篇.assets/1715579392357-114.png)\n\n然后调用sleep方法，创建sleep方法栈帧\n\n![img](./7.1、JVM基础篇.assets/1715579392357-115.png)\n\n最后study方法结束之后弹出栈帧，main方法结束之后弹出main的栈帧。\n\n在IDEA中也可以看到对应的栈帧：\n\n```Java\npackage chapter03.frame;\n\n/**\n * 栈帧测试1\n */\npublic class FrameDemo {\n    public static void main(String[] args) {\n        A();\n    }\n\n    public static void A() {\n        System.out.println(\"A执行了...\");\n        B();\n    }\n\n    public static void B() {\n        System.out.println(\"B执行了...\");\n        C();\n    }\n\n    public static void C() {\n        System.out.println(\"C执行了...\");\n        throw new RuntimeException(\"测试\");\n    }\n}\n```\n\n打上断点debug之后会出现栈帧内容：\n\n![img](./7.1、JVM基础篇.assets/1715579392357-116.png)\n\nJava虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。如下就有两个线程的虚拟机栈，main线程和线程A。\n\n![img](./7.1、JVM基础篇.assets/1715579392357-117.png)\n\nJava虚拟机栈的栈帧中主要包含三方面的内容：\n\n- 局部变量表，局部变量表的作用是在运行过程中存放所有的局部变量\n- 操作数栈，操作数栈是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域\n- 帧数据，帧数据主要包含动态链接、方法出口、异常表的引用\n\n#### 局部变量表\n\n局部变量表的作用是在方法执行过程中存放所有的局部变量。局部变量表分为两种，一种是字节码文件中的，另外一种是栈帧中的也就是保存在内存中。栈帧中的局部变量表是根据字节码文件中的内容生成的。\n\n我们先来看下字节码文件中的局部变量表：编译成字节码文件时就可以确定局部变量表的内容。\n\n```Java\npublic static void test1(){\n    int i = 0;\n    long j = 1;\n}\n```\n\ntest1方法的局部变量表如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392357-118.png)\n\n局部变量表中保存了字节码指令生效的偏移量：\n\n![img](./7.1、JVM基础篇.assets/1715579392357-119.png)\n\n比如`i`这个变量，它的起始PC是2，代表从`lconst_1`这句指令开始才能使用`i`，长度为3，也就是2-4这三句指令都可以使用`i`。为什么从2才能使用，因为0和1这两句字节码指令还在处理`int i = 0`这句赋值语句。`j`这个变量只有等3指令执行完之后也就是`long j = 1`代码执行完之后才能使用，所以起始PC为4，只能在4这行字节码指令中使用。\n\n接下来看下栈帧中的局部变量表，栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽(slot) ，long和double类型占用两个槽，其他类型占用一个槽。\n\n![img](./7.1、JVM基础篇.assets/1715579392357-120.png)\n\n`i`占用数组下标为0的位置，`j`占用数组下标1-2的位置。\n\n刚才看到的是静态方法，实例方法中的序号为0的位置存放的是this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址。\n\n![img](./7.1、JVM基础篇.assets/1715579392357-121.png)\n\n方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致。局部变量表保存的内容有：实例方法的this对象，方法的参数，方法体中声明的局部变量。\n\n![img](./7.1、JVM基础篇.assets/1715579392357-122.png)\n\ntest3方法中包含两个参数`k`,`m`，这两个参数也会被加入到局部变量表中。\n\n**以下代码的局部变量表中会占用几个槽？**\n\n```Java\npublic void test4(int k,int m){\n    {\n        int a = 1;\n        int b = 2;\n    }\n    {\n        int c = 1;\n    }\n    int i = 0;\n    long j = 1;\n}\n```\n\n为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用。\n\n1、方法执行时，实例对象`this`、`k`、`m` 会被放入局部变量表中，占用3个槽\n\n![img](./7.1、JVM基础篇.assets/1715579392357-123.png)\n\n2、将1的值放入局部变量表下标为3的位置上，相当于给a进行赋值。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-124.png)\n\n3、将2放入局部变量表下标为4的位置，给b赋值为2。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-125.png)\n\n4、ab已经脱离了生效范围，所以下标为3和4的这两个位置可以复用。此时c的值1就可以放入下标为3的位置。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-126.png)\n\n4、脱离c的生效范围之后，给i赋值就可以复用c的位置。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-127.png)\n\n5、最后放入j，j是一个long类型，占用两个槽。但是可以复用b所在的位置，所以占用4和5这两个位置\n\n![img](./7.1、JVM基础篇.assets/1715579392358-128.png)\n\n所以，局部变量表数值的长度为6。这一点在编译期间就可以确定了，运行过程中只需要在栈帧中创建长度为6的数组即可。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-129.png)\n\n#### 操作数栈\n\n操作数栈是栈帧中虚拟机在执行指令过程中用来存放中间数据的一块区域。他是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。\n\n在编译期就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-130.png)\n\n比如之前的相加案例中，操作数栈最大的深入会出现在这个时刻：\n\n![img](./7.1、JVM基础篇.assets/1715579392358-131.png)\n\n所以操作数栈的深度会定义为2。\n\n#### 帧数据\n\n帧数据主要包含动态链接、方法出口、异常表的引用。\n\n##### 动态链接\n\n当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-132.png)\n\n##### 方法出口\n\n方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-133.png)\n\n##### 异常表\n\n异常表存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-134.png)\n\n`如下案例：i=1`这行源代码编译成字节码指令之后，会包含偏移量2-4这三行指令。其中2-3是对i进行赋值1的操作，4的没有异常就跳转到10方法结束。如果出现异常的情况下，继续执行到7这行指令，7会将异常对象放入操作数栈中，这样在catch代码块中就可以使用异常对象了。接下来执行8-9，对i进行赋值为2的操作。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-135.png)\n\n所以异常表中，异常捕获的起始偏移量就是2，结束偏移量是4，在2-4执行过程中抛出了`java.lang.Exception`对象或者子类对象，就会将其捕获，然后跳转到偏移量为7的指令。\n\n#### 栈内存溢出\n\nJava虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出。Java虚拟机栈内存溢出时会出现StackOverflowError的错误。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-136.png)\n\n如果我们不指定栈的大小，JVM 将创建一个具有默认大小的栈。大小取决于操作系统和计算机的体系结构。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-137.png)\n\n我们来模拟下栈内存的溢出情况:\n\n```Java\npublic static int count = 0;\n     //递归方法调用自己\n     public static void recursion(){\n         System.out.println(++count);\n         recursion();\n     }\n```\n\n使用递归让方法调用自身，但是不设置退出条件。定义调用次数的变量，每一次调用让变量加1。查看错误发生时总调用的次数。\n\n![img](./7.1、JVM基础篇.assets/1715579392358-138.png)\n\n执行之后可以打印出溢出时总栈帧的数量，并且发现虚拟机已经抛出了StackOverflow的错误。\n\n要修改Java虚拟机栈的大小，可以使用虚拟机参数 -Xss 。\n\n- 语法：-Xss栈大小\n- 单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)\n\n例如：\n\n```Java\n-Xss1048576 \n-Xss1024K      \n-Xss1m\n-Xss1g\n```\n\n操作步骤如下，不同IDEA版本的设置方式会略有不同：\n\n1、点击修改配置Modify options\n\n2、点击Add VM options\n\n3、添加参数\n\n![img](./7.1、JVM基础篇.assets/1715579392358-139.png)\n\n调成512k之后，明显发现最大栈帧数量减少了：\n\n![img](./7.1、JVM基础篇.assets/1715579392358-140.png)\n\n**注意事项：**\n\n1、与-Xss类似，也可以使用 -XX:ThreadStackSize 调整标志来配置堆栈大小。\n\n格式为： `-XX:ThreadStackSize=1024`\n\n2、HotSpot JVM对栈大小的最大值和最小值有要求：\n\n​      比如测试如下两个参数，会直接报错:\n\n```\n-Xss1k\n-Xss1025m\n```\n\nWindows（64位）下的JDK8测试最小值为`180k`，最大值为`1024m`。\n\n3、局部变量过多、操作数栈深度过大也会影响栈内存的大小。我们在这段代码中添加一些局部变量。\n\n```Java\n//递归方法调用自己\npublic static void recursion() {\n    long a,b,c,d,f,g,h,i,j,k;\n    System.out.println(++count);\n    recursion();\n}\n```\n\n使用默认大小来测试之后，发现栈帧数量从10000+减少了到8000+\n\n![img](./7.1、JVM基础篇.assets/1715579392359-141.png)\n\n一般情况下，工作中即便使用了递归进行操作，栈的深度最多也只能到几百,不会出现栈的溢出。所以此参数可以手动指定为-Xss256k节省内存。\n\n### 3.3 本地方法栈\n\nJava虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是native本地方法的栈帧。\n\n在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。\n\n![img](./7.1、JVM基础篇.assets/1715579392359-142.png)\n\n比如测试下这段代码：\n\n```Java\n/**\n * 本地方法栈\n */\npublic class NativeDemo1 {\n    public static void main(String[] args) {\n        try {\n            FileOutputStream fileOutputStream = new FileOutputStream(\"E:\\\\123.txt\");\n            fileOutputStream.write(1);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n执行之后发生异常，会打印出所有栈帧的名字：\n\n![img](./7.1、JVM基础篇.assets/1715579392359-143.png)\n\n`open0`是一个本地方法，所以创建了本地方法的栈帧。本地方法和Java虚拟机方法的栈帧在一个栈上。\n\n### 3.4 堆内存\n\n一般Java程序中堆内存是空间最大的一块内存区域。创建出来的对象都存在于堆上。栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。\n\n```Java\npublic class Test {    \n    public static void main(String[] args) {        \n        Student s1 = new Student();        \n        s1.name = \"张三\";       \n        s1.age = 18;       \n        s1.id = 1;\n        s1.printTotalScore();        \n        s1.printAverageScore();        \n        \n        Student s2 = new Student();       \n        s2.name = \"李四\";        \n        s2.age = 19;        \n        s2.id= 2;        \n        s2.printTotalScore();        \n        s2.printAverageScore();    \n    }\n}\n```\n\n这段代码中通过`new`关键字创建了两个`Student`类的对象，这两个对象会被存放在堆上。在栈上通过`s1`和`s2`两个局部变量保存堆上两个对象的地址，从而实现了引用关系的建立。\n\n![img](./7.1、JVM基础篇.assets/1715579392359-144.png)\n\n#### 堆内存的溢出\n\n通过new关键字不停创建对象，放入集合中，模拟堆内存的溢出，观察堆溢出之后的异常信息。\n\n```Java\npackage chapter03.heap;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\n\n/**\n * 堆内存的使用和回收\n */\npublic class Demo1 {\n    public static void main(String[] args) throws InterruptedException, IOException {\n\n        ArrayList<Object> objects = new ArrayList<Object>();\n        System.in.read();\n        while (true){\n            objects.add(new byte[1024 * 1024 * 100]);\n            Thread.sleep(1000);\n        }\n\n\n    }\n}\n```\n\n堆内存大小是有上限的，当对象一直向堆中放入对象达到上限之后，就会抛出OutOfMemory错误。在这段代码中，不停创建100M大小的字节数组并放入ArrayList集合中，最终超过了堆内存的上限。抛出如下错误：\n\n![img](./7.1、JVM基础篇.assets/1715579392359-145.png)\n\n#### 三个重要的值\n\n堆空间有三个需要关注的值，used、total、max。used指的是当前已使用的堆内存，total是java虚拟机已经分配的可用堆内存，max是java虚拟机可以分配的最大堆内存。\n\n![img](./7.1、JVM基础篇.assets/1715579392359-146.png)\n\n堆内存used total max三个值可以通过dashboard命令看到。\n\n> 手动指定刷新频率（不指定默认5秒一次）：`dashboard –i  刷新频率(毫秒)`\n\n![img](./7.1、JVM基础篇.assets/1715579392359-147.png)\n\n随着堆中的对象增多，当total可以使用的内存即将不足时，java虚拟机会继续分配内存给堆。\n\n![img](./7.1、JVM基础篇.assets/1715579392359-148.png)\n\n此时used达到了total的大小，Java虚拟机会向操作系统申请更大的内存。\n\n![img](./7.1、JVM基础篇.assets/1715579392359-149.png)\n\n但是这个申请过程不是无限的，total最多只能与max相等。\n\n![img](./7.1、JVM基础篇.assets/1715579392359-150.png)\n\n那么是不是当used = max = total的时候，堆内存就溢出了呢？\n\n不是，堆内存溢出的判断条件比较复杂，在下一章《垃圾回收器》中会详细介绍。\n\n如果不设置任何的虚拟机参数，max默认是系统内存的1/4，total默认是系统内存的1/64。在实际应用中一般都需要设置total和max的值。 Oracle官方文档：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\n\n#### 设置堆的大小\n\n要修改堆的大小，可以使用虚拟机参数 –Xmx（max最大值）和-Xms (初始的total)。\n\n语法：`-Xmx值 -Xms值`\n\n单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)\n\n限制：Xmx必须大于 2 MB，Xms必须大于1MB\n\n```Java\n-Xms6291456\n-Xms6144k\n-Xms6m\n-Xmx83886080\n-Xmx81920k\n-Xmx80m\n```\n\n这样可以将max和初始的total都设置为4g，在启动后就已经获得了最大的堆内存大小。运行过程中不需要向操作系统申请。\n\n![img](./7.1、JVM基础篇.assets/1715579392359-151.png)\n\n使用`arthas`的`memory`命令同样可以看到：\n\n![img](./7.1、JVM基础篇.assets/1715579392359-152.png)\n\n为什么arthas中显示的heap堆大小与设置的值不一样呢？\n\narthas中的heap堆内存使用了JMX技术中内存获取方式，这种方式与垃圾回收器有关，计算的是可以分配对象的内存，而不是整个内存。\n\n**建议：**\n\nJava服务端程序开发时，建议将-Xmx和-Xms设置为相同的值，这样在程序启动之后可使用的总内存就是最大内存，而无需向java虚拟机再次申请，减少了申请并分配内存时间上的开销，同时也不会出现内存过剩之后堆收缩的情况。-Xmx具体设置的值与实际的应用程序运行环境有关，在《实战篇》中会给出设置方案。\n\n### 3.5 方法区\n\n方法区是存放基础信息的位置，线程共享，主要包含三部分内容：\n\n- 类的元信息，保存了所有类的基本信息\n- 运行时常量池，保存了字节码文件中的常量池内容\n- 字符串常量池，保存了字符串常量\n\n#### 类的元信息\n\n方法区是用来存储每个类的基本信息（元信息），一般称之为InstanceKlass对象。在类的加载阶段完成。其中就包含了类的字段、方法等字节码文件中的内容，同时还保存了运行过程中需要使用的虚方法表（实现多态的基础）等信息。\n\n![img](./7.1、JVM基础篇.assets/1715579392359-153.png)\n\n#### 运行时常量池\n\n方法区除了存储类的元信息之外，还存放了运行时常量池。常量池中存放的是字节码中的常量池内容。\n\n字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池。\n\n![img](./7.1、JVM基础篇.assets/1715579392360-154.png)\n\n#### 方法区的实现\n\n方法区是《Java虚拟机规范》中设计的虚拟概念，每款Java虚拟机在实现上都各不相同。Hotspot设计如下：\n\nJDK7及之前的版本将方法区存放在堆区域中的永久代空间，堆的大小由虚拟机参数来控制。\n\nJDK8及之后的版本将方法区存放在元空间中，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受的上限，可以一直分配。\n\n![img](./7.1、JVM基础篇.assets/1715579392360-155.png)\n\n可以通过arthas的`memory`命令看到方法区的名称以及大小：\n\n- JDK7及之前的版本查看ps_perm_gen属性。\n\n![img](./7.1、JVM基础篇.assets/1715579392360-156.png)\n\n- JDK8及之后的版本查看metaspace属性。\n\n![img](./7.1、JVM基础篇.assets/1715579392360-157.png)\n\n#### 方法区的溢出\n\n通过ByteBuddy框架，动态创建类并将字节码数据加载到内存中。通过死循环不停地加载到方法区，观察方法区是否会出现内存溢出的情况。分别在JDK7和JDK8上运行上述代码。\n\nByteBuddy是一个基于Java的开源库，用于生成和操作Java字节码。\n\n1.引入依赖\n\n```XML\n<dependency>\n    <groupId>net.bytebuddy</groupId>\n    <artifactId>byte-buddy</artifactId>\n    <version>1.12.23</version>\n </dependency>\n```\n\n2.创建ClassWriter对象\n\n```Java\n ClassWriter classWriter = new ClassWriter(0);\n```\n\n3.调用visit方法，创建字节码数据。\n\n```Java\nclassWriter.visit(Opcodes.V1_7,Opcodes.ACC_PUBLIC,name,null ,\"java/lang/Object\",null);\nbyte[] bytes = classWriter.toByteArray();\n```\n\n代码：\n\n```Java\npackage chapter03.methodarea;\n\nimport net.bytebuddy.jar.asm.ClassWriter;\nimport net.bytebuddy.jar.asm.Opcodes;\n\nimport java.io.IOException;\n\n/**\n * 方法区的溢出测试\n */\npublic class Demo1 extends ClassLoader {\n    public static void main(String[] args) throws IOException {\n        System.in.read();\n        Demo1 demo1 = new Demo1();\n        int count = 0;\n        while (true) {\n            String name = \"Class\" + count;\n            ClassWriter classWriter = new ClassWriter(0);\n            classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, name, null\n                    , \"java/lang/Object\", null);\n            byte[] bytes = classWriter.toByteArray();\n            demo1.defineClass(name, bytes, 0, bytes.length);\n            System.out.println(++count);\n        }\n    }\n}\n```\n\n实验发现，JDK7上运行大概十几万次，就出现了错误。\n\n![img](./7.1、JVM基础篇.assets/1715579392360-158.png)\n\n在JDK8上运行百万次，程序都没有出现任何错误，但是内存会直线升高。这说明JDK7和JDK8在方法区的存放上，采用了不同的设计。\n\n- JDK7将方法区存放在堆区域中的永久代空间，堆的大小由虚拟机参数-XX:MaxPermSize=值来控制。\n- JDK8将方法区存放在元空间中，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受的上限，可以一直分配。可以使用-XX:MaxMetaspaceSize=值将元空间最大大小进行限制。\n\n在JDK8中将最大元空间内存设置为256m，再次测试\n\n![img](./7.1、JVM基础篇.assets/1715579392360-159.png)\n\n这次就出现了MetaSpace溢出的错误：\n\n![img](./7.1、JVM基础篇.assets/1715579392360-160.png)\n\n#### 字符串常量池\n\n方法区中除了类的元信息、运行时常量池之外，还有一块区域叫字符串常量池(StringTable)。\n\n字符串常量池存储在代码中定义的常量字符串内容。比如“123” 这个123就会被放入字符串常量池。\n\n如下代码执行时，代码中包含`abc`字符串，就会被直接放入字符串常量池。在堆上创建String对象，并通过局部变量s1引用堆上的对象。\n\n![img](./7.1、JVM基础篇.assets/1715579392360-161.png)\n\n接下来通过s2局部变量引用字符串常量池的`abc`。\n\n![img](./7.1、JVM基础篇.assets/1715579392360-162.png)\n\n所以s1和s2指向的不是同一个对象，打印出`false`。\n\n##### 字符串常量池和运行时常量池有什么关系？\n\n早期设计时，字符串常量池是属于运行时常量池的一部分，他们存储的位置也是一致的。后续做出了调整，将字符串常量池和运行时常量池做了拆分。\n\n![img](./7.1、JVM基础篇.assets/1715579392360-163.png)\n\n##### StringTable的练习题1：\n\n```Java\n/**\n * 字符串常量池案例\n */\npublic class Demo2 {\n    public static void main(String[] args) {\n        String a = \"1\";\n        String b = \"2\";\n        String c = \"12\";\n        String d = a + b;\n        System.out.println(c == d);\n    }\n}\n```\n\n1、首先将`1`放入字符串常量池，通过局部变量a引用字符串常量池中的`1`字符串。\n\n![img](./7.1、JVM基础篇.assets/1715579392360-164.png)\n\n2、同理处理b和c：\n\n![img](./7.1、JVM基础篇.assets/1715579392360-165.png)\n\n3、将a和b指向的字符串进行连接，本质上就是使用StringBuilder进行连接，最后创建了一个新的字符串放入堆中。然后将局部变量d指向堆上的对象。\n\n![img](./7.1、JVM基础篇.assets/1715579392360-166.png)\n\n4、所以c和d指向的不是同一个对象，打印出的结果就是false。\n\n##### StringTable的练习题2：\n\n```Java\npackage chapter03.stringtable;\n\n/**\n * 字符串常量池案例\n */\npublic class Demo3 {\n    public static void main(String[] args) {\n        String a = \"1\";\n        String b = \"2\";\n        String c = \"12\";\n        String d = \"1\" + \"2\";\n        System.out.println(c == d);\n    }\n}\n```\n\n编译之后的字节码指令如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392360-167.png)\n\n说明在编译阶段，已经将1和2进行连接，最终生成12的字符串常量池中的结果。所以返回结果就是true，c和d都指向字符串常量池中的对象。\n\n总结一下：\n\n![img](./7.1、JVM基础篇.assets/1715579392360-168.png)\n\n##### 神奇的intern\n\nString.intern()方法是可以手动将字符串放入字符串常量池中，分别在JDK6 JDK8下执行代码，JDK6 中结果是false false ，JDK8中是true false\n\n```Java\npackage chapter03.stringtable;\n\n/**\n * intern案例\n */\npublic class Demo4 {\n    public static void main(String[] args) {\n        String s1 = new StringBuilder().append(\"think\").append(\"123\").toString();\n\n        System.out.println(s1.intern() == s1);\n//        System.out.println(s1.intern() == s1.intern());\n\n        String s2 = new StringBuilder().append(\"ja\").append(\"va\").toString();\n\n        System.out.println(s2.intern() == s2);\n    }\n}\n```\n\n先来分析JDK6中，代码执行步骤如下：\n\n1、使用StringBuilder的将`think`和`123`拼接成`think123`，转换成字符串，在堆上创建一个字符串对象。局部变量`s1`指向堆上的对象。\n\n![img](./7.1、JVM基础篇.assets/1715579392360-169.png)\n\n2、调用s1.intern方法，会在字符串常量池中创建think123的对象，最后将对象引用返回。所以s1.intern和s1指向的不是同一个对象。打印出false。\n\n![img](./7.1、JVM基础篇.assets/1715579392361-170.png)\n\n3、同理，通过StringBuilder在堆上创建java字符串对象。这里注意字符串常量池中本来就有一个java字符串对象，这是java虚拟机自身使用的所以启动时就会创建出来。\n\n![img](./7.1、JVM基础篇.assets/1715579392361-171.png)\n\n4、调用s2.intern发现字符串常量池中已经有java字符串对象了，就将引用返回。所以s2.intern指向的是字符串常量池中的对象，而s2指向的是堆中的对象。打印结果为false。\n\n![img](./7.1、JVM基础篇.assets/1715579392361-172.png)\n\n接下来分析JDK7中，JDK7及之后版本中由于字符串常量池在堆上，所以intern () 方法会把第一次遇到的字符串的引用放入字符串常量池。\n\n代码执行步骤如下：\n\n1、执行第二句代码时，由于字符串常量池中没有think123的字符串，所以直接创建一个引用，指向堆中的think123对象。所以s1.intern和s1指向的都是堆上的对象，打印结果为true。\n\n![img](./7.1、JVM基础篇.assets/1715579392361-173.png)\n\n2、s2.intern方法调用时，字符串常量池中已经有java字符串了，所以将引用返回。这样打印出来的结果就是false。\n\n![img](./7.1、JVM基础篇.assets/1715579392361-174.png)\n\n> 后续JDK版本中，如果Java虚拟机不需要使用java字符串，那么字符串常量池中就不会存放`java`。打印结果有可能会出现两个true。\n\n####  面试题：静态变量存储在哪里呢？\n\n- JDK6及之前的版本中，静态变量是存放在方法区中的，也就是永久代。\n- JDK7及之后的版本中，静态变量是存放在堆中的Class对象中，脱离了永久代。具体源码可参考虚拟机源码：BytecodeInterpreter针对putstatic指令的处理。\n\n### 3.6 直接内存\n\n直接内存（Direct Memory）并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域。\n\n在 JDK 1.4 中引入了 NIO 机制，使用了直接内存，主要为了解决以下两个问题:\n\n1、Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。\n\n2、IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。\n\n现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。\n\n使用堆创建对象的过程：\n\n![img](./7.1、JVM基础篇.assets/1715579392361-175.png)\n\n使用直接内存创建对象的过程，不需要进行复制对象，数据直接存放在直接内存中：\n\n![img](./7.1、JVM基础篇.assets/1715579392361-176.png)\n\n#### 使用方法：\n\n要创建直接内存上的数据，可以使用`ByteBuffer`。\n\n语法： `ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);`\n\n注意事项： arthas的memory命令可以查看直接内存大小，属性名direct。\n\n![img](./7.1、JVM基础篇.assets/1715579392361-177.png)\n\n代码：\n\n```Java\npackage chapter03.direct;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 直接内存的使用和回收\n */\npublic class Demo1 {\n    public static int size = 1024 * 1024 * 100; //100mb\n    public static List<ByteBuffer> list = new ArrayList<ByteBuffer>();\n    public static int count = 0;\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        System.in.read();\n        while (true) {\n            //1.创建DirectByteBuffer对象并返回\n            //2.在DirectByteBuffer构造方法中，向操作系统申请直接内存空间\n            ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);\n            //directBuffer = null;\n\n            list.add(directBuffer);\n            System.out.println(++count);\n            Thread.sleep(5000);\n        }\n\n    }\n}\n```\n\n运行之后，用arthas监控发现，每隔5秒直接内存会增长100M：\n\n![img](./7.1、JVM基础篇.assets/1715579392361-178.png)\n\n如果将`Thread.`*`sleep`*`(5000);`注释掉，让直接内存快速大量分配。操作系统内存不足时就会报错：\n\n![img](./7.1、JVM基础篇.assets/1715579392361-179.png)\n\n但是工作中服务器上有可能部署了其他应用，为了避免将内存耗尽，需要设置直接内存的最大值。如果需要手动调整直接内存的大小，可以使用`XX:MaxDirectMemorySize=大小`\n\n单位k或K表示千字节，m或M表示兆字节，g或G表示千兆字节。默认不设置该参数情况下，JVM 自动选择 最大分配的大小。\n\n以下示例以不同的单位说明如何将 直接内存大小设置为 1024 KB：\n\n```Java\n-XX:MaxDirectMemorySize=1m\n-XX:MaxDirectMemorySize=1024k\n-XX:MaxDirectMemorySize=1048576\n```\n\n在Idea中设置直接内存最大值为1g：\n\n![img](./7.1、JVM基础篇.assets/1715579392361-180.png)\n\n直接循环11次之后，超过最大值就会报错：\n\n![img](./7.1、JVM基础篇.assets/1715579392361-181.png)\n\n### 3.8 方法区和堆区的区别\n\n#### **方法区（Method Area）**：\n\n- 方法区是存储类的元数据信息、静态变量、常量池、方法字节码等数据的内存区域。\n- 主要包含以下内容：\n  - 类的元数据信息：包括类的结构信息、方法和字段的描述符、访问权限、继承关系等。\n  - 静态变量：被声明为 static 关键字的变量，它们在类加载时被初始化，并且存储在方法区中。\n  - 常量池：用于存放编译时生成的各种字面量和符号引用，例如字符串常量、类和接口的全限定名、字段和方法的符号引用等。\n  - 方法字节码：类中的方法代码被编译成字节码后存储在方法区中。\n- 方法区在 JVM 启动时被创建，并且在 JVM 运行期间始终存在，直到 JVM 进程结束才会被释放。\n\n#### **堆区（Java Heap）**：\n\n- 堆区是存储对象实例和数组对象的内存区域，它是 Java 程序中创建的对象的主要存放地点。\n- 主要包含以下内容：\n  - 对象实例：通过 `new` 关键字创建的对象实例都存储在堆区中。\n  - 数组对象：Java 中的数组对象也存储在堆区中，无论是基本数据类型的数组还是对象数组。\n- 堆区在 JVM 启动时被创建，并且在 JVM 运行期间动态地分配和释放内存，由垃圾回收器负责管理。\n- 堆区的内存分配由 Java 虚拟机根据应用程序的需求动态调整，当堆区内存不足时会触发垃圾回收，释放无用对象来腾出空间。\n\n总的来说，方法区主要存储类相关的信息和静态变量，而堆区主要存储对象实例和数组对象。两者在 Java 虚拟机中扮演着不同的角色，但都是 Java 程序执行过程中重要的内存区域。\n\n### 3.9 不同版本的运行时数据区\n\n#### jdk6、jdk7、jdk8区别\n\n![img](./7.1、JVM基础篇.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc2NzAxNQ==,size_16,color_FFFFFF,t_70.png)\n\n\n\n#### JDK8之后\n\n静态变量移到元空间\n\n字符串常量池仍在堆区\n\n# 4、垃圾回收\n\n在C/C++这类没有自动垃圾回收机制的语言中，一个对象如果不再使用，需要手动释放，否则就会出现内存泄漏。\n\n内存泄漏指的是不再使用的对象在系统中未被回收，内存泄漏的积累可能会导致内存溢出。   \n\n在这段代码中，通过死循环不停创建Test类的对象，每一轮循环结束之后，这次创建的对象就不再使用了。但是没有手动调用删除对象的方法，此时对象就会出现内存泄漏。     \n\n![img](./7.1、JVM基础篇.assets/1715579392361-182.png)\n\n这段代码中，手动调用`delete`删除对象，就不会出现内存泄漏。\n\n![img](./7.1、JVM基础篇.assets/1715579392361-183.png)\n\n我们称这种释放对象的过程为垃圾回收，而需要程序员编写代码进行回收的方式为手动回收。手动回收的方式相对来说回收比较及时，删除代码执行之后对象就被回收了，可以快速释放内存。缺点是对程序员要求比较高，很容易出现创建完对象之后，程序员忘记释放对象。\n\nJava中为了简化对象的释放，引入了自动的垃圾回收（Garbage Collection简称GC）机制。通过垃圾回收器来对不再使用的对象完成自动的回收，垃圾回收器主要负责对堆上的内存进行回收。其他很多现代语言比如C#、Python、Go都拥有自己的垃圾回收器。\n\n垃圾回收器如果发现某个对象不再使用，就可以回收该对象。\n\n![img](./7.1、JVM基础篇.assets/1715579392361-184.png)\n\n![img](./7.1、JVM基础篇.assets/1715579392361-185.png)\n\n- 自动垃圾回收，自动根据对象是否使用由虚拟机来回收对象\n  - 优点：降低程序员实现难度、降低对象回收bug的可能性\n  - 缺点：程序员无法控制内存回收的及时性\n- 手动垃圾回收，由程序员编程实现对象的删除\n  - 优点：回收及时性高，由程序员把控回收的时机\n  - 缺点：编写不当容易出现悬空指针、重复释放、内存泄漏等问题\n\n那么垃圾回收器需要负责对哪些部分的内存进行回收呢？\n\n首先是线程不共享的部分，都是伴随着线程的创建而创建，线程的销毁而销毁。而方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。所以这一部分不需要垃圾回收器负责回收。\n\n![img](./7.1、JVM基础篇.assets/1715579392361-186.png)\n\n## 4.1 方法区的回收\n\n方法区中能回收的内容主要就是不再使用的类。\n\n判定一个类可以被卸载。需要同时满足下面三个条件：\n\n**1、此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。**\n\n这段代码中就将局部变量对堆上实例对象的引用去除了，所以对象就可以被回收。\n\n![img](./7.1、JVM基础篇.assets/1715579392361-187.png)\n\n**2、加载该类的类加载器已经被回收。**\n\n这段代码让局部变量对类加载器的引用去除，类加载器就可以回收。\n\n![img](./7.1、JVM基础篇.assets/1715579392362-188.png)\n\n**3、该类对应的 java.lang.Class 对象没有在任何地方被引用。**\n\n![img](./7.1、JVM基础篇.assets/1715579392362-189.png)\n\n代码:\n\n```Java\npackage chapter04.gc;\n\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\n\n/**\n * 类的卸载\n */\npublic class ClassUnload {\n    public static void main(String[] args) throws InterruptedException {\n\n        try {\n            ArrayList<Class<?>> classes = new ArrayList<>();\n            ArrayList<URLClassLoader> loaders = new ArrayList<>();\n            ArrayList<Object> objs = new ArrayList<>();\n            while (true) {\n\n                URLClassLoader loader = new URLClassLoader(\n                        new URL[]{new URL(\"file:D:\\\\lib\\\\\")});\n                Class<?> clazz = loader.loadClass(\"com.itheima.my.A\");\n                Object o = clazz.newInstance();\n\n\n//                objs.add(o);\n//                classes.add(clazz);\n//                 loaders.add(loader);\n\n                 System.gc();\n\n            }\n\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n添加这两个虚拟机参数进行测试：\n\n```Java\n-XX:+TraceClassLoading -XX:+TraceClassUnloading\n```\n\n![img](./7.1、JVM基础篇.assets/1715579392362-190.png)\n\n如果注释掉代码中三句add调用，就可以同时满足3个条件。但是需要手动调用`System.gc()`方法，让垃圾回收器进行回收。\n\n> 如果需要手动触发垃圾回收，可以调用System.gc()方法。\n>\n> 语法： `System.gc()`\n>\n> 注意事项：\n>\n> 调用System.gc()方法并不一定会立即回收垃圾，仅仅是向Java虚拟机发送一个垃圾回收的请求，具体是否需要执行垃圾回收Java虚拟机会自行判断。\n\n执行之后，日志中就会打印出类卸载的内容：\n\n![img](./7.1、JVM基础篇.assets/1715579392362-191.png)\n\n那么类卸载主要用在什么场景下呢？\n\n开发中此类场景一般很少出现，主要在如 OSGi、JSP 的热部署等应用场景中。\n\n每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。\n\n## 4.2 如何判断对象可以回收\n\n垃圾回收器要回收对象的第一步就是判断哪些对象可以回收。Java中的对象是否能被回收，是根据对象是否被引用来决定的。如果对象被引用了，说明该对象还在使用，不允许被回收。\n\n比如下面代码的内存结构图：\n\n第一行代码执行之后，堆上创建了Demo类的实例对象，同时栈上保存局部变量引用堆上的对象。\n\n![img](./7.1、JVM基础篇.assets/1715579392362-192.png)\n\n第二行代码执行之后，局部变量对堆上的对象引用去掉，那么堆上的对象就可以被回收了。\n\n![img](./7.1、JVM基础篇.assets/1715579392362-193.png)\n\n一个更复杂的案例：\n\n![img](./7.1、JVM基础篇.assets/1715579392362-194.png)\n\n这个案例中，如果要让对象a和b回收，必须将局部变量到堆上的引用去除。\n\n![img](./7.1、JVM基础篇.assets/1715579392362-195.png)\n\n那么问题来了，A和B互相之间的引用需要去除吗？答案是不需要，因为局部变量都没引用这两个对象了，在代码中已经无法访问这两个对象，即便他们之间互相有引用关系，也不影响对象的回收。\n\n判断对象是否可以回收，主要有两种方式：引用计数法和可达性分析法。\n\n### 引用计数法\n\n引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。\n\n比如下图中，对象A的计数器初始为0，局部变量a1对它引用之后，计数器加1就变成了1。同样A对B产生了引用，B的计数器也是1。\n\n![img](./7.1、JVM基础篇.assets/1715579392362-196.png)\n\n引用计数法的优点是实现简单，C++中的智能指针就采用了引用计数法，但是它也存在缺点，主要有两点：\n\n1.每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响\n\n2.存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题。\n\n这张图上，由于A和B之间存在互相引用，所以计数器都为1，两个对象都不能被回收。但是由于没有局部变量对这两个代码产生引用，代码中已经无法访问到这两个对象，理应可以被回收。\n\n![img](./7.1、JVM基础篇.assets/1715579392362-197.png)\n\n我们来做一个实验，验证下Java中循环引用不会导致内存泄漏，因为Java虚拟机根本没有使用引用计数法。首先我们要学会去看一个对象有没有被回收，可以通过垃圾回收日志来查看。\n\n如果想要查看垃圾回收的信息，可以使用`-verbose:gc`参数。\n\n语法： `-verbose:gc`\n\n![img](./7.1、JVM基础篇.assets/1715579392362-198.png)\n\n加上这个参数之后执行代码，发现对象确实被回收了：\n\n![img](./7.1、JVM基础篇.assets/1715579392362-199.png)\n\n通过不同的死循环创建对象，内存并没有上升，一直维持在1000K,说明每轮循环创建的两个对象在垃圾回收之后都被回收了。\n\n### 可达性分析法\n\nJava使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象，对象与对象之间存在引用关系。\n\n下图中A到B再到C和D，形成了一个引用链，可达性分析算法指的是如果从某个到GC Root对象是可达的，对象就不可被回收。\n\n![img](./7.1、JVM基础篇.assets/1715579392362-200.png)\n\n#### GC Root对象\n\n哪些对象被称之为GC Root对象呢？\n\n- 线程Thread对象，引用线程栈帧中的方法参数、局部变量等。\n- 系统类加载器加载的java.lang.Class对象，引用类中的静态变量。\n\n![img](./7.1、JVM基础篇.assets/1715579392362-201.png)\n\n- 监视器对象，用来保存同步锁synchronized关键字持有的对象。\n\n![img](./7.1、JVM基础篇.assets/1715579392362-202.png)\n\n- 本地方法调用时使用的全局对象。\n\n\n\n#### 工具\n\n通过arthas和eclipse Memory Analyzer (MAT) 工具可以查看GC Root，MAT工具是eclipse推出的Java堆内存检测工具。具体操作步骤如下：\n\n1、使用arthas的heapdump命令将堆内存快照保存到本地磁盘中。\n\n2、使用MAT工具打开堆内存快照文件。\n\n3、选择GC Roots功能查看所有的GC Root。\n\n![img](./7.1、JVM基础篇.assets/1715579392362-203.png)\n\n#### 步骤详解：\n\n1、代码如下：\n\n```Java\npackage com.itheima.jvm.chapter04;\n\nimport java.io.IOException;\n\npublic class ReferenceCounting {\n    public static A a2 = null;\n    public static void main(String[] args) throws IOException {\n//        while (true){\n            A a1 = new A();\n            B b1 = new B();\n            a1.b = b1;\n            b1.a = a1;\n            a2 = a1;\n            System.in.read();\n//            a1 = null;\n//            b1 = null;\n//        }\n\n    }\n}\n\nclass A {\n    B b;\n//    byte[] t = new byte[1024 * 1024 * 10];\n}\n\nclass B {\n    A a;\n//    byte[] t = new byte[1024 * 1024 * 10];\n}\n```\n\n2、使用arthas连接到程序，输入如下命令:\n\n```Java\nheapdump 目录/test2.hprof\n```\n\n![img](./7.1、JVM基础篇.assets/1715579392362-204.png)\n\n这样就生成了一个堆内存快照（后面介绍，简单来说就是包含了所有堆中的对象信息）。\n\n3、打开资料中提供的MAT工具，如果出现如下错误，请将环境变量中的JDK版本升级到17以上。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-205.png)\n\n4、选择菜单中的打开堆内存快照功能，并选择刚才生成的文件。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-206.png)\n\n5、选择内存泄漏检测报告，并确定。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-207.png)\n\n6、通过菜单找到GC Roots。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-208.png)\n\n7、MAT对4类GC Root对象做了分类。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-209.png)\n\n8、找到静态变量。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-210.png)\n\n9、找到局部变量\n\n![img](./7.1、JVM基础篇.assets/1715579392363-211.png)\n\n\n\n##  4.3 常见的引用对象\n\n可达性算法中描述的对象引用，一般指的是强引用，即是GCRoot对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收。除了强引用之外，Java中还设计了几种其他引用方式：\n\n- 软引用\n- 弱引用\n- 虚引用\n- 终结器引用\n\n### 强引用\n\n### 软引用\n\n软引用相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。在JDK 1.2版之后提供了SoftReference类来实现软引用，软引用常用于缓存中。\n\n如下图中，对象A被GC Root对象强引用了，同时我们创建了一个软引用SoftReference对象（它本身也是一个对象），软引用对象中引用了对象A。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-212.png)\n\n接下来强引用被去掉之后，对象A暂时还是处于不可回收状态，因为有软引用存在并且内存还够用。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-213.png)\n\n如果内存出现不够用的情况，对象A就处于可回收状态，可以被垃圾回收器回收。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-214.png)\n\n这样做有什么好处？如果对象A是一个缓存，平时会保存在内存中，如果想访问数据可以快速访问。但是如果内存不够用了，我们就可以将这部分缓存清理掉释放内存。即便缓存没了，也可以从数据库等地方获取数据，不会影响到业务正常运行，这样可以减少内存溢出产生的可能性。\n\n**特别注意：**\n\n软引用对象本身，也需要被强引用，否则软引用对象也会被回收掉。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-215.png)\n\n#### 软引用的使用方法\n\n软引用的执行过程如下：\n\n1.将对象使用软引用包装起来，new SoftReference<对象类型>(对象)。\n\n2.内存不足时，虚拟机尝试进行垃圾回收。\n\n3.如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象。\n\n4.如果依然内存不足，抛出OutOfMemory异常。\n\n代码：\n\n```Java\n/**\n * 软引用案例2 - 基本使用\n */\npublic class SoftReferenceDemo2 {\n    public static void main(String[] args) throws IOException {\n\n        byte[] bytes = new byte[1024 * 1024 * 100];\n        SoftReference<byte[]> softReference = new SoftReference<byte[]>(bytes);\n        bytes = null;\n        System.out.println(softReference.get());\n\n        byte[] bytes2 = new byte[1024 * 1024 * 100];\n        System.out.println(softReference.get());\n//\n//        byte[] bytes3 = new byte[1024 * 1024 * 100];\n//        softReference = null;\n//        System.gc();\n//\n//        System.in.read();\n    }\n}\n```\n\n添加虚拟机参数，限制最大堆内存大小为200m：\n\n![img](./7.1、JVM基础篇.assets/1715579392363-216.png)\n\n执行后发现，第二个100m对象创建之后需，软引用中包含的对象已经被回收了。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-217.png)\n\n#### 软引用对象本身怎么回收呢？\n\n如果软引用对象里边包含的数据已经被回收了，那么软引用对象本身其实也可以被回收了。\n\nSoftReference提供了一套队列机制：\n\n1、软引用创建时，通过构造器传入引用队列\n\n![img](./7.1、JVM基础篇.assets/1715579392363-218.png)\n\n2、在软引用中包含的对象被回收时，该软引用对象会被放入引用队列\n\n![img](./7.1、JVM基础篇.assets/1715579392363-219.png)\n\n3、通过代码遍历引用队列，将SoftReference的强引用删除\n\n代码\n\n```Java\n/**\n * 软引用案例3 - 引用队列使用\n */\npublic class SoftReferenceDemo3 {\n\n    public static void main(String[] args) throws IOException {\n\n        ArrayList<SoftReference> softReferences = new ArrayList<>();\n        ReferenceQueue<byte[]> queues = new ReferenceQueue<byte[]>();\n        for (int i = 0; i < 10; i++) {\n            byte[] bytes = new byte[1024 * 1024 * 100];\n            SoftReference studentRef = new SoftReference<byte[]>(bytes,queues);\n            softReferences.add(studentRef);\n        }\n\n        SoftReference<byte[]> ref = null;\n        int count = 0;\n        while ((ref = (SoftReference<byte[]>) queues.poll()) != null) {\n            count++;\n        }\n        System.out.println(count);\n\n    }\n}\n```\n\n最终展示的结果是：\n\n![img](./7.1、JVM基础篇.assets/1715579392363-220.png)\n\n这9个软引用对象中包含的数据已经被回收掉，所以可以手动从ArrayList中去掉，这样就可以释放这9个对象。\n\n#### 软引用的缓存案例\n\n使用软引用实现学生信息的缓存，能支持内存不足时清理缓存。\n\n![img](./7.1、JVM基础篇.assets/1715579392363-221.png)\n\n代码：\n\n```Java\npackage chapter04.soft;\n\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Map;\n/**\n * 软引用案例4 - 学生信息的缓存\n */\npublic class StudentCache {\n\n    private static StudentCache cache = new StudentCache();\n\n    public static void main(String[] args) {\n        for (int i = 0; ; i++) {\n            StudentCache.getInstance().cacheStudent(new Student(i, String.valueOf(i)));\n        }\n    }\n\n    private Map<Integer, StudentRef> StudentRefs;// 用于Cache内容的存储\n    private ReferenceQueue<Student> q;// 垃圾Reference的队列\n\n    // 继承SoftReference，使得每一个实例都具有可识别的标识。\n    // 并且该标识与其在HashMap内的key相同。\n    private class StudentRef extends SoftReference<Student> {\n        private Integer _key = null;\n\n        public StudentRef(Student em, ReferenceQueue<Student> q) {\n            super(em, q);\n            _key = em.getId();\n        }\n    }\n\n    // 构建一个缓存器实例\n    private StudentCache() {\n        StudentRefs = new HashMap<Integer, StudentRef>();\n        q = new ReferenceQueue<Student>();\n    }\n\n    // 取得缓存器实例\n    public static StudentCache getInstance() {\n        return cache;\n    }\n\n    // 以软引用的方式对一个Student对象的实例进行引用并保存该引用\n    private void cacheStudent(Student em) {\n        cleanCache();// 清除垃圾引用\n        StudentRef ref = new StudentRef(em, q);\n        StudentRefs.put(em.getId(), ref);\n        System.out.println(StudentRefs.size());\n    }\n\n    // 依据所指定的ID号，重新获取相应Student对象的实例\n    public Student getStudent(Integer id) {\n        Student em = null;\n// 缓存中是否有该Student实例的软引用，如果有，从软引用中取得。\n        if (StudentRefs.containsKey(id)) {\n            StudentRef ref = StudentRefs.get(id);\n            em = ref.get();\n        }\n// 如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，\n// 并保存对这个新建实例的软引用\n        if (em == null) {\n            em = new Student(id, String.valueOf(id));\n            System.out.println(\"Retrieve From StudentInfoCenter. ID=\" + id);\n            this.cacheStudent(em);\n        }\n        return em;\n    }\n\n    // 清除那些所软引用的Student对象已经被回收的StudentRef对象\n    private void cleanCache() {\n        StudentRef ref = null;\n        while ((ref = (StudentRef) q.poll()) != null) {\n            StudentRefs.remove(ref._key);\n        }\n    }\n\n//    // 清除Cache内的全部内容\n//    public void clearCache() {\n//        cleanCache();\n//        StudentRefs.clear();\n//        //System.gc();\n//        //System.runFinalization();\n//    }\n}\n\nclass Student {\n    int id;\n    String name;\n\n    public Student(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n```\n\n### 弱引用\n\n弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收。在JDK 1.2版之后提供了WeakReference类来实现弱引用，弱引用主要在ThreadLocal中使用。\n\n弱引用对象本身也可以使用引用队列进行回收。\n\n```Java\npackage chapter04.weak;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\n/**\n * 弱引用案例 - 基本使用\n */\npublic class WeakReferenceDemo2 {\n    public static void main(String[] args) throws IOException {\n\n        byte[] bytes = new byte[1024 * 1024 * 100];\n        WeakReference<byte[]> weakReference = new WeakReference<byte[]>(bytes);\n        bytes = null;\n        System.out.println(weakReference.get());\n\n        System.gc();\n\n        System.out.println(weakReference.get());\n    }\n}\n```\n\n执行之后发现gc执行之后，对象已经被回收了。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-222.png)\n\n### 虚引用和终结器引用\n\n这两种引用在常规开发中是不会使用的。\n\n- 虚引用也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。Java中使用PhantomReference实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。\n\n- 终结器引用指的是在对象需要被回收时，终结器引用会关联对象并放置在Finalizer类中的引用队列中，在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法，在对象第二次被回收时，该对象才真正的被回收。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做。\n\n```Java\npackage chapter04.finalreference;\n\n/**\n * 终结器引用案例\n */\npublic class FinalizeReferenceDemo {\n    public static FinalizeReferenceDemo reference = null;\n\n    public void alive() {\n        System.out.println(\"当前对象还存活\");\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        try{\n            System.out.println(\"finalize()执行了...\");\n            //设置强引用自救\n            reference = this;\n        }finally {\n            super.finalize();\n        }\n    }\n\n    public static void main(String[] args) throws Throwable {\n        reference = new FinalizeReferenceDemo();\n       test();\n       test();\n    }\n\n    private static void test() throws InterruptedException {\n        reference = null;\n        //回收对象\n        System.gc();\n        //执行finalize方法的优先级比较低，休眠500ms等待一下\n        Thread.sleep(500);\n        if (reference != null) {\n            reference.alive();\n        } else {\n            System.out.println(\"对象已被回收\");\n        }\n    }\n}\n```\n\n## 4.4 垃圾回收算法\n\nJava是如何实现垃圾回收的呢？简单来说，垃圾回收要做的有两件事：\n\n1、找到内存中存活的对象\n\n2、释放不再存活对象的内存，使得程序能再次利用这部分空间 \n\n![img](./7.1、JVM基础篇.assets/1715579392364-223.png)\n\n### 垃圾回收算法的历史和分类\n\n1960年John McCarthy发布了第一个GC算法：标记-清除算法。\n\n1963年Marvin L. Minsky 发布了复制算法。\n\n本质上后续所有的垃圾回收算法，都是在上述两种算法的基础上优化而来。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-224.png)\n\n### 垃圾回收算法的评价标准\n\nJava垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要停止所有的用户线程。这个过程被称之为Stop The World简称STW，如果STW时间过长则会影响用户的使用。\n\n如下图，用户代码执行和垃圾回收执行让用户线程停止执行（STW）是交替执行的。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-225.png)\n\n所以判断GC算法是否优秀，可以从三个方面来考虑：\n\n#### 1.吞吐量\n\n吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 /（执行用户代码时间 + GC时间）。吞吐量数值越高，垃圾回收的效率就越高。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-226.png)\n\n#### 2.最大暂停时间\n\n最大暂停时间指的是所有在垃圾回收过程中的STW时间最大值。比如如下的图中，黄色部分的STW就是最大暂停时间，显而易见上面的图比下面的图拥有更少的最大暂停时间。最大暂停时间越短，用户使用系统时受到的影响就越短。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-227.png)\n\n####  3.堆使用效率\n\n不同垃圾回收算法，对堆内存的使用方式是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法。\n\n上述三种评价标准：堆使用效率、吞吐量，以及最大暂停时间不可兼得。\n\n一般来说，堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就会降低吞吐量。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-228.png)\n\n没有一个垃圾回收算法能兼顾上述三点评价标准，所以不同的垃圾回收算法它的侧重点是不同的，适用于不同的应用场景。\n\n### 标记清除算法\n\n标记清除算法的核心思想分为两个阶段：\n\n1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。\n\n2.清除阶段，从内存中删除没有被标记也就是非存活对象。\n\n第一个阶段，从GC Root对象开始扫描，将对象A、B、C在引用链上的对象标记出来：\n\n![img](./7.1、JVM基础篇.assets/1715579392364-229.png)\n\n第二个阶段，将没有标记的对象清理掉，所以对象D就被清理掉了。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-230.png)\n\n优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。\n\n缺点：1.碎片化问题\n\n由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。\n\n如下图，红色部分已经被清理掉了，总共回收了9个字节，但是每个都是一个小碎片，无法为5个字节的对象分配空间。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-231.png)\n\n标记清除算法的缺点：\n\n2.分配速度慢。由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。 我们需要用一个链表来维护，哪些空间可以分配对象，很有可能需要遍历这个链表到最后，才能发现这块空间足够我们去创建一个对象。如下图，遍历到最后才发现有足够的空间分配3个字节的对象了。如果链表很长，遍历也会花费较长的时间。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-232.png)\n\n### 复制算法\n\n复制算法的核心思想是：\n\n1.准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。\n\n对象A首先分配在From空间：\n\n![img](./7.1、JVM基础篇.assets/1715579392364-233.png)\n\n2.在垃圾回收GC阶段，将From中存活对象复制到To空间。\n\n在垃圾回收阶段，如果对象A存活，就将其复制到To空间。然后将From空间直接清空。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-234.png)\n\n3.将两块空间的From和To名字互换。\n\n接下来将两块空间的名称互换，下次依然在From空间上创建对象。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-235.png)\n\n完整的复制算法的例子：\n\n1.将堆内存分割成两块From空间 To空间，对象分配阶段，创建对象。\n\n![img](./7.1、JVM基础篇.assets/1715579392364-236.png)\n\n2.GC阶段开始，将GC Root搬运到To空间\n\n![img](./7.1、JVM基础篇.assets/1715579392364-237.png)\n\n3.将GC Root关联的对象，搬运到To空间\n\n![img](./7.1、JVM基础篇.assets/1715579392365-238.png)\n\n4.清理From空间，并把名称互换\n\n![img](./7.1、JVM基础篇.assets/1715579392365-239.png)\n\n优点：\n\n- 吞吐量高，复制算法只需要遍历一次存活对象复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动\n- 不会发生碎片化，复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。\n\n缺点：\n\n内存使用效率低，每次只能让一半的内存空间来为创建对象使用。\n\n### 标记整理算法\n\n标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。\n\n核心思想分为两个阶段：\n\n1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。\n\n2.整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。\n\n![img](./7.1、JVM基础篇.assets/1715579392365-240.png)\n\n优点：\n\n- 内存使用效率高，整个堆内存都可以使用，不会像复制算法只能使用半个堆内存\n- 不会发生碎片化，在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间\n\n缺点：\n\n整理阶段的效率不高，整理算法有很多种，比如Lisp2整理算法需要对整个堆中的对象搜索3次，整体性能不佳。可以通过Two-Finger、表格算法、ImmixGC等高效的整理算法优化此阶段的性能。\n\n### 分代垃圾回收算法\n\n现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法组合进行使用，其中应用最广的就是分代垃圾回收算法(Generational GC)。\n\n分代垃圾回收将整个内存区域划分为年轻代和老年代：\n\n![img](./7.1、JVM基础篇.assets/1715579392365-241.png)\n\n我们通过arthas来验证下内存划分的情况：\n\n在JDK8中，添加-XX:+UseSerialGC参数使用分代回收的垃圾回收器，运行程序。\n\n在arthas中使用memory命令查看内存，显示出三个区域的内存情况。\n\n![img](./7.1、JVM基础篇.assets/1715579392365-242.png)\n\nEden + survivor 这两块区域组成了年轻代。\n\ntenured_gen指的是晋升区域，其实就是老年代。\n\n另外还可以选择的虚拟机参数如下\n\n| 参数名                        | 参数含义                                                     | 示例                                                    |\n| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------- |\n| -Xms                          | 设置堆的最小和初始大小，必须是1024倍数且大于1MB              | 比如初始大小6MB的写法： -Xms6291456 -Xms6144k -Xms6m    |\n| -Xmx                          | 设置最大堆的大小，必须是1024倍数且大于2MB                    | 比如最大堆80 MB的写法： -Xmx83886080 -Xmx81920k -Xmx80m |\n| -Xmn                          | 新生代的大小                                                 | 新生代256 MB的写法： -Xmn256m -Xmn262144k -Xmn268435456 |\n| -XX:SurvivorRatio             | 伊甸园区和幸存区的比例，默认为8 新生代1g内存，伊甸园区800MB,S0和S1各100MB | 比例调整为4的写法：-XX:SurvivorRatio=4                  |\n| -XX:+PrintGCDetailsverbose:gc | 打印GC日志                                                   | 无                                                      |\n\n代码：\n\n```Java\npackage chapter04.gc;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 垃圾回收器案例1\n */\n//-XX:+UseSerialGC  -Xms60m -Xmn20m -Xmx60m -XX:SurvivorRatio=3  -XX:+PrintGCDetails\npublic class GcDemo0 {\n\n    public static void main(String[] args) throws IOException {\n        List<Object> list = new ArrayList<>();\n        int count = 0;\n        while (true){\n            System.in.read();\n            System.out.println(++count);\n            //每次添加1m的数据\n            list.add(new byte[1024 * 1024 * 1]);\n        }\n    }\n}\n```\n\n使用arthas的memory展示出来的效果：\n\n![img](./7.1、JVM基础篇.assets/1715579392365-243.png)\n\nheap展示的是可用堆，survivor区每次只有一块能使用，所以60 - 4 = 56m。\n\n1、分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。\n\n![img](./7.1、JVM基础篇.assets/1715579392365-244.png)\n\n2、随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC。\n\nMinor GC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。\n\n![img](./7.1、JVM基础篇.assets/1715579392365-245.png)\n\n3、接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC。\n\n![img](./7.1、JVM基础篇.assets/1715579392365-246.png)\n\n此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入S0。\n\n注意：每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1。\n\n![img](./7.1、JVM基础篇.assets/1715579392365-247.png)\n\n4、如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。\n\n![img](./7.1、JVM基础篇.assets/1715579392365-248.png)\n\n![img](./7.1、JVM基础篇.assets/1715579392365-249.png)\n\n当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收。\n\n如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常。\n\n![img](./7.1、JVM基础篇.assets/1715579392365-250.png)\n\n下图中的程序为什么会出现OutOfMemory？\n\n![img](./7.1、JVM基础篇.assets/1715579392365-251.png)\n\n从上图可以看到，Full GC无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常。\n\n继续使用这段代码测试：\n\n```Java\n//-XX:+UseSerialGC  -Xms60m -Xmn20m -Xmx60m -XX:SurvivorRatio=3  -XX:+PrintGCDetails\npublic class GcDemo0 {\n\n    public static void main(String[] args) throws IOException {\n        List<Object> list = new ArrayList<>();\n        int count = 0;\n        while (true){\n            System.in.read();\n            System.out.println(++count);\n            //每次添加1m的数据\n            list.add(new byte[1024 * 1024 * 1]);\n        }\n    }\n}\n```\n\n结果如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392365-252.png)\n\n老年代已经满了，而且垃圾回收无法回收掉对象，如果还想往里面放就发生了`OutOfMemoryError`。\n\n## 4.5 垃圾回收器\n\n为什么分代GC算法要把堆分成年轻代和老年代？首先我们要知道堆内存中对象的特性：\n\n- 系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。\n- 老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。\n- 在虚拟机的默认设置中，新生代大小要远小于老年代的大小。\n\n分代GC算法将堆分成年轻代和老年代主要原因有：\n\n1、可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。\n\n2、新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记-清除和标记-整理算法，由程序员来选择灵活度较高。\n\n3、分代的设计中允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收(full gc),STW时间就会减少。\n\n垃圾回收器是垃圾回收算法的具体实现。\n\n由于垃圾回收器分为年轻代和老年代，除了G1之外其他垃圾回收器必须成对组合进行使用。\n\n具体的关系图如下：\n\n![img](./7.1、JVM基础篇.assets/1715579392365-253.png)\n\n### 年轻代-Serial垃圾回收器\n\nSerial是是一种单线程串行回收年轻代的垃圾回收器。\n\n![img](./7.1、JVM基础篇.assets/1715579392366-254.png)\n\n**回收年代和算法：**\n\n年轻代\n\n复制算法\n\n**优点**\n\n单CPU处理器下吞吐量非常出色\n\n**缺点**\n\n多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待\n\n**适用场景**\n\nJava编写的客户端程序或者硬件配置有限的场景\n\n### 老年代-SerialOld垃圾回收器\n\nSerialOld是Serial垃圾回收器的老年代版本，采用单线程串行回收\n\n-XX:+UseSerialGC 新生代、老年代都使用串行回收器。\n\n![img](./7.1、JVM基础篇.assets/1715579392366-255.png)\n\n**回收年代和算法：**\n\n老年代\n\n标记-整理算法\n\n**优点**\n\n单CPU处理器下吞吐量非常出色\n\n**缺点**\n\n多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待\n\n**适用场景**\n\n与Serial垃圾回收器搭配使用，或者在CMS特殊情况下使用\n\n### 年轻代-ParNew垃圾回收器\n\nParNew垃圾回收器本质上是对Serial在多CPU下的优化，使用多线程进行垃圾回收\n\n-XX:+UseParNewGC 新生代使用ParNew回收器， 老年代使用串行回收器\n\n![img](./7.1、JVM基础篇.assets/1715579392366-256.png)\n\n**回收年代和算法：**\n\n年轻代\n\n复制算法\n\n**优点**\n\n多CPU处理器下停顿时间较短\n\n**缺点**\n\n吞吐量和停顿时间不如G1，所以在JDK9之后不建议使用\n\n**适用场景**\n\n JDK8及之前的版本中，与CMS老年代垃圾回收器搭配使用\n\n### 老年代- CMS(Concurrent Mark Sweep)垃圾回收器\n\nCMS垃圾回收器关注的是系统的暂停时间，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少了用户线程的等待时间。\n\n参数：XX:+UseConcMarkSweepGC\n\n![img](./7.1、JVM基础篇.assets/1715579392366-257.png)\n\n**回收年代和算法：**\n\n老年代\n\n标记清除算法\n\n**优点**\n\n系统由于垃圾回收出现的停顿时间较短，用户体验好\n\n**缺点**\n\n1、内存碎片问题\n\n2、退化问题\n\n3、浮动垃圾问题\n\n**适用场景**\n\n 大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等\n\nCMS执行步骤：\n\n1.初始标记，用极短的时间标记出GC Roots能直接关联到的对象。\n\n2.并发标记,   标记所有的对象，用户线程不需要暂停。\n\n3.重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。\n\n4.并发清理，清理死亡的对象，用户线程不需要暂停。\n\n缺点：\n\n1、CMS使用了标记-清除算法，在垃圾收集结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。这样会导致用户线程暂停，可以使用-XX:CMSFullGCsBeforeCompaction=N 参数（默认0）调整N次Full GC之后再整理。\n\n2.、无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。\n\n3、如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代。\n\n并发线程数：\n\n在CMS中并发阶段运行时的线程数可以通过-XX:ConcGCThreads参数设置，默认值为0，由系统计算得出。\n\n计算公式为(-XX:ParallelGCThreads定义的线程数 + 3) / 4， ParallelGCThreads是STW停顿之后的并行线程数\n\nParallelGCThreads是由处理器核数决定的：\n\n  1、当cpu核数小于8时，ParallelGCThreads = CPU核数\n\n  2、否则 ParallelGCThreads = 8 + (CPU核数 – 8 )*5/8 \n\n我的电脑上逻辑处理器有12个，所以ParallelGCThreads  =  8 + （12 - 8）* 5/8 = 10，ConcGCThreads = (-XX:ParallelGCThreads定义的线程数 + 3) / 4 = （10 + 3） / 4 = 3\n\n![img](./7.1、JVM基础篇.assets/1715579392366-258.png)\n\n最终可以得到这张图：\n\n![img](./7.1、JVM基础篇.assets/1715579392366-259.png)\n\n并发标记和并发清理阶段，会使用3个线程并行处理。重新标记阶段会使用10个线程处理。\n\n由于CPU的核心数有限，并发阶段会影响用户线程执行的性能。\n\n![img](./7.1、JVM基础篇.assets/1715579392366-260.png)\n\n### 年轻代-Parallel Scavenge垃圾回收器\n\nParallel Scavenge是JDK8默认的年轻代垃圾回收器，多线程并行回收，关注的是系统的吞吐量。具备自动调整堆内存大小的特点。\n\n![img](./7.1、JVM基础篇.assets/1715579392366-261.png)\n\n**回收年代和算法：**\n\n年轻代\n\n复制算法\n\n**优点**\n\n吞吐量高，而且手动可控。为了提高吞吐量，虚拟机会动态调整堆的参数\n\n**缺点**\n\n不能保证单次的停顿时间\n\n**适用场景**\n\n后台任务，不需要与用户交互，并且容易产生大量的对象。比如：大数据的处理，大文件导出\n\n**常用参数：**\n\nParallel Scavenge允许手动设置最大暂停时间和吞吐量。Oracle官方建议在使用这个组合时，不要设置堆内存的最大值，垃圾回收器会根据最大暂停时间和吞吐量自动调整内存大小。\n\n- 最大暂停时间，`-XX:MaxGCPauseMillis=n` 设置每次垃圾回收时的最大停顿毫秒数\n- 吞吐量，`-XX:GCTimeRatio=n` 设置吞吐量为n（用户线程执行时间 = n/n + 1）\n- 自动调整内存大小, `-XX:+UseAdaptiveSizePolicy`设置可以让垃圾回收器根据吞吐量和最大停顿的毫秒数自动调整内存大小\n\n### 老年代-Parallel Old垃圾回收器\n\nParallel Old是为Parallel Scavenge收集器设计的老年代版本，利用多线程并发收集。\n\n参数： -XX:+UseParallelGC  或\n\n​           -XX:+UseParallelOldGC可以使用Parallel Scavenge + Parallel Old这种组合。\n\n![img](./7.1、JVM基础篇.assets/1715579392366-262.png)\n\n**回收年代和算法：**\n\n老年代\n\n标记-整理算法\n\n**优点**\n\n并发收集，在多核CPU下效率较高\n\n**缺点**\n\n暂停时间会比较长\n\n**适用场景**\n\n与Parallel Scavenge配套使用\n\n### G1垃圾回收器\n\nJDK9之后默认的垃圾回收器是G1（Garbage First）垃圾回收器。Parallel Scavenge关注吞吐量，允许用户设置最大暂停时间 ，但是会减少年轻代可用空间的大小。CMS关注暂停时间，但是吞吐量方面会下降。\n\n而G1设计目标就是将上述两种垃圾回收器的优点融合：\n\n1.支持巨大的堆空间回收，并有较高的吞吐量。\n\n2.支持多CPU并行垃圾回收。\n\n3.允许用户设置最大暂停时间。\n\nJDK9之后强烈建议使用G1垃圾回收器。\n\nG1出现之前的垃圾回收器，年轻代和老年代一般是连续的，如下图：\n\n![img](./7.1、JVM基础篇.assets/1715579392366-263.png)\n\nG1的整个堆会被划分成多个大小相等的区域，称之为区Region，区域不要求是连续的。分为Eden、Survivor、Old区。Region的大小通过堆空间大小/2048计算得到，也可以通过参数-XX:G1HeapRegionSize=32m指定(其中32m指定region大小为32M)，Region size必须是2的指数幂，取值范围从1M到32M。\n\n![img](./7.1、JVM基础篇.assets/1715579392366-264.png)\n\nG1垃圾回收有两种方式：\n\n1、年轻代回收（Young GC）\n\n2、混合回收（Mixed GC）\n\n#### 年轻代回收\n\n年轻代回收（Young GC），回收Eden区和Survivor区中不用的对象。会导致STW，G1中可以通过参数\n\n-XX:MaxGCPauseMillis=n（默认200）  设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地保证暂停时间。\n\n1、新创建的对象会存放在Eden区。当G1判断年轻代区不足（max默认60%），无法分配对象时需要回收时会执行Young GC。\n\n![img](./7.1、JVM基础篇.assets/1715579392366-265.png)\n\n2、标记出Eden和Survivor区域中的存活对象，\n\n3、根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的Survivor区中（年龄+1），清空这些区域。\n\n![img](./7.1、JVM基础篇.assets/1715579392366-266.png)\n\n![img](./7.1、JVM基础篇.assets/1715579392366-267.png)\n\nG1在进行Young GC的过程中会去记录每次垃圾回收时每个Eden区和Survivor区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个Region区域了。\n\n比如 -XX:MaxGCPauseMillis=n（默认200），每个Region回收耗时40ms，那么这次回收最多只能回收4个Region。\n\n4、后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。\n\n![img](./7.1、JVM基础篇.assets/1715579392366-268.png)\n\n![img](./7.1、JVM基础篇.assets/1715579392366-269.png)\n\n5、当某个存活对象的年龄到达阈值（默认15），将被放入老年代。\n\n![img](./7.1、JVM基础篇.assets/1715579392366-270.png)\n\n6、部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为Humongous区。比如堆内存是4G，每个Region是2M，只要一个大对象超过了1M就被放入Humongous区，如果对象过大会横跨多个Region。\n\n![img](./7.1、JVM基础篇.assets/1715579392367-271.png)\n\n7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时\n\n（-XX:InitiatingHeapOccupancyPercent默认45%）会触发混合回收MixedGC。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法来完成。\n\n![img](./7.1、JVM基础篇.assets/1715579392367-272.png)\n\n![img](./7.1、JVM基础篇.assets/1715579392367-273.png)\n\n#### 混合回收\n\n混合回收分为：初始标记（initial mark）、并发标记（concurrent mark）、最终标记（remark或者Finalize Marking）、并发清理（cleanup）\n\nG1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1（Garbage first）名称的由来。\n\n   \n\n![img](./7.1、JVM基础篇.assets/1715579392367-274.png)\n\nG1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1（Garbage first）名称的由来。最后清理阶段使用复制算法，不会产生内存碎片。\n\n![img](./7.1、JVM基础篇.assets/1715579392367-275.png)\n\n注意：如果清理过程中发现没有足够的空Region存放转移的对象，会出现Full GC。单线程执行标记-整理算法，此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。\n\n![img](./7.1、JVM基础篇.assets/1715579392367-276.png)\n\n### G1 – Garbage First 垃圾回收器\n\n参数1： `-XX:+UseG1GC`  打开G1的开关，JDK9之后默认不需要打开\n\n参数2：`-XX:MaxGCPauseMillis=毫秒值` 最大暂停的时\n\n**回收年代和算法：**\n\n年轻代+老年代\n\n复制算法\n\n**优点**\n\n对比较大的堆如超过6G的堆回收时，延迟可控\n\n不会产生内存碎片\n\n并发标记的SATB算法效率高\n\n**缺点**\n\nJDK8之前还不够成熟\n\n**适用场景**\n\nJDK8最新版本、JDK9之后建议默认使用\n\n使用以下代码测试g1垃圾回收器，打印出每个阶段的时间:\n\n```Java\npackage chapter04.gc;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 垃圾回收器案例3\n */\n//-XX:+UseG1GC   -Xmn8g -Xmx16g -XX:SurvivorRatio=8  -XX:+PrintGCDetails -verbose:gc \npublic class GcDemo2 {\n\n    public static void main(String[] args) throws IOException {\n        int count = 0;\n        List<Object> list = new ArrayList<>();\n        while (true){\n            //System.out.println(++count);\n            if(count++ % 10240 == 0){\n                list.clear();\n            }\n//            byte[] bytes = new byte[1024 * 1024 * 1];\n            list.add(new byte[1024 * 1024 * 1 / 2]);\n//            System.gc();\n        }\n    }\n}\n```\n\n每个region大小为2m，一共有84个young区，26个幸存者区。\n\n![img](./7.1、JVM基础篇.assets/1715579392367-277.png)\n\n初始标记花了0.0478秒。\n\n![img](./7.1、JVM基础篇.assets/1715579392367-278.png)\n\n并发标记总共耗时10ms，不会产生STW。\n\n![img](./7.1、JVM基础篇.assets/1715579392367-279.png)\n\n### 总结\n\n垃圾回收器的组合关系虽然很多，但是针对几个特定的版本，比较好的组合选择如下：\n\nJDK8及之前：\n\nParNew + CMS（关注暂停时间）、Parallel Scavenge + Parallel Old (关注吞吐量)、 G1（JDK8之前不建议，较大堆并且关注暂停时间）\n\nJDK9之后:\n\nG1（默认）\n\n从JDK9之后，由于G1日趋成熟，JDK默认的垃圾回收器已经修改为G1，所以强烈建议在生产环境上使用G1。\n\nG1的实现原理将在《原理篇》中介绍，更多前沿技术ZGC、GraalVM将在《高级篇》中介绍。',28,'JAVA','jvm',1,85,0,0,'2024-05-17 16:07:20','2024-05-17 16:07:20'),(13,'JVM基础','','http://114.132.41.159/admin/dist/img/rand/35.jpg','1、JVM基础\nhttps://lisxpq12rl7.feishu.cn/wiki/ZaKnwhhhmiDu9ekUnRNcv2iNnof\n1.1 什么是JVM\nJVM 全称是 Java Virtual Machine，中文译名 Java虚拟机。JVM 本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件。\n\nJava源代码执行流程如下：\n\nimg\n\n分为三个步骤：\n\n1、编写Java源代码文件。\n\n2、使用Java编译器（javac命令）将源代码编译成Java字节码文件。\n\n3、使用Java虚拟机加载并运行Java字节码文件，此时会启动一个新的进程。\n\n1.2 JVM的功能\n1 - 解释和运行\n2 - 内存管理\n3 - 即时编译\n1.2.1 解释和运行\n当Java程序运行时，JVM会将Java字节码文件加载到内存中，并逐条解释执行其中的指令。这种解释执行的方式使得Java程序具有跨平台性，因为不同的操作系统只需要提供不同的JVM实现即可运行相同的Java程序。\n\n对字节码文件中的指令，实时的解释成机器码，让计算机执行。\n\n字节码文件中包含了字节码指令，计算器无法直接执行，Java虚拟机会将字节码文件中的字节码指令实时地解释成机器码，机器码是计算机可以运行的指令。\n\nimg\n\n1.2.2 内存管理\n自动为对象、方法等分配内存\n自动的垃圾回收机制，回收不再使用的对象\nJava虚拟机会帮助程序员为对象分配内存，同时将不用的对象使用垃圾回收器回收掉，这是对比C和C++这些语言的一个优势。在C/C++语言中，对象的回收需要程序员手动去编写代码完成，如果遗漏了这段删除对象的代码，这个对象就会永远占用内存空间，不会再回收。所以JVM的这个功能降低了程序员编写代码的难度。\n\n1.2.3 即时编译\n对热点代码进行优化，提升执行效率。即时编译可以说是提升Java程序性能最核心的手段。\n\n为了提高Java程序的执行效率，JVM引入了即时编译（JIT）技术。JIT编译器在运行时将那些经常运行的代码块（热点代码）编译成与平台相关的机器语言，从而提高程序的执行效率。与传统的编译器事先编译不同，JIT编译器在运行时进行编译，因此可以针对特定的运行环境进行优化。\n\nJava性能低的主要原因和跨平台特性\nJava语言如果不做任何的优化，性能其实是不如C和C++语言的。主要原因是：\n\n在程序运行过程中，Java虚拟机需要将字节码指令实时地解释成计算机能识别的机器码，这个过程在运行时可能会反复地执行，所以效率较低。\n\nimg\n\nC和C++语言在执行过程中，只需要将源代码编译成可执行文件，就包含了计算机能识别的机器码，无需在运行过程中再实时地解释，所以性能较高。\n\nimg\n\nJava为什么要选择一条执行效率比较低的方式呢？主要是为了实现跨平台的特性。Java的字节码指令，如果希望在不同平台（操作系统+硬件架构），比如在windows或者linux上运行。可以使用同一份字节码指令，交给windows和linux上的Java虚拟机进行解释，这样就可以获得不同平台上的机器码了。这样就实现了Write Once，Run Anywhere 编写一次，到处运行 的目标。\n\nimg\n\n但是C/C++语言，如果要让程序在不同平台上运行，就需要将一份源代码在不同平台上分别进行编译，相对来说比较麻烦。\n\n再回到即时编译，在JDK1.1的版本中就推出了即时编译去优化对应的性能。\n\nimg\n\n虚拟机在运行过程中如果发现某一个方法甚至是循环是热点代码（被非常高频调用），即时编译器会优化这段代码并将优化后的机器码保存在内存中，如果第二次再去执行这段代码。Java虚拟机会将机器码从内存中取出来直接进行调用。这样节省了一次解释的步骤，同时执行的是优化后的代码，效率较高。\n\nJava通过即时编译器获得了接近C/C++语言的性能，在某些特定的场景下甚至可以实现超越。\n\n1.3 JVM的类型\n1.3.1 Java虚拟机规范\n《Java虚拟机规范》由Oracle制定，内容主要包含了Java虚拟机在设计和实现时需要遵守的规范，主要包含class字节码文件的定义、类和接口的加载和初始化、指令集等内容。\n《Java虚拟机规范》是对虚拟机设计的要求，而不是对Java设计的要求，也就是说虚拟机可以运行在其他的语言比如Groovy、Scala生成的class字节码文件之上。\n官网地址：https://docs.oracle.com/javase/specs/index.html\n1.3.2 Java的常见类型\n平时我们最常用的，就是Hotspot虚拟机。\n\n名称	作者	支持版本	社区活跃度（github star）	特性	适用场景\nHotSpot (Oracle JDK版)	Oracle	所有版本	高(闭源)	使用最广泛，稳定可靠，社区活跃JIT支持Oracle JDK默认虚拟机	默认\nHotSpot (Open JDK版)	Oracle	所有版本	中(16.1k)	同上开源，Open JDK默认虚拟机	默认对JDK有二次开发需求\nGraalVM	Oracle	11, 17,19企业版支持8	高（18.7k）	多语言支持高性能、JIT、AOT支持	微服务、云原生架构需要多语言混合编程\nDragonwell JDK龙井	Alibaba	标准版 8,11,17扩展版11,17	低(3.9k)	基于OpenJDK的增强高性能、bug修复、安全性提升JWarmup、ElasticHeap、Wisp特性支持	电商、物流、金融领域对性能要求比较高\nEclipse OpenJ9 (原 IBM J9)	IBM	8,11,17,19,20	低(3.1k)	高性能、可扩展JIT、AOT特性支持	微服务、云原生架构\n1.3.3 HotSpot的发展历程\n初出茅庐 - 1999年4月\n源自1997年收购的SmallTalk语言的虚拟机，HotSpot虚拟机初次在JDK中使用。在JDK1.2中作为附加功能存在，\n\nJDK1.3之后作为默认的虚拟机。\n\n野蛮生长 - 2006年12月\nJDK 6发布，并在虚拟机层面做了大量的优化，这些优化对后续虚拟机的发展产生了深远的影响。\n\n稳步前进 - 2009-2013\nJDK7中首次推出了G1垃圾收集器。收购了Sun公司之后，吸纳了JRockIt虚拟机的一些设计思想，JDK8中引入了JMC等工具，去除了永久代。\n\n百家争鸣 - 2018-2019\nJDK11优化了G1垃圾收集器的性能,同时推出了ZGC新一代的垃圾回收器，JDK12推出Shenan-doah垃圾回收器。\n\n拥抱云原生 - 2019-至今\n以Hotspot为基础的GraalVM虚拟机诞生，不仅让解决了单体应用中多语言整合的难题，同时也提升了这些语言运行时的效率。极高的性能、极快的启动速度也更适用于当下的云原生架构。\n\n1.4 Java生态框架\nimg\n\nJDK发展历程\n2000年，JDK 1.3发布，Java HotSpot Virtual Machine正式发布，成为Java的默认虚拟机。 2002年，JDK 1.4发布，古老的Classic虚拟机退出历史舞台。 2003年年底，Java平台的Scala正式发布，同年Groovy也加入了 Java阵营。 2006年，JDK 6发布。同年，Java开源并建立了 OpenJDK。顺理成章，Hotspot虚拟机也成为了 OpenJDK中的默认虚拟机。 2007年，Java平台迎来了新伙伴Clojure。 2008 年，Oracle 收购了 BEA,得到了 JRockit 虚拟机。 2009年，Twitter宣布把后台大部分程序从Ruby迁移到Scala，这是Java平台的又一次大规模应用。 2010年，Oracle收购了Sun，获得Java商标和最具价值的HotSpot虚拟机。此时，Oracle拥有市场占用率最高的两款虚拟机HotSpot和JRockit，并计划在未来对它们进行整合：HotRockit. JCP组织管理：Java语言 2011年，JDK7发布。在JDK 1.7u4中，正式启用了新的垃圾回收器G1。 2017年，JDK9发布。将G1设置为默认GC，替代CMS (被标记为Deprecated) 同年，IBM的J9开源，形成了现在的Open J9社区 2018年，Android的Java侵权案判决，Google赔偿Oracle计88亿美元 同年，JDK11发布，LTS版本的JDK,发布革命性的ZGC,调整JDK授权许可 2019年，JDK12发布，加入RedHat领导开发的Shenandoah GC\n\nOracle与OpenJDK之间的主要区别\nOracle JDK版本将每三年发布一次LTS版本，而OpenJDK版本每三个月发布一次。\nOracle JDK将更多地关注稳定性，它重视更多的企业级用户，而OpenJDK经常发布以支持其他性能，这可能会导致不稳定。\nOracle JDK支持长期发布的更改，而Open JDK仅支持计划和完成下一个发行版。\nOracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。 使用Oracle平台时会产生一些许可影响。如Oracle 宣布的那样，在没有商业许可的情况下，在2019年1月之后发布的Oracle Java SE 8的公开更新将无法用于商业，商业或生产用途。但是，OpenJDK是完全开源的，可以自由使用。\nOracle JDK的构建过程基于OpenJDK，因此OpenJDK与Oracle JDK之间没有技术差异。\n顶级公司正在使用Oracle JDK，例如Android Studio，Minecraft和IntelliJ IDEA开发工具，其中Open JDK不太受欢迎。\nOracle JDK具有Flight Recorder，Java Mission Control和Application Class-Data Sharing功能，Open JDK具有Font Renderer功能，这是OpenJDK与Oracle JDK之间的显着差异。\nOracle JDK具有良好的GC选项和更好的渲染器，而OpenJDK具有更少的GC选项，并且由于其包含自己的渲染器的分布，因此具有较慢的图形渲染器选项。\n在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能。\n与OpenJDK相比，Oracle JDK的开源社区较少，OpenJDK社区用户的表现优于Oracle JDK发布的功能，以提高性能。\n如果使用Oracle JDK会产生许可影响，而OpenJDK没有这样的问题，并且可以以任何方式使用，以满足完全开源和免费使用。\nOracle JDK在运行JDK时不会产生任何问题，而OpenJDK在为某些用户运行JDK时会产生一些问题。\n根据使用方的使用和许可协议，现有应用程序可以从Oracle JDK迁移到Open JDK，反之亦然。\nOracle JDK将从其10.0.X版本将收费，用户必须付费或必须依赖OpenJDK才能使用其免费版本。\nOracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本。\nOracle JDK以前的1.0版以前的版本是由Sun开发的，后来被Oracle收购并为其他版本维护，而OpenJDK最初只基于Java SDK或JDK版本7。\nOracle JDK发布时大多数功能都是开源的，其中一些功能免于开源，并且根据Sun的许可授权，而OpenJDK发布了所有功能，如开源和免费。\nOracle JDK完全由Oracle公司开发，而Open JDK项目由IBM，Apple，SAP AG，Redhat等顶级公司加入和合作。\n1.5 JVM组成框架\nimage-20240403000639342\n\nimg\n\nimage-20240403154753322\n\nimage-20240403153528645\n\n最上层：javac编译器将编译好的字节码class文件，通过java 类装载器执行机制，把对象或class文件存放在 jvm划分内存区域。 中间层：称为Runtime Data Area，主要是在Java代码运行时用于存放数据的，从左至右为方法区(永久代、元数据区)、堆(共享,GC回收对象区域)、栈、程序计数器、寄存器、本地方法栈(私有)。 最下层：解释器、JIT(just in time)编译器和 GC（Garbage Collection，垃圾回收器）\n\n类加载子系统：核心组件类加载器，负责将字节码文件中的内容加载到内存中。\n\n运行时数据区：JVM管理的内存，创建出来的对象、类的信息等等内容都会放在这块区域中。\n\n执行引擎：包含了即时编译器、解释器、垃圾回收器，执行引擎使用解释器将字节码指令解释成机器码，使用即时编译器优化性能，使用垃圾回收器回收不再使用的对象。\n\n本地接口：调用本地使用C/C++编译好的方法，本地方法在Java中声明时，都会带上native关键字，如下图所示。\n\nimg\n\n1.6 JVM功能框架\nimage-20240514153726631\n\n2、字节码文件详解\n2.2 字节码文件的组成\n2.2.1 以正确的姿势打开文件\n字节码文件中保存了源代码编译之后的内容，以二进制的方式存储，无法直接用记事本打开阅读。\n\n通过NotePad++使用十六进制插件查看class文件：\n\nimg\n\n无法解读出文件里包含的内容，推荐使用 jclasslib工具查看字节码文件。 Github地址： https://github.com/ingokegel/jclasslib\n\n安装方式：找到 资料\\工具\\jclasslib_win64_6_0_4.exe 安装即可\n\nimg\n\n2.2.2 字节码文件的组成\n字节码文件总共可以分为以下几个部分：\n\n基础信息：魔数、字节码文件对应的Java版本号、访问标识(public final等等)、父类和接口信息\n\n常量池： 保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用\n\n字段： 当前类或接口声明的字段信息\n\n字节码中的字段指的是类或接口中声明的变量，用于存储对象的状态或数据。字段在字节码中用 field_info 结构表示，其中包含字段的名称、类型、访问标志等信息。字节码指令可以通过字段的名称或索引来读取或写入字段的值。\n字段表示类或接口中声明的变量，用于存储对象的状态或数据。\n方法： 当前类或接口声明的方法信息，核心内容为方法的字节码指令\n\n属性： 类的属性，比如源码的文件名、内部类的列表等\n\n字节码中的属性是一种用于附加额外信息于类、字段、方法或代码段的机制。属性在字节码中用 attribute_info 结构表示，常见的属性包括源文件信息、行号表、局部变量表、异常表等。属性提供了额外的元数据，用于调试、优化或其他用途。\n属性表示与类、字段、方法或代码段相关的附加信息。\n2.2.2.1 基本信息\n基本信息包含了jclasslib中能看到的两块内容：\n\nimg\n\nMagic魔数\n每个Java字节码文件的前四个字节是固定的，用16进制表示就是0xcafebabe。文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改不影响文件的内容。软件会使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错。\n\n比如常见的文件格式校验方式如下：\n\nimg\n\nJava字节码文件中，将文件头称为magic魔数。Java虚拟机会校验字节码文件的前四个字节是不是0xcafebabe，如果不是，该字节码文件就无法正常使用，Java虚拟机会抛出对应的错误。\n\n主副版本号\n主副版本号指的是编译字节码文件时使用的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1使用了45.0-45.3，JDK1.2是46之后每升级一个大版本就加1；副版本号是当主版本号相同时作为区分不同版本的标识，一般只需要关心主版本号。\n\n1.2之后大版本号计算方法就是 : 主版本号 – 44，比如主版本号52就是JDK8。\n\nimg\n\n版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容。如果使用较低版本的JDK去运行较高版本JDK的字节码文件，无法使用会显示如下错误：\n\nimg\n\n有两种方案：\n\n1.升级JDK版本，将图中使用的JDK6升级至JDK8即可正常运行，容易引发其他的兼容性问题，并且需要大量的测试。\n\n2.将第三方依赖的版本号降低或者更换依赖，以满足JDK版本的要求。建议使用这种方案\n\n其他基础信息\n其他基础信息包括访问标识、类和接口索引，如下：\n\nimg\n\n2.2.2.2 常量池\n字节码文件中常量池的作用：避免相同的内容重复定义，节省空间。如下图，常量池中定义了一个字符串，字符串的字面量值为123。\n\nimg\n\n比如在代码中，编写了两个相同的字符串“我爱北京天安门”，字节码文件甚至将来在内存中使用时其实只需要保存一份，此时就可以将这个字符串以及字符串里边包含的字面量，放入常量池中以达到节省空间的作用。\n\nString str1 = \"我爱北京天安门\";\nString str2 = \"我爱北京天安门\";\n常量池中的数据都有一个编号，编号从1开始。比如“我爱北京天安门”这个字符串，在常量池中的编号就是7。在字段或者字节码指令中通过编号7可以快速的找到这个字符串。\n\n字节码指令中通过编号引用到常量池的过程称之为符号引用。\n\nimg\n\n2.2.2.3 字段\n字段中存放的是当前类或接口声明的字段信息。\n\n如下图中，定义了两个字段a1和a2，这两个字段就会出现在字段这部分内容中。同时还包含字段的名字、描述符（字段的类型）、访问标识（public/private static final等）。\n\nimg\n\n2.2.2.4 方法\n字节码中的方法区域是存放字节码****指令的核心位置，字节码指令的内容存放在方法的Code属性中。\n\nimg\n\n通过分析方法的字节码指令，可以清楚地了解一个方法到底是如何执行的。先来看如下案例：\n\nint i = 0;\nint j = i + 1;\n这段代码编译成字节码指令之后是如下内容：\n\nimg\n\n要理解这段字节码指令是如何执行的，我们需要先理解两块内存区域：操作数栈和局部变量表。\n\n操作数栈是用来存放临时数据的内容，是一个栈式的结构，先进后出。\n\n局部变量****表是存放方法中的局部变量，包含方法的参数、方法中定义的局部变量，在编译期就已经可以确定方法有多少个局部变量。\n\n1、iconst_0，将常量0放入操作数栈。此时栈上只有0。\n\nimg\n\n2、istore_1会从操作数栈中，将栈顶的元素弹出来，此时0会被弹出，放入局部变量表的1号位置。局部变量表中的1号位置，在编译时就已经确定是局部变量i使用的位置。完成了对局部变量i的赋值操作。\n\nimg\n\n3、iload_1将局部变量表1号位置的数据放入操作数栈中，此时栈中会放入0。\n\nimg\n\n4、iconst_1会将常量1放入操作数栈中。\n\nimg\n\n5、iadd会将操作数栈顶部的两个数据相加，现在操作数栈上有两个数0和1，相加之后结果为1放入操作数栈中，此时栈上只有一个数也就是相加的结果1。\n\nimg\n\n6、istore_2从操作数栈中将1弹出，并放入局部变量表的2号位置，2号位置是j在使用。完成了对局部变量j的赋值操作。\n\nimg\n\n7、return语句执行，方法结束并返回。\n\nimg\n\n同理，同学们可以自行分析下i++和++i的字节码指令执行的步骤。\n\ni++的字节码指令如下，其中iinc 1 by 1指令指的是将局部变量表1号位置增加1，其实就实现了i++的操作。\n\nimg\n\n而++i只是对两个字节码指令的顺序进行了更改：\n\nimg\n\n面试题：\n问：int i = 0; i = i++; 最终i的值是多少？\n\n答：答案是0，我通过分析字节码指令发现，i++先把0取出来放入临时的操作数栈中，\n\n接下来对i进行加1，i变成了1，最后再将之前保存的临时值0放入i，最后i就变成了0。\n\n2.2.2.5 属性\n属性主要指的是类的属性，比如源码的文件名、内部类的列表等。\n\nimg\n\n2.2.3 玩转字节码常用工具\n2.2.3.1 javap\njavap是JDK自带的反编译工具，可以通过控制台查看字节码文件的内容。适合在服务器上查看字节码文件内容。\n\n直接输入javap查看所有参数。输入javap -v 字节码文件名称 查看具体的字节码信息。如果jar包需要先使用 jar –xvf 命令解压。\n\nimg\n\n2.2.3.2 jclasslib插件\njclasslib也有Idea插件版本，建议开发时使用Idea插件版本，可以在代码编译之后实时看到字节码文件内容。\n\n安装方式：\n\n1、打开idea的插件页面，搜索jclasslib\n\nimg\n\n2、选中要查看的源代码文件，选择 视图(View) - Show Bytecode With Jclasslib\n\nimg\n\n右侧会展示对应源代码编译后的字节码文件内容：\n\nimg\n\ntips:\n\n1、一定要选择文件再点击视图(view)菜单，否则菜单项不会出现。\n\n2、文件修改后一定要重新编译之后，再点击刷新按钮。\n\n2.2.3.3 Arthas\nArthas 是一款线上监控诊断产品，通过全局视角实时查看应用 load、内存、gc、线程的状态信息，并能在不修改应用代码的情况下，对业务问题进行诊断，大大提升线上问题排查效率。 官网：https://arthas.aliyun.com/doc/ Arthas的功能列表如下：\n\nimg\n\n安装方法：\n\n1、将 资料/工具/arthas-boot.jar 文件复制到任意工作目录。\n\n2、使用java -jar arthas-boot.jar 启动程序。\n\n3、输入需要Arthas监控的进程id。\n\nimg\n\n4、输入命令即可使用。\n\ndump\n\n命令详解：https://arthas.aliyun.com/doc/dump.html\n\ndump命令可以将字节码文件保存到本地，如下将java.lang.String 的字节码文件保存到了/tmp/output目录下：\n\n$ dump -d /tmp/output java.lang.String\n\n HASHCODE  CLASSLOADER  LOCATION\n null                   /tmp/output/java/lang/String.class\nAffect(row-cnt:1) cost in 138 ms.\njad\n\n命令详解：https://arthas.aliyun.com/doc/jad.html\n\njad命令可以将类的字节码文件进行反编译成源代码，用于确认服务器上的字节码文件是否是最新的，如下将demo.MathGame的源代码进行了显示。\n\n$ jad --source-only demo.MathGame\n/*\n * Decompiled with CFR 0_132.\n */\npackage demo;\n\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Random;\nimport java.util.concurrent.TimeUnit;\n\npublic class MathGame {\n    private static Random random = new Random();\n    public int illegalArgumentCount = 0;\n...\n2.3、类的生命周期\n类的生命周期描述了一个类加载、使用、卸载的整个过程。整体可以分为：\n\n加载\n连接，其中又分为验证、准备、解析三个子阶段\n初始化\n使用\n卸载\nimg\n\n2.3.1 加载阶段\n1、加载(Loading)阶段第一步是类加载器根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息，程序员可以使用Java代码拓展的不同的渠道。\n\n从本地磁盘上获取文件\n运行时通过动态代理生成，比如Spring框架\nApplet技术通过网络获取字节码文件\n2、类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中，方法区中生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息。\n\nimg\n\n4、Java虚拟机同时会在堆上生成与方法区中数据类似的java.lang.Class对象，作用是在Java代码中去获取类的信息以及存储静态字段的数据（JDK8及之后）。\n\nimg\n\n2.3.2 连接阶段\n连接阶段分为三个子阶段:\n\n验证，验证内容是否满足《Java虚拟机规范》。\n准备，给静态变量赋初值。\n解析，将常量池中的符号引用替换成指向内存的直接引用。\nimg\n\n验证\n验证的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与。主要包含如下四部分，具体详见《Java虚拟机规范》：\n\n1、文件格式验证，比如文件是否以0xCAFEBABE开头，主次版本号是否满足当前Java虚拟机版本要求。\n\nimg\n\n2、元信息验证，例如类必须有父类（super不能为空）。\n\n3、验证程序执行指令的语义，比如方法内的指令执行中跳转到不正确的位置。\n\n4、符号引用验证，例如是否访问了其他类中private的方法等。\n\n对版本号的验证，在JDK8的源码中如下：\n\nimg\n\n编译文件的主版本号不能高于运行环境主版本号，如果主版本号相等，副版本号也不能超过。\n\n准备\n准备阶段为静态变量（static）分配内存并设置初值，每一种基本数据类型和引用数据类型都有其初值。\n\n数据类型	初始值\nint	0\nlong	0L\nshort	0\nchar	‘\\u0000’\nbyte	0\nboolean	false\ndouble	0.0\n引用数据类型	null\n如下代码：\n\npublic class Student{\n\npublic static int value = 1;\n\n}\n在准备阶段会为value分配内存并赋初值为0，在初始化阶段才会将值修改为1。\n\nfinal修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。\n\n如下例子中，变量加上final进行修饰，在准备阶段value值就直接变成1了，因为final修饰的变量后续不会发生值的变更。\n\nimg\n\n来看这个案例：\n\npublic class HsdbDemo {\n    public static final int i = 2;\n    public static void main(String[] args) throws IOException, InstantiationException, IllegalAccessException {\n        HsdbDemo hsdbDemo = new HsdbDemo();\n        System.out.println(i);\n        System.in.read();\n    }\n}\n从字节码文件也可以看到，编译器已经确定了该字段指向了常量池中的常量2：\n\nimg\n\n解析\n解析阶段主要是将常量池中的符号引用替换为直接引用，符号引用就是在字节码文件中使用编号来访问常量池中的内容。\n\nimg\n\n直接引用不在使用编号，而是使用内存中地址进行访问具体的数据。\n\nimg\n\n2.3.3 初始化阶段\n初始化阶段会执行字节码文件中clinit（class init 类的初始化）方法的字节码指令，包含了静态代码块中的代码，并为静态变量赋值。\n\n如下代码编译成字节码文件之后，会生成三个方法：\n\npublic class Demo1 {\n\n    public static int value = 1;\n    static {\n        value = 2;\n    }\n   \n    public static void main(String[] args) {\n\n    }\n}\nimg\n\ninit方法，会在对象初始化时执行\nmain方法，主方法\nclinit方法，类的初始化阶段执行\n继续来看clinit方法中的字节码指令：\n\n1、iconst_1，将常量1放入操作数栈。此时栈中只有1这个数。\n\nimg\n\n2、putstatic指令会将操作数栈上的数弹出来，并放入堆中静态变量的位置，字节码指令中#2指向了常量池中的静态变量value，在解析阶段会被替换成变量的地址。\n\nimg\n\n3、后两步操作类似，执行value=2，将堆上的value赋值为2。\n\n如果将代码的位置互换：\n\npublic class Demo1 {\n    static {\n        value = 2;\n    }\n   \n    public static int value = 1;\n   \n    public static void main(String[] args) {\n\n    }\n}\n字节码指令的位置也会发生变化：\n\nimg\n\n这样初始化结束之后，最终value的值就变成了1而不是2。\n\n以下几种方式会导致类的初始化：\n\n1.访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化。\n\n2.调用Class.forName(String className)。\n\n3.new一个该类的对象时。\n\n4.执行Main方法的当前类。\n\n添加-XX:+TraceClassLoading 参数可以打印出加载并初始化的类\n\n面试题1：\n如下代码的输出结果是什么？\n\npublic class Test1 {\n    public static void main(String[] args) {\n        System.out.println(\"A\");\n        new Test1();\n        new Test1();\n    }\n\n    public Test1(){\n        System.out.println(\"B\");\n    }\n\n    {\n        System.out.println(\"C\");\n    }\n\n    static {\n        System.out.println(\"D\");\n    }\n}\n分析步骤：\n\n1、执行main方法之前，先执行clinit指令。\n\nimg\n\n指令会输出D\n\n2、执行main方法的字节码指令。\n\nimg\n\n指令会输出A\n\n3、创建两个对象，会执行两次对象初始化的指令。\n\nimg\n\n这里会输出CB，源代码中输出C这行，被放到了对象初始化的一开始来执行。\n\n所以最后的结果应该是DACBCB\n\nclinit不会执行的几种情况\n如下几种情况是不会进行初始化指令执行的：\n\n1.无静态代码块且无静态变量赋值语句。\n\n2.有静态变量的声明，但是没有赋值语句。\n\nimg\n\n3.静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化。\n\nimg\n\n面试题2：\n如下代码的输出结果是什么？\n\npublic class Demo01 {\n    public static void main(String[] args) {\n        new B02();\n        System.out.println(B02.a);\n    }\n}\n\nclass A02{\n    static int a = 0;\n    static {\n        a = 1;\n    }\n}\n\nclass B02 extends A02{\n    static {\n        a = 2;\n    }\n}\n分析步骤：\n\n1、调用new创建对象，需要初始化B02，优先初始化父类。\n\n2、执行A02的初始化代码，将a赋值为1。\n\n3、B02初始化，将a赋值为2。\n\n变化\n将new B02();注释掉会怎么样？\n\n分析步骤：\n\n1、访问父类的静态变量，只初始化父类。\n\n2、执行A02的初始化代码，将a赋值为1。\n\n补充练习题\n分析如下代码执行结果:\n\npublic class Test2 {\n    public static void main(String[] args) {\n        Test2_A[] arr = new Test2_A[10];\n\n    }\n}\n\nclass Test2_A {\n    static {\n        System.out.println(\"Test2 A的静态代码块运行\");\n    }\n}\n数组的创建不会导致数组中元素的类进行初始化。\n\npublic class Test4 {\n    public static void main(String[] args) {\n        System.out.println(Test4_A.a);\n    }\n}\n\nclass Test4_A {\n    public static final int a = Integer.valueOf(1);\n\n    static {\n        System.out.println(\"Test3 A的静态代码块运行\");\n    }\n}\nfinal修饰的变量如果赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化。\n\n2、类加载器\n2.4、类加载器\n2.4.1 什么是类加载器\n类加载器（ClassLoader）是Java虚拟机提供给应用程序去实现获取类和接口字节码数据的技术，类加载器只参与加载过程中的字节码获取并加载到内存这一部分。\n\nimg\n\n类加载器会通过二进制流的方式获取到字节码文件的内容，接下来将获取到的数据交给Java虚拟机，虚拟机会在方法区和堆上生成对应的对象保存字节码信息。\n\n2.4.2 类加载器的分类\n类加载器分为两类，一类是Java代码中实现的，一类是Java虚拟机底层源码实现的。\n\n虚拟机底层实现：源代码位于Java虚拟机的源码中，实现语言与虚拟机底层语言一致，比如Hotspot使用C++。主要目的是保证Java程序运行中基础类被正确地加载，比如java.lang.String，Java虚拟机需要确保其可靠性。\nJDK中默认提供或者自定义：JDK中默认提供了多种处理不同渠道的类加载器，程序员也可以自己根据需求定制，使用Java语言。所有Java中实现的类加载器都需要继承ClassLoader这个抽象类。\n类加载器的设计JDK8和8之后的版本差别较大，首先来看JDK8及之前的版本，这些版本中默认的类加载器有如下几种：\n\nimg\n\n类加载器的详细信息可以通过Arthas的classloader命令查看：\n\nclassloader - 查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource\n\nimg\n\nBootstrapClassLoader是启动类加载器，numberOfInstances是类加载器的数量只有1个，loadedCountTotal是加载类的数量1861个。\nExtClassLoader是扩展类加载器\nAppClassLoader是应用程序类加载器\n2.4.3 启动类加载器\n启动类加载器（Bootstrap ClassLoader）是由Hotspot虚拟机提供的、使用C++编写的类加载器。\n默认加载Java安装目录/jre/lib下的类文件，比如rt.jar，tools.jar，resources.jar等。\n运行如下代码：\n\n/**\n * 启动程序类加载器案例\n */\npublic class BootstrapClassLoaderDemo {\n    public static void main(String[] args) throws IOException {\n        ClassLoader classLoader = String.class.getClassLoader();\n        System.out.println(classLoader);\n\n        System.in.read();\n    }\n}\n这段代码通过String类获取到它的类加载器并且打印，结果是null。这是因为启动类加载器在JDK8中是由C++语言来编写的，在Java代码中去获取既不适合也不安全，所以才返回null\n\n在Arthas中可以通过sc -d 类名的方式查看加载这个类的类加载器详细的信息，比如：\n\nimg\n\n通过上图可以看到，java.lang.String类的类加载器是空的，Hash值也是null。\n\n用户扩展基础jar包\n如果用户想扩展一些比较基础的jar包，让启动类加载器加载，有两种途径：\n\n放入jre/lib下进行扩展。不推荐，尽可能不要去更改JDK安装目录中的内容，会出现即时放进去由于文件名不匹配的问题也不会正常地被加载。\n**使用参数进行扩展。**推荐，使用-Xbootclasspath/a:jar包目录/jar包名 进行扩展，参数中的/a代表新增。\n如下图，在IDEA配置中添加虚拟机参数，就可以加载D:/jvm/jar/classloader-test.jar这个jar包了。\n\nimg\n\n2.4.4 扩展类加载器和应用程序类加载器\n扩展类加载器和应用程序类加载器都是JDK中提供的、使用Java编写的类加载器。\n它们的源码都位于sun.misc.Launcher中，是一个静态内部类。继承自URLClassLoader。具备通过目录或者指定jar包将字节码文件加载到内存中。\n继承关系图如下：\n\nimg\n\nClassLoader类定义了具体的行为模式，简单来说就是先从本地或者网络获得字节码信息，然后调用虚拟机底层的方法创建方法区和堆上的对象。这样的好处就是让子类只需要去实现如何获取字节码信息这部分代码。\nSecureClassLoader提供了证书机制，提升了安全性。\nURLClassLoader提供了根据URL获取目录下或者指定jar包进行加载，获取字节码的数据。\n扩展类加载器和应用程序类加载器继承自URLClassLoader，获得了上述的三种能力。\n扩展类加载器\n扩展类加载器（Extension Class Loader）是JDK中提供的、使用Java编写的类加载器。默认加载Java安装目录/jre/lib/ext下的类文件。\n\nimg\n\n如下代码会打印ScriptEnvironment类的类加载器。ScriptEnvironment是nashorn框架中用来运行javascript语言代码的环境类，他位于nashorn.jar包中被扩展类加载器加载\n\n/**\n * 扩展类加载器\n */\npublic class ExtClassLoaderDemo {\n    public static void main(String[] args) throws IOException {\n        ClassLoader classLoader = ScriptEnvironment.class.getClassLoader();\n        System.out.println(classLoader);\n    }\n}\n打印结果如下：\n\nimg\n\n通过扩展类加载器去加载用户jar包：\n\n放入/jre/lib/ext下进行扩展。不推荐，尽可能不要去更改JDK安装目录中的内容。\n使用参数进行扩展使用参数进行扩展。推荐，使用-Djava.ext.dirs=jar包目录 进行扩展,这种方式会覆盖掉原始目录，可以用;(windows):(macos/linux)追加上原始目录\n如下图中：\n\nimg\n\n使用引号将整个地址包裹起来，这样路径中即便是有空格也不需要额外处理。路径中要包含原来ext文件夹，同时在最后加上扩展的路径。\n\n应用程序加载器\n应用程序类加载器会加载classpath下的类文件，默认加载的是项目中的类以及通过maven引入的第三方jar包中的类。\n\n如下案例中，打印出Student和FileUtils的类加载器：\n\n/**\n * 应用程序类加载器案例\n */\npublic class AppClassLoaderDemo {\n    public static void main(String[] args) throws IOException, InterruptedException {\n        //当前项目中创建的Student类\n        Student student = new Student();\n        ClassLoader classLoader = Student.class.getClassLoader();\n        System.out.println(classLoader);\n\n        //maven依赖中包含的类\n        ClassLoader classLoader1 = FileUtils.class.getClassLoader();\n        System.out.println(classLoader1);\n\n        Thread.sleep(1000);\n        System.in.read();\n\n    }\n}\n输出结果如下：\n\nimg\n\n这两个类均由应用程序类加载器加载。\n\n类加载器的加载路径可以通过classloader –c hash值 查看：\n\nimg\n\n2.5、双亲委派机制\n双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会自底向上查找是否加载过，\n\n再由顶向下进行加载。\n\nimg\n\n详细流程：\n\n每个类加载器都有一个父类加载器。父类加载器的关系如下，启动类加载器没有父类加载器：\n\nimg\n\n在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。\n\n案例1：\n比如com.itheima.my.A假设在启动类加载器的加载目录中，而应用程序类加载器接到了加载类的任务。\n\n1、应用程序类加载器首先判断自己加载过没有，没有加载过就交给父类加载器 - 扩展类加载器。\n\nimg\n\n2、扩展类加载器也没加载过，交给他的父类加载器 - 启动类加载器。\n\nimg\n\n3、启动类加载器发现已经加载过，直接返回。\n\nimg\n\n案例2：\nB类在扩展类加载器加载路径中，同样应用程序类加载器接到了加载任务，按照案例1中的方式一层一层向上查找，发现都没有加载过。那么启动类加载器会首先尝试加载。它发现这类不在它的加载目录中，向下传递给扩展类加载器。\n\nimg\n\n扩展类加载器发现这个类在它加载路径中，加载成功并返回。\n\nimg\n\n如果第二次再接收到加载任务，同样地向上查找。扩展类加载器发现已经加载过，就可以返回了。\n\nimg\n\n双亲委派机制的作用\n1.保证类加载的安全性。通过双亲委派机制避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。\n\n2.避免重复加载。双亲委派机制可以避免同一个类被多次加载。\n\n如何指定加载类的类加载器？\n在Java中如何使用代码的方式去主动加载一个类呢？\n\n方式1：使用Class.forName方法，使用当前类的类加载器去加载指定的类。\n\n方式2：获取到类加载器，通过类加载器的loadClass方法指定某个类加载器加载。\n\n例如：\n\nimg\n\n三个面试题\n1、如果一个类重复出现在三个类加载器的加载位置，应该由谁来加载？\n\n启动类加载器加载，根据双亲委派机制，它的优先级是最高的\n\n2、String类能覆盖吗，在自己的项目中去创建一个java.lang.String类，会被加载吗？\n\n不能，会返回启动类加载器加载在rt.jar包中的String类。\n\n3、类的双亲委派机制是什么？\n\n当一个类加载器去加载某个类的时候，会自底向上查找是否加载过，如果加载过就直接返回，如果一直到最顶层的类加载器都没有加载，再由顶向下进行加载。\n应用程序类加载器的父类加载器是扩展类加载器，扩展类加载器的父类加载器是启动类加载器。\n双亲委派机制的好处有两点：第一是避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。第二是避免一个类重复地被加载。\n2.6、打破双亲委派机制\n打破双亲委派机制历史上有三种方式，但本质上只有第一种算是真正的打破了双亲委派机制：\n\n自定义类加载器并且重写loadClass方法。Tomcat通过这种方式实现应用之间类隔离，《面试篇》中分享它的做法。\n线程上下文类加载器。利用上下文类加载器加载类，比如JDBC和JNDI等。\nOsgi框架的类加载器。历史上Osgi框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载，目前很少使用。\n自定义类加载器\n一个Tomcat程序中是可以运行多个Web应用的，如果这两个应用中出现了相同限定名的类，比如Servlet类，Tomcat要保证这两个类都能加载并且它们应该是不同的类。如果不打破双亲委派机制，当应用类加载器加载Web应用1中的MyServlet之后，Web应用2中相同限定名的MyServlet类就无法被加载了。\n\nimg\n\nTomcat使用了自定义类加载器来实现应用之间类的隔离。 每一个应用会有一个独立的类加载器加载对应的类。\n\nimg\n\n那么自定义加载器是如何能做到的呢？首先我们需要先了解，双亲委派机制的代码到底在哪里，接下来只需要把这段代码消除即可。\n\nClassLoader中包含了4个核心方法，双亲委派机制的核心代码就位于loadClass方法中。\n\npublic Class<?> loadClass(String name)\n类加载的入口，提供了双亲委派机制。内部会调用findClass   重要\n\nprotected Class<?> findClass(String name)\n由类加载器子类实现,获取二进制数据调用defineClass ，比如URLClassLoader会根据文件路径去获取类文件中的二进制数据。重要\n\nprotected final Class<?> defineClass(String name, byte[] b, int off, int len)\n做一些类名的校验，然后调用虚拟机底层的方法将字节码信息加载到虚拟机内存中\n\nprotected final void resolveClass(Class<?> c)\n执行类生命周期中的连接阶段\n1、入口方法：\n\nimg\n\n2、再进入看下：\n\nimg\n\n如果查找都失败，进入加载阶段，首先会由启动类加载器加载，这段代码在findBootstrapClassOrNull中。如果失败会抛出异常，接下来执行下面这段代码：\n\nimg\n\n父类加载器加载失败就会抛出异常，回到子类加载器的这段代码，这样就实现了加载并向下传递。\n\n3、最后根据传入的参数判断是否进入连接阶段：\n\nimg\n\n接下来实现打破双亲委派机制：\n\npackage classloader.broken;//package com.itheima.jvm.chapter02.classloader.broken;\n\nimport org.apache.commons.io.IOUtils;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.nio.charset.StandardCharsets;\nimport java.security.ProtectionDomain;\nimport java.util.regex.Matcher;\n\n/**\n * 打破双亲委派机制 - 自定义类加载器\n */\n\npublic class BreakClassLoader1 extends ClassLoader {\n\n    private String basePath;\n    private final static String FILE_EXT = \".class\";\n\n    //设置加载目录\n    public void setBasePath(String basePath) {\n        this.basePath = basePath;\n    }\n\n    //使用commons io 从指定目录下加载文件\n    private byte[] loadClassData(String name)  {\n        try {\n            String tempName = name.replaceAll(\"\\\\.\", Matcher.quoteReplacement(File.separator));\n            FileInputStream fis = new FileInputStream(basePath + tempName + FILE_EXT);\n            try {\n                return IOUtils.toByteArray(fis);\n            } finally {\n                IOUtils.closeQuietly(fis);\n            }\n\n        } catch (Exception e) {\n            System.out.println(\"自定义类加载器加载失败，错误原因：\" + e.getMessage());\n            return null;\n        }\n    }\n\n    //重写loadClass方法\n    @Override\n    public Class<?> loadClass(String name) throws ClassNotFoundException {\n        //如果是java包下，还是走双亲委派机制\n        if(name.startsWith(\"java.\")){\n            return super.loadClass(name);\n        }\n        //从磁盘中指定目录下加载\n        byte[] data = loadClassData(name);\n        //调用虚拟机底层方法，方法区和堆区创建对象\n        return defineClass(name, data, 0, data.length);\n    }\n\n    public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IOException {\n        //第一个自定义类加载器对象\n        BreakClassLoader1 classLoader1 = new BreakClassLoader1();\n        classLoader1.setBasePath(\"D:\\\\lib\\\\\");\n\n        Class<?> clazz1 = classLoader1.loadClass(\"com.itheima.my.A\");\n         //第二个自定义类加载器对象\n        BreakClassLoader1 classLoader2 = new BreakClassLoader1();\n        classLoader2.setBasePath(\"D:\\\\lib\\\\\");\n\n        Class<?> clazz2 = classLoader2.loadClass(\"com.itheima.my.A\");\n\n        System.out.println(clazz1 == clazz2);\n\n        Thread.currentThread().setContextClassLoader(classLoader1);\n\n        System.out.println(Thread.currentThread().getContextClassLoader());\n\n        System.in.read();\n     }\n}\n自定义类加载器父类怎么是AppClassLoader呢？\n默认情况下自定义类加载器的父类加载器是应用程序类加载器：\n\nimg\n\n以Jdk8为例，ClassLoader类中提供了构造方法设置parent的内容：\n\nimg\n\n这个构造方法由另外一个构造方法调用，其中父类加载器由getSystemClassLoader方法设置，该方法返回的是AppClassLoader。\n\nimg\n\n两个自定义类加载器加载相同限定名的类，不会冲突吗？\n不会冲突，在同一个Java虚拟机中，只有相同类加载器+相同的类限定名才会被认为是同一个类。\n\n在Arthas中使用sc –d 类名的方式查看具体的情况。\n\n如下代码：\n\n public static void main(String[] args) throws ClassNotFoundException, InstantiationException, IllegalAccessException, IOException {\n        //第一个自定义类加载器对象\n        BreakClassLoader1 classLoader1 = new BreakClassLoader1();\n        classLoader1.setBasePath(\"D:\\\\lib\\\\\");\n\n        Class<?> clazz1 = classLoader1.loadClass(\"com.itheima.my.A\");\n         //第二个自定义类加载器对象\n        BreakClassLoader1 classLoader2 = new BreakClassLoader1();\n        classLoader2.setBasePath(\"D:\\\\lib\\\\\");\n\n        Class<?> clazz2 = classLoader2.loadClass(\"com.itheima.my.A\");\n\n        System.out.println(clazz1 == clazz2);\n     }\n打印的应该是false，因为两个类加载器不同，尽管加载的是同一个类名，最终Class对象也不是相同的。\n\n通过Arthas看：\n\nimg\n\n也会出现两个不同的A类。\n\n线程上下文类加载器\n利用上下文类加载器加载类，比如JDBC和JNDI等。\n\n我们来看下JDBC的案例：\n\n1、JDBC中使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动。\n\npackage classloader.broken;//package com.itheima.jvm.chapter02.classloader.broken;\n\nimport com.mysql.cj.jdbc.Driver;\n\nimport java.sql.*;\n\n/**\n * 打破双亲委派机制 - JDBC案例\n */\n\npublic class JDBCExample {\n    // JDBC driver name and database URL\n    static final String JDBC_DRIVER = \"com.mysql.cj.jdbc.Driver\";\n    static final String DB_URL = \"jdbc:mysql:///bank1\";\n\n    //  Database credentials\n    static final String USER = \"root\";\n    static final String PASS = \"123456\";\n\n    public static void main(String[] args) {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = DriverManager.getConnection(DB_URL, USER, PASS);\n            stmt = conn.createStatement();\n            String sql;\n            sql = \"SELECT id, account_name FROM account_info\";\n            ResultSet rs = stmt.executeQuery(sql);\n\n            //STEP 4: Extract data from result set\n            while (rs.next()) {\n                //Retrieve by column name\n                int id = rs.getInt(\"id\");\n                String name = rs.getString(\"account_name\");\n\n                //Display values\n                System.out.print(\"ID: \" + id);\n                System.out.print(\", Name: \" + name + \"\\n\");\n            }\n            //STEP 5: Clean-up environment\n            rs.close();\n            stmt.close();\n            conn.close();\n        } catch (SQLException se) {\n            //Handle errors for JDBC\n            se.printStackTrace();\n        } catch (Exception e) {\n            //Handle errors for Class.forName\n            e.printStackTrace();\n        } finally {\n            //finally block used to close resources\n            try {\n                if (stmt != null)\n                    stmt.close();\n            } catch (SQLException se2) {\n            }// nothing we can do\n            try {\n                if (conn != null)\n                    conn.close();\n            } catch (SQLException se) {\n                se.printStackTrace();\n            }//end finally try\n        }//end try\n    }//end main\n}//end FirstExample\n2、DriverManager类位于rt.jar包中，由启动类加载器加载。\n\nimg\n\n3、依赖中的mysql驱动对应的类，由应用程序类加载器来加载。\n\nimg\n\n在类中有初始化代码：\n\nimg\n\nDriverManager属于rt.jar是启动类加载器加载的。而用户jar包中的驱动需要由应用类加载器加载，这就违反了双亲委派机制。（这点存疑，一会儿再讨论）\n\n那么问题来了，DriverManager怎么知道jar包中要加载的驱动在哪儿？\n\n1、在类的初始化代码中有这么一个方法LoadInitialDrivers：\n\nimg\n\n2、这里使用了SPI机制，去加载所有jar包中实现了Driver接口的实现类。\n\nimg\n\n3、SPI机制就是在这个位置下存放了一个文件，文件名是接口名，文件里包含了实现类的类名。这样SPI机制就可以找到实现类了。\n\nimg\n\nimg\n\n4、SPI中利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象。\n\nimg\n\n总结：\n\nimg\n\nJDBC案例中真的打破了双亲委派机制吗？\n最早这个论点提出是在周志明《深入理解Java虚拟机》中，他认为打破了双亲委派机制，这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，所以打破了双亲委派机制。\n\n但是如果我们分别从DriverManager以及驱动类的加载流程上分析，JDBC只是在DriverManager加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依然遵循双亲委派机制。\n\n所以我认为这里没有打破双亲委派机制，只是用一种巧妙的方法让启动类加载器加载的类，去引发的其他类的加载。\n\nOsgi框架的类加载器\n历史上，OSGi模块化框架。它存在同级之间的类加载器的委托加载。OSGi还使用类加载器实现了热部署的功能。热部署指的是在服务不停止的情况下，动态地更新字节码文件到内存中。\n\nimg\n\n由于这种机制使用已经不多，所以不再过多讨论OSGi，着重来看下热部署在实际项目中的应用。\n\n案例：使用阿里arthas不停机解决线上问题\n背景：\n\n小李的团队将代码上线之后，发现存在一个小bug，但是用户急着使用，如果重新打包再发布需要一个多小时的时间，所以希望能使用arthas尽快的将这个问题修复。\n\n思路：\n\n在出问题的服务器上部署一个 arthas，并启动。\njad --source-only 类全限定名 > 目录/文件名.java jad 命令反编译，然后可以用其它编译器，比如 vim 来修改源码\nmc –c 类加载器的hashcode 目录/文件名.java -d 输出目录\n​ mc 命令用来编译修改过的代码\n\nretransform class文件所在目录/xxx.class\n​ 用 retransform 命令加载新的字节码\n\n详细流程：\n\n1、这段代码编写有误，在枚举中的类型判断上使用了== 而不是equals。\n\nimg\n\n2、枚举中是这样定义的，1001是普通用户，1002是VIP用户：\n\nimg\n\n3、由于代码有误，导致传递1001参数时，返回的是收费用户的内容。\n\nimg\n\n4、jad --source-only 类全限定名 > 目录/文件名.java 使用 jad 命令反编译，然后可以用其它编译器，比如 vim 来修改源码\n\nimg\n\n这里直接双击文件使用finalShell编辑：\n\nimg\n\n5、mc –c 类加载器的hashcode 目录/文件名.java -d 输出目录 使用mc 命令用来编译修改过的代码\n\nimg\n\n6、retransform class文件所在目录/xxx.class 用 retransform 命令加载新的字节码\n\nimg\n\n7、测试：\n\nimg\n\n注意事项：\n\n1、程序重启之后，字节码文件会恢复，除非将class文件放入jar包中进行更新。\n\n2、使用retransform不能添加方法或者字段，也不能更新正在执行中的方法。\n\n2.7、JDK9之后的类加载器\nJDK8及之前的版本中，扩展类加载器和应用程序类加载器的源码位于rt.jar包中的sun.misc.Launcher.java。\n\nimg\n\n由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。\n\n1.启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中。\n\nJava中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。\n\n启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。\n\n2、扩展类加载器被替换成了平台类加载器（Platform Class Loader）。\n\n​ 平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。\n\n3、运行时数据区\nJava虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区。《Java虚拟机规范》中规定了每一部分的作用。\n\nimg\n\n3.1 程序计数器\n程序计数器（Program Counter Register）也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址。\n\nimg\n\n一个程序计数器的具体案例：\n\n在加载阶段，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的偏移量转换成内存地址。每一条字节码指令都会拥有一个内存地址。\n\nimg\n\n在代码执行过程中，程序计数器会记录下一行字节码指令的地址。执行完当前指令之后，虚拟机的执行引擎根据程序计数器执行下一行指令。这里为了简单起见，使用偏移量代替，真实内存中执行时保存的应该是地址。\n\n比如当前执行的是偏移量为0的指令，那么程序计数器中保存的就是下一条的地址（偏移量1）。\n\nimg\n\n一路向下执行\n\nimg\n\n一直执行到方法的最后一行指令，此时方法执行return语句，当前方法执行结束，程序计数器中会放入方法出口的地址（栈中讲解，简单来说就是这个B方法结束了，A调用了B，那么要回到A方法）\n\nimg\n\n所以，程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑。不管是分支、跳转、异常，只需要在程序计数器中放入下一行要执行的指令地址即可。\n\n在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU切换前解释执行到那一句指令并继续解释运行。\n\nimg\n\n程序计数器会出现内存溢出吗？\n内存溢出指的是程序在使用某一块内存区域时，存放的数据需要占用的内存大小超过了虚拟机能提供的内存上限。由于每个线程只存储一个固定长度的内存地址，程序计数器是不会发生内存溢出的。程序员无需对程序计数器做任何处理。\n\n3.2 Java虚拟机栈\nJava虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，先进后出（First In Last Out）,每一个方法的调用使用一个栈帧（Stack Frame）来保存。\n\npublic class MethodDemo {   \n    public static void main(String[] args) {        \n         study();    \n     }\n\n    public static void study(){\n        eat();\n\n        sleep();\n    }   \n    \n    public static void eat(){       \n         System.out.println(\"吃饭\");   \n    }    \n    \n    public static void sleep(){        \n        System.out.println(\"睡觉\");    \n        }\n  }\nmain方法执行时，会创建main方法的栈帧：\n\nimg\n\n接下来执行study方法，会创建study方法的栈帧\n\nimg\n\n进入eat方法，创建eat方法的栈帧\n\nimg\n\neat方法执行完之后，会弹出它的栈帧：\n\nimg\n\n然后调用sleep方法，创建sleep方法栈帧\n\nimg\n\n最后study方法结束之后弹出栈帧，main方法结束之后弹出main的栈帧。\n\n在IDEA中也可以看到对应的栈帧：\n\npackage chapter03.frame;\n\n/**\n * 栈帧测试1\n */\npublic class FrameDemo {\n    public static void main(String[] args) {\n        A();\n    }\n\n    public static void A() {\n        System.out.println(\"A执行了...\");\n        B();\n    }\n\n    public static void B() {\n        System.out.println(\"B执行了...\");\n        C();\n    }\n\n    public static void C() {\n        System.out.println(\"C执行了...\");\n        throw new RuntimeException(\"测试\");\n    }\n}\n打上断点debug之后会出现栈帧内容：\n\nimg\n\nJava虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。如下就有两个线程的虚拟机栈，main线程和线程A。\n\nimg\n\nJava虚拟机栈的栈帧中主要包含三方面的内容：\n\n局部变量表，局部变量表的作用是在运行过程中存放所有的局部变量\n操作数栈，操作数栈是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域\n帧数据，帧数据主要包含动态链接、方法出口、异常表的引用\n局部变量表\n局部变量表的作用是在方法执行过程中存放所有的局部变量。局部变量表分为两种，一种是字节码文件中的，另外一种是栈帧中的也就是保存在内存中。栈帧中的局部变量表是根据字节码文件中的内容生成的。\n\n我们先来看下字节码文件中的局部变量表：编译成字节码文件时就可以确定局部变量表的内容。\n\npublic static void test1(){\n    int i = 0;\n    long j = 1;\n}\ntest1方法的局部变量表如下：\n\nimg\n\n局部变量表中保存了字节码指令生效的偏移量：\n\nimg\n\n比如i这个变量，它的起始PC是2，代表从lconst_1这句指令开始才能使用i，长度为3，也就是2-4这三句指令都可以使用i。为什么从2才能使用，因为0和1这两句字节码指令还在处理int i = 0这句赋值语句。j这个变量只有等3指令执行完之后也就是long j = 1代码执行完之后才能使用，所以起始PC为4，只能在4这行字节码指令中使用。\n\n接下来看下栈帧中的局部变量表，栈帧中的局部变量表是一个数组，数组中每一个位置称之为槽(slot) ，long和double类型占用两个槽，其他类型占用一个槽。\n\nimg\n\ni占用数组下标为0的位置，j占用数组下标1-2的位置。\n\n刚才看到的是静态方法，实例方法中的序号为0的位置存放的是this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址。\n\nimg\n\n方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致。局部变量表保存的内容有：实例方法的this对象，方法的参数，方法体中声明的局部变量。\n\nimg\n\ntest3方法中包含两个参数k,m，这两个参数也会被加入到局部变量表中。\n\n以下代码的局部变量表中会占用几个槽？\n\npublic void test4(int k,int m){\n    {\n        int a = 1;\n        int b = 2;\n    }\n    {\n        int c = 1;\n    }\n    int i = 0;\n    long j = 1;\n}\n为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用。\n\n1、方法执行时，实例对象this、k、m 会被放入局部变量表中，占用3个槽\n\nimg\n\n2、将1的值放入局部变量表下标为3的位置上，相当于给a进行赋值。\n\nimg\n\n3、将2放入局部变量表下标为4的位置，给b赋值为2。\n\nimg\n\n4、ab已经脱离了生效范围，所以下标为3和4的这两个位置可以复用。此时c的值1就可以放入下标为3的位置。\n\nimg\n\n4、脱离c的生效范围之后，给i赋值就可以复用c的位置。\n\nimg\n\n5、最后放入j，j是一个long类型，占用两个槽。但是可以复用b所在的位置，所以占用4和5这两个位置\n\nimg\n\n所以，局部变量表数值的长度为6。这一点在编译期间就可以确定了，运行过程中只需要在栈帧中创建长度为6的数组即可。\n\nimg\n\n操作数栈\n操作数栈是栈帧中虚拟机在执行指令过程中用来存放中间数据的一块区域。他是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。\n\n在编译期就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小。\n\nimg\n\n比如之前的相加案例中，操作数栈最大的深入会出现在这个时刻：\n\nimg\n\n所以操作数栈的深度会定义为2。\n\n帧数据\n帧数据主要包含动态链接、方法出口、异常表的引用。\n\n动态链接\n当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系。\n\nimg\n\n方法出口\n方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。\n\nimg\n\n异常表\n异常表存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。\n\nimg\n\n如下案例：i=1这行源代码编译成字节码指令之后，会包含偏移量2-4这三行指令。其中2-3是对i进行赋值1的操作，4的没有异常就跳转到10方法结束。如果出现异常的情况下，继续执行到7这行指令，7会将异常对象放入操作数栈中，这样在catch代码块中就可以使用异常对象了。接下来执行8-9，对i进行赋值为2的操作。\n\nimg\n\n所以异常表中，异常捕获的起始偏移量就是2，结束偏移量是4，在2-4执行过程中抛出了java.lang.Exception对象或者子类对象，就会将其捕获，然后跳转到偏移量为7的指令。\n\n栈内存溢出\nJava虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出。Java虚拟机栈内存溢出时会出现StackOverflowError的错误。\n\nimg\n\n如果我们不指定栈的大小，JVM 将创建一个具有默认大小的栈。大小取决于操作系统和计算机的体系结构。\n\nimg\n\n我们来模拟下栈内存的溢出情况:\n\npublic static int count = 0;\n     //递归方法调用自己\n     public static void recursion(){\n         System.out.println(++count);\n         recursion();\n     }\n使用递归让方法调用自身，但是不设置退出条件。定义调用次数的变量，每一次调用让变量加1。查看错误发生时总调用的次数。\n\nimg\n\n执行之后可以打印出溢出时总栈帧的数量，并且发现虚拟机已经抛出了StackOverflow的错误。\n\n要修改Java虚拟机栈的大小，可以使用虚拟机参数 -Xss 。\n\n语法：-Xss栈大小\n单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)\n例如：\n\n-Xss1048576 \n-Xss1024K      \n-Xss1m\n-Xss1g\n操作步骤如下，不同IDEA版本的设置方式会略有不同：\n\n1、点击修改配置Modify options\n\n2、点击Add VM options\n\n3、添加参数\n\nimg\n\n调成512k之后，明显发现最大栈帧数量减少了：\n\nimg\n\n注意事项：\n\n1、与-Xss类似，也可以使用 -XX:ThreadStackSize 调整标志来配置堆栈大小。\n\n格式为： -XX:ThreadStackSize=1024\n\n2、HotSpot JVM对栈大小的最大值和最小值有要求：\n\n​ 比如测试如下两个参数，会直接报错:\n\n-Xss1k\n-Xss1025m\nWindows（64位）下的JDK8测试最小值为180k，最大值为1024m。\n\n3、局部变量过多、操作数栈深度过大也会影响栈内存的大小。我们在这段代码中添加一些局部变量。\n\n//递归方法调用自己\npublic static void recursion() {\n    long a,b,c,d,f,g,h,i,j,k;\n    System.out.println(++count);\n    recursion();\n}\n使用默认大小来测试之后，发现栈帧数量从10000+减少了到8000+\n\nimg\n\n一般情况下，工作中即便使用了递归进行操作，栈的深度最多也只能到几百,不会出现栈的溢出。所以此参数可以手动指定为-Xss256k节省内存。\n\n3.3 本地方法栈\nJava虚拟机栈存储了Java方法调用时的栈帧，而本地方法栈存储的是native本地方法的栈帧。\n\n在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了同一个栈空间。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来。\n\nimg\n\n比如测试下这段代码：\n\n/**\n * 本地方法栈\n */\npublic class NativeDemo1 {\n    public static void main(String[] args) {\n        try {\n            FileOutputStream fileOutputStream = new FileOutputStream(\"E:\\\\123.txt\");\n            fileOutputStream.write(1);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n执行之后发生异常，会打印出所有栈帧的名字：\n\nimg\n\nopen0是一个本地方法，所以创建了本地方法的栈帧。本地方法和Java虚拟机方法的栈帧在一个栈上。\n\n3.4 堆内存\n一般Java程序中堆内存是空间最大的一块内存区域。创建出来的对象都存在于堆上。栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。\n\npublic class Test {    \n    public static void main(String[] args) {        \n        Student s1 = new Student();        \n        s1.name = \"张三\";       \n        s1.age = 18;       \n        s1.id = 1;\n        s1.printTotalScore();        \n        s1.printAverageScore();        \n        \n        Student s2 = new Student();       \n        s2.name = \"李四\";        \n        s2.age = 19;        \n        s2.id= 2;        \n        s2.printTotalScore();        \n        s2.printAverageScore();    \n    }\n}\n这段代码中通过new关键字创建了两个Student类的对象，这两个对象会被存放在堆上。在栈上通过s1和s2两个局部变量保存堆上两个对象的地址，从而实现了引用关系的建立。\n\nimg\n\n堆内存的溢出\n通过new关键字不停创建对象，放入集合中，模拟堆内存的溢出，观察堆溢出之后的异常信息。\n\npackage chapter03.heap;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\n\n/**\n * 堆内存的使用和回收\n */\npublic class Demo1 {\n    public static void main(String[] args) throws InterruptedException, IOException {\n\n        ArrayList<Object> objects = new ArrayList<Object>();\n        System.in.read();\n        while (true){\n            objects.add(new byte[1024 * 1024 * 100]);\n            Thread.sleep(1000);\n        }\n\n\n    }\n}\n堆内存大小是有上限的，当对象一直向堆中放入对象达到上限之后，就会抛出OutOfMemory错误。在这段代码中，不停创建100M大小的字节数组并放入ArrayList集合中，最终超过了堆内存的上限。抛出如下错误：\n\nimg\n\n三个重要的值\n堆空间有三个需要关注的值，used、total、max。used指的是当前已使用的堆内存，total是java虚拟机已经分配的可用堆内存，max是java虚拟机可以分配的最大堆内存。\n\nimg\n\n堆内存used total max三个值可以通过dashboard命令看到。\n\n手动指定刷新频率（不指定默认5秒一次）：dashboard –i 刷新频率(毫秒)\n\nimg\n\n随着堆中的对象增多，当total可以使用的内存即将不足时，java虚拟机会继续分配内存给堆。\n\nimg\n\n此时used达到了total的大小，Java虚拟机会向操作系统申请更大的内存。\n\nimg\n\n但是这个申请过程不是无限的，total最多只能与max相等。\n\nimg\n\n那么是不是当used = max = total的时候，堆内存就溢出了呢？\n\n不是，堆内存溢出的判断条件比较复杂，在下一章《垃圾回收器》中会详细介绍。\n\n如果不设置任何的虚拟机参数，max默认是系统内存的1/4，total默认是系统内存的1/64。在实际应用中一般都需要设置total和max的值。 Oracle官方文档：https://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html\n\n设置堆的大小\n要修改堆的大小，可以使用虚拟机参数 –Xmx（max最大值）和-Xms (初始的total)。\n\n语法：-Xmx值 -Xms值\n\n单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)\n\n限制：Xmx必须大于 2 MB，Xms必须大于1MB\n\n-Xms6291456\n-Xms6144k\n-Xms6m\n-Xmx83886080\n-Xmx81920k\n-Xmx80m\n这样可以将max和初始的total都设置为4g，在启动后就已经获得了最大的堆内存大小。运行过程中不需要向操作系统申请。\n\nimg\n\n使用arthas的memory命令同样可以看到：\n\nimg\n\n为什么arthas中显示的heap堆大小与设置的值不一样呢？\n\narthas中的heap堆内存使用了JMX技术中内存获取方式，这种方式与垃圾回收器有关，计算的是可以分配对象的内存，而不是整个内存。\n\n建议：\n\nJava服务端程序开发时，建议将-Xmx和-Xms设置为相同的值，这样在程序启动之后可使用的总内存就是最大内存，而无需向java虚拟机再次申请，减少了申请并分配内存时间上的开销，同时也不会出现内存过剩之后堆收缩的情况。-Xmx具体设置的值与实际的应用程序运行环境有关，在《实战篇》中会给出设置方案。\n\n3.5 方法区\n方法区是存放基础信息的位置，线程共享，主要包含三部分内容：\n\n类的元信息，保存了所有类的基本信息\n运行时常量池，保存了字节码文件中的常量池内容\n字符串常量池，保存了字符串常量\n类的元信息\n方法区是用来存储每个类的基本信息（元信息），一般称之为InstanceKlass对象。在类的加载阶段完成。其中就包含了类的字段、方法等字节码文件中的内容，同时还保存了运行过程中需要使用的虚方法表（实现多态的基础）等信息。\n\nimg\n\n运行时常量池\n方法区除了存储类的元信息之外，还存放了运行时常量池。常量池中存放的是字节码中的常量池内容。\n\n字节码文件中通过编号查表的方式找到常量，这种常量池称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速的定位到常量池中的内容，这种常量池称为运行时常量池。\n\nimg\n\n方法区的实现\n方法区是《Java虚拟机规范》中设计的虚拟概念，每款Java虚拟机在实现上都各不相同。Hotspot设计如下：\n\nJDK7及之前的版本将方法区存放在堆区域中的永久代空间，堆的大小由虚拟机参数来控制。\n\nJDK8及之后的版本将方法区存放在元空间中，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受的上限，可以一直分配。\n\nimg\n\n可以通过arthas的memory命令看到方法区的名称以及大小：\n\nJDK7及之前的版本查看ps_perm_gen属性。\nimg\n\nJDK8及之后的版本查看metaspace属性。\nimg\n\n方法区的溢出\n通过ByteBuddy框架，动态创建类并将字节码数据加载到内存中。通过死循环不停地加载到方法区，观察方法区是否会出现内存溢出的情况。分别在JDK7和JDK8上运行上述代码。\n\nByteBuddy是一个基于Java的开源库，用于生成和操作Java字节码。\n\n1.引入依赖\n\n<dependency>\n    <groupId>net.bytebuddy</groupId>\n    <artifactId>byte-buddy</artifactId>\n    <version>1.12.23</version>\n </dependency>\n2.创建ClassWriter对象\n\n ClassWriter classWriter = new ClassWriter(0);\n3.调用visit方法，创建字节码数据。\n\nclassWriter.visit(Opcodes.V1_7,Opcodes.ACC_PUBLIC,name,null ,\"java/lang/Object\",null);\nbyte[] bytes = classWriter.toByteArray();\n代码：\n\npackage chapter03.methodarea;\n\nimport net.bytebuddy.jar.asm.ClassWriter;\nimport net.bytebuddy.jar.asm.Opcodes;\n\nimport java.io.IOException;\n\n/**\n * 方法区的溢出测试\n */\npublic class Demo1 extends ClassLoader {\n    public static void main(String[] args) throws IOException {\n        System.in.read();\n        Demo1 demo1 = new Demo1();\n        int count = 0;\n        while (true) {\n            String name = \"Class\" + count;\n            ClassWriter classWriter = new ClassWriter(0);\n            classWriter.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, name, null\n                    , \"java/lang/Object\", null);\n            byte[] bytes = classWriter.toByteArray();\n            demo1.defineClass(name, bytes, 0, bytes.length);\n            System.out.println(++count);\n        }\n    }\n}\n实验发现，JDK7上运行大概十几万次，就出现了错误。\n\nimg\n\n在JDK8上运行百万次，程序都没有出现任何错误，但是内存会直线升高。这说明JDK7和JDK8在方法区的存放上，采用了不同的设计。\n\nJDK7将方法区存放在堆区域中的永久代空间，堆的大小由虚拟机参数-XX:MaxPermSize=值来控制。\nJDK8将方法区存放在元空间中，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统承受的上限，可以一直分配。可以使用-XX:MaxMetaspaceSize=值将元空间最大大小进行限制。\n在JDK8中将最大元空间内存设置为256m，再次测试\n\nimg\n\n这次就出现了MetaSpace溢出的错误：\n\nimg\n\n字符串常量池\n方法区中除了类的元信息、运行时常量池之外，还有一块区域叫字符串常量池(StringTable)。\n\n字符串常量池存储在代码中定义的常量字符串内容。比如“123” 这个123就会被放入字符串常量池。\n\n如下代码执行时，代码中包含abc字符串，就会被直接放入字符串常量池。在堆上创建String对象，并通过局部变量s1引用堆上的对象。\n\nimg\n\n接下来通过s2局部变量引用字符串常量池的abc。\n\nimg\n\n所以s1和s2指向的不是同一个对象，打印出false。\n\n字符串常量池和运行时常量池有什么关系？\n早期设计时，字符串常量池是属于运行时常量池的一部分，他们存储的位置也是一致的。后续做出了调整，将字符串常量池和运行时常量池做了拆分。\n\nimg\n\nStringTable的练习题1：\n/**\n * 字符串常量池案例\n */\npublic class Demo2 {\n    public static void main(String[] args) {\n        String a = \"1\";\n        String b = \"2\";\n        String c = \"12\";\n        String d = a + b;\n        System.out.println(c == d);\n    }\n}\n1、首先将1放入字符串常量池，通过局部变量a引用字符串常量池中的1字符串。\n\nimg\n\n2、同理处理b和c：\n\nimg\n\n3、将a和b指向的字符串进行连接，本质上就是使用StringBuilder进行连接，最后创建了一个新的字符串放入堆中。然后将局部变量d指向堆上的对象。\n\nimg\n\n4、所以c和d指向的不是同一个对象，打印出的结果就是false。\n\nStringTable的练习题2：\npackage chapter03.stringtable;\n\n/**\n * 字符串常量池案例\n */\npublic class Demo3 {\n    public static void main(String[] args) {\n        String a = \"1\";\n        String b = \"2\";\n        String c = \"12\";\n        String d = \"1\" + \"2\";\n        System.out.println(c == d);\n    }\n}\n编译之后的字节码指令如下：\n\nimg\n\n说明在编译阶段，已经将1和2进行连接，最终生成12的字符串常量池中的结果。所以返回结果就是true，c和d都指向字符串常量池中的对象。\n\n总结一下：\n\nimg\n\n神奇的intern\nString.intern()方法是可以手动将字符串放入字符串常量池中，分别在JDK6 JDK8下执行代码，JDK6 中结果是false false ，JDK8中是true false\n\npackage chapter03.stringtable;\n\n/**\n * intern案例\n */\npublic class Demo4 {\n    public static void main(String[] args) {\n        String s1 = new StringBuilder().append(\"think\").append(\"123\").toString();\n\n        System.out.println(s1.intern() == s1);\n//        System.out.println(s1.intern() == s1.intern());\n\n        String s2 = new StringBuilder().append(\"ja\").append(\"va\").toString();\n\n        System.out.println(s2.intern() == s2);\n    }\n}\n先来分析JDK6中，代码执行步骤如下：\n\n1、使用StringBuilder的将think和123拼接成think123，转换成字符串，在堆上创建一个字符串对象。局部变量s1指向堆上的对象。\n\nimg\n\n2、调用s1.intern方法，会在字符串常量池中创建think123的对象，最后将对象引用返回。所以s1.intern和s1指向的不是同一个对象。打印出false。\n\nimg\n\n3、同理，通过StringBuilder在堆上创建java字符串对象。这里注意字符串常量池中本来就有一个java字符串对象，这是java虚拟机自身使用的所以启动时就会创建出来。\n\nimg\n\n4、调用s2.intern发现字符串常量池中已经有java字符串对象了，就将引用返回。所以s2.intern指向的是字符串常量池中的对象，而s2指向的是堆中的对象。打印结果为false。\n\nimg\n\n接下来分析JDK7中，JDK7及之后版本中由于字符串常量池在堆上，所以intern () 方法会把第一次遇到的字符串的引用放入字符串常量池。\n\n代码执行步骤如下：\n\n1、执行第二句代码时，由于字符串常量池中没有think123的字符串，所以直接创建一个引用，指向堆中的think123对象。所以s1.intern和s1指向的都是堆上的对象，打印结果为true。\n\nimg\n\n2、s2.intern方法调用时，字符串常量池中已经有java字符串了，所以将引用返回。这样打印出来的结果就是false。\n\nimg\n\n后续JDK版本中，如果Java虚拟机不需要使用java字符串，那么字符串常量池中就不会存放java。打印结果有可能会出现两个true。\n\n面试题：静态变量存储在哪里呢？\nJDK6及之前的版本中，静态变量是存放在方法区中的，也就是永久代。\nJDK7及之后的版本中，静态变量是存放在堆中的Class对象中，脱离了永久代。具体源码可参考虚拟机源码：BytecodeInterpreter针对putstatic指令的处理。\n3.6 直接内存\n直接内存（Direct Memory）并不在《Java虚拟机规范》中存在，所以并不属于Java运行时的内存区域。\n\n在 JDK 1.4 中引入了 NIO 机制，使用了直接内存，主要为了解决以下两个问题:\n\n1、Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。\n\n2、IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。\n\n现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。\n\n使用堆创建对象的过程：\n\nimg\n\n使用直接内存创建对象的过程，不需要进行复制对象，数据直接存放在直接内存中：\n\nimg\n\n使用方法：\n要创建直接内存上的数据，可以使用ByteBuffer。\n\n语法： ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);\n\n注意事项： arthas的memory命令可以查看直接内存大小，属性名direct。\n\nimg\n\n代码：\n\npackage chapter03.direct;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 直接内存的使用和回收\n */\npublic class Demo1 {\n    public static int size = 1024 * 1024 * 100; //100mb\n    public static List<ByteBuffer> list = new ArrayList<ByteBuffer>();\n    public static int count = 0;\n\n    public static void main(String[] args) throws IOException, InterruptedException {\n        System.in.read();\n        while (true) {\n            //1.创建DirectByteBuffer对象并返回\n            //2.在DirectByteBuffer构造方法中，向操作系统申请直接内存空间\n            ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);\n            //directBuffer = null;\n\n            list.add(directBuffer);\n            System.out.println(++count);\n            Thread.sleep(5000);\n        }\n\n    }\n}\n运行之后，用arthas监控发现，每隔5秒直接内存会增长100M：\n\nimg\n\n如果将Thread.sleep(5000);注释掉，让直接内存快速大量分配。操作系统内存不足时就会报错：\n\nimg\n\n但是工作中服务器上有可能部署了其他应用，为了避免将内存耗尽，需要设置直接内存的最大值。如果需要手动调整直接内存的大小，可以使用XX:MaxDirectMemorySize=大小\n\n单位k或K表示千字节，m或M表示兆字节，g或G表示千兆字节。默认不设置该参数情况下，JVM 自动选择 最大分配的大小。\n\n以下示例以不同的单位说明如何将 直接内存大小设置为 1024 KB：\n\n-XX:MaxDirectMemorySize=1m\n-XX:MaxDirectMemorySize=1024k\n-XX:MaxDirectMemorySize=1048576\n在Idea中设置直接内存最大值为1g：\n\nimg\n\n直接循环11次之后，超过最大值就会报错：\n\nimg\n\n3.8 方法区和堆区的区别\n方法区（Method Area）：\n方法区是存储类的元数据信息、静态变量、常量池、方法字节码等数据的内存区域。\n主要包含以下内容：\n类的元数据信息：包括类的结构信息、方法和字段的描述符、访问权限、继承关系等。\n静态变量：被声明为 static 关键字的变量，它们在类加载时被初始化，并且存储在方法区中。\n常量池：用于存放编译时生成的各种字面量和符号引用，例如字符串常量、类和接口的全限定名、字段和方法的符号引用等。\n方法字节码：类中的方法代码被编译成字节码后存储在方法区中。\n方法区在 JVM 启动时被创建，并且在 JVM 运行期间始终存在，直到 JVM 进程结束才会被释放。\n堆区（Java Heap）：\n堆区是存储对象实例和数组对象的内存区域，它是 Java 程序中创建的对象的主要存放地点。\n主要包含以下内容：\n对象实例：通过 new 关键字创建的对象实例都存储在堆区中。\n数组对象：Java 中的数组对象也存储在堆区中，无论是基本数据类型的数组还是对象数组。\n堆区在 JVM 启动时被创建，并且在 JVM 运行期间动态地分配和释放内存，由垃圾回收器负责管理。\n堆区的内存分配由 Java 虚拟机根据应用程序的需求动态调整，当堆区内存不足时会触发垃圾回收，释放无用对象来腾出空间。\n总的来说，方法区主要存储类相关的信息和静态变量，而堆区主要存储对象实例和数组对象。两者在 Java 虚拟机中扮演着不同的角色，但都是 Java 程序执行过程中重要的内存区域。\n\n3.9 不同版本的运行时数据区\njdk6、jdk7、jdk8区别\nimg\n\nJDK8之后\n静态变量移到元空间\n\n字符串常量池仍在堆区\n\n4、垃圾回收\n在C/C++这类没有自动垃圾回收机制的语言中，一个对象如果不再使用，需要手动释放，否则就会出现内存泄漏。\n\n内存泄漏指的是不再使用的对象在系统中未被回收，内存泄漏的积累可能会导致内存溢出。\n\n在这段代码中，通过死循环不停创建Test类的对象，每一轮循环结束之后，这次创建的对象就不再使用了。但是没有手动调用删除对象的方法，此时对象就会出现内存泄漏。\n\nimg\n\n这段代码中，手动调用delete删除对象，就不会出现内存泄漏。\n\nimg\n\n我们称这种释放对象的过程为垃圾回收，而需要程序员编写代码进行回收的方式为手动回收。手动回收的方式相对来说回收比较及时，删除代码执行之后对象就被回收了，可以快速释放内存。缺点是对程序员要求比较高，很容易出现创建完对象之后，程序员忘记释放对象。\n\nJava中为了简化对象的释放，引入了自动的垃圾回收（Garbage Collection简称GC）机制。通过垃圾回收器来对不再使用的对象完成自动的回收，垃圾回收器主要负责对堆上的内存进行回收。其他很多现代语言比如C#、Python、Go都拥有自己的垃圾回收器。\n\n垃圾回收器如果发现某个对象不再使用，就可以回收该对象。\n\nimg\n\nimg\n\n自动垃圾回收，自动根据对象是否使用由虚拟机来回收对象\n优点：降低程序员实现难度、降低对象回收bug的可能性\n缺点：程序员无法控制内存回收的及时性\n手动垃圾回收，由程序员编程实现对象的删除\n优点：回收及时性高，由程序员把控回收的时机\n缺点：编写不当容易出现悬空指针、重复释放、内存泄漏等问题\n那么垃圾回收器需要负责对哪些部分的内存进行回收呢？\n\n首先是线程不共享的部分，都是伴随着线程的创建而创建，线程的销毁而销毁。而方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。所以这一部分不需要垃圾回收器负责回收。\n\nimg\n\n4.1 方法区的回收\n方法区中能回收的内容主要就是不再使用的类。\n\n判定一个类可以被卸载。需要同时满足下面三个条件：\n\n1、此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。\n\n这段代码中就将局部变量对堆上实例对象的引用去除了，所以对象就可以被回收。\n\nimg\n\n2、加载该类的类加载器已经被回收。\n\n这段代码让局部变量对类加载器的引用去除，类加载器就可以回收。\n\nimg\n\n3、该类对应的 java.lang.Class 对象没有在任何地方被引用。\n\nimg\n\n代码:\n\npackage chapter04.gc;\n\nimport java.net.URL;\nimport java.net.URLClassLoader;\nimport java.util.ArrayList;\n\n/**\n * 类的卸载\n */\npublic class ClassUnload {\n    public static void main(String[] args) throws InterruptedException {\n\n        try {\n            ArrayList<Class<?>> classes = new ArrayList<>();\n            ArrayList<URLClassLoader> loaders = new ArrayList<>();\n            ArrayList<Object> objs = new ArrayList<>();\n            while (true) {\n\n                URLClassLoader loader = new URLClassLoader(\n                        new URL[]{new URL(\"file:D:\\\\lib\\\\\")});\n                Class<?> clazz = loader.loadClass(\"com.itheima.my.A\");\n                Object o = clazz.newInstance();\n\n\n//                objs.add(o);\n//                classes.add(clazz);\n//                 loaders.add(loader);\n\n                 System.gc();\n\n            }\n\n\n        } catch (Exception e) {\n\n            e.printStackTrace();\n        }\n    }\n}\n添加这两个虚拟机参数进行测试：\n\n-XX:+TraceClassLoading -XX:+TraceClassUnloading\nimg\n\n如果注释掉代码中三句add调用，就可以同时满足3个条件。但是需要手动调用System.gc()方法，让垃圾回收器进行回收。\n\n如果需要手动触发垃圾回收，可以调用System.gc()方法。\n\n语法： System.gc()\n\n注意事项：\n\n调用System.gc()方法并不一定会立即回收垃圾，仅仅是向Java虚拟机发送一个垃圾回收的请求，具体是否需要执行垃圾回收Java虚拟机会自行判断。\n\n执行之后，日志中就会打印出类卸载的内容：\n\nimg\n\n那么类卸载主要用在什么场景下呢？\n\n开发中此类场景一般很少出现，主要在如 OSGi、JSP 的热部署等应用场景中。\n\n每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。\n\n4.2 如何判断对象可以回收\n垃圾回收器要回收对象的第一步就是判断哪些对象可以回收。Java中的对象是否能被回收，是根据对象是否被引用来决定的。如果对象被引用了，说明该对象还在使用，不允许被回收。\n\n比如下面代码的内存结构图：\n\n第一行代码执行之后，堆上创建了Demo类的实例对象，同时栈上保存局部变量引用堆上的对象。\n\nimg\n\n第二行代码执行之后，局部变量对堆上的对象引用去掉，那么堆上的对象就可以被回收了。\n\nimg\n\n一个更复杂的案例：\n\nimg\n\n这个案例中，如果要让对象a和b回收，必须将局部变量到堆上的引用去除。\n\nimg\n\n那么问题来了，A和B互相之间的引用需要去除吗？答案是不需要，因为局部变量都没引用这两个对象了，在代码中已经无法访问这两个对象，即便他们之间互相有引用关系，也不影响对象的回收。\n\n判断对象是否可以回收，主要有两种方式：引用计数法和可达性分析法。\n\n引用计数法\n引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。\n\n比如下图中，对象A的计数器初始为0，局部变量a1对它引用之后，计数器加1就变成了1。同样A对B产生了引用，B的计数器也是1。\n\nimg\n\n引用计数法的优点是实现简单，C++中的智能指针就采用了引用计数法，但是它也存在缺点，主要有两点：\n\n1.每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响\n\n2.存在循环引用问题，所谓循环引用就是当A引用B，B同时引用A时会出现对象无法回收的问题。\n\n这张图上，由于A和B之间存在互相引用，所以计数器都为1，两个对象都不能被回收。但是由于没有局部变量对这两个代码产生引用，代码中已经无法访问到这两个对象，理应可以被回收。\n\nimg\n\n我们来做一个实验，验证下Java中循环引用不会导致内存泄漏，因为Java虚拟机根本没有使用引用计数法。首先我们要学会去看一个对象有没有被回收，可以通过垃圾回收日志来查看。\n\n如果想要查看垃圾回收的信息，可以使用-verbose:gc参数。\n\n语法： -verbose:gc\n\nimg\n\n加上这个参数之后执行代码，发现对象确实被回收了：\n\nimg\n\n通过不同的死循环创建对象，内存并没有上升，一直维持在1000K,说明每轮循环创建的两个对象在垃圾回收之后都被回收了。\n\n可达性分析法\nJava使用的是可达性分析算法来判断对象是否可以被回收。可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象，对象与对象之间存在引用关系。\n\n下图中A到B再到C和D，形成了一个引用链，可达性分析算法指的是如果从某个到GC Root对象是可达的，对象就不可被回收。\n\nimg\n\nGC Root对象\n哪些对象被称之为GC Root对象呢？\n\n线程Thread对象，引用线程栈帧中的方法参数、局部变量等。\n系统类加载器加载的java.lang.Class对象，引用类中的静态变量。\nimg\n\n监视器对象，用来保存同步锁synchronized关键字持有的对象。\nimg\n\n本地方法调用时使用的全局对象。\n工具\n通过arthas和eclipse Memory Analyzer (MAT) 工具可以查看GC Root，MAT工具是eclipse推出的Java堆内存检测工具。具体操作步骤如下：\n\n1、使用arthas的heapdump命令将堆内存快照保存到本地磁盘中。\n\n2、使用MAT工具打开堆内存快照文件。\n\n3、选择GC Roots功能查看所有的GC Root。\n\nimg\n\n步骤详解：\n1、代码如下：\n\npackage com.itheima.jvm.chapter04;\n\nimport java.io.IOException;\n\npublic class ReferenceCounting {\n    public static A a2 = null;\n    public static void main(String[] args) throws IOException {\n//        while (true){\n            A a1 = new A();\n            B b1 = new B();\n            a1.b = b1;\n            b1.a = a1;\n            a2 = a1;\n            System.in.read();\n//            a1 = null;\n//            b1 = null;\n//        }\n\n    }\n}\n\nclass A {\n    B b;\n//    byte[] t = new byte[1024 * 1024 * 10];\n}\n\nclass B {\n    A a;\n//    byte[] t = new byte[1024 * 1024 * 10];\n}\n2、使用arthas连接到程序，输入如下命令:\n\nheapdump 目录/test2.hprof\nimg\n\n这样就生成了一个堆内存快照（后面介绍，简单来说就是包含了所有堆中的对象信息）。\n\n3、打开资料中提供的MAT工具，如果出现如下错误，请将环境变量中的JDK版本升级到17以上。\n\nimg\n\n4、选择菜单中的打开堆内存快照功能，并选择刚才生成的文件。\n\nimg\n\n5、选择内存泄漏检测报告，并确定。\n\nimg\n\n6、通过菜单找到GC Roots。\n\nimg\n\n7、MAT对4类GC Root对象做了分类。\n\nimg\n\n8、找到静态变量。\n\nimg\n\n9、找到局部变量\n\nimg\n\n4.3 常见的引用对象\n可达性算法中描述的对象引用，一般指的是强引用，即是GCRoot对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收。除了强引用之外，Java中还设计了几种其他引用方式：\n\n软引用\n弱引用\n虚引用\n终结器引用\n强引用\n软引用\n软引用相对于强引用是一种比较弱的引用关系，如果一个对象只有软引用关联到它，当程序内存不足时，就会将软引用中的数据进行回收。在JDK 1.2版之后提供了SoftReference类来实现软引用，软引用常用于缓存中。\n\n如下图中，对象A被GC Root对象强引用了，同时我们创建了一个软引用SoftReference对象（它本身也是一个对象），软引用对象中引用了对象A。\n\nimg\n\n接下来强引用被去掉之后，对象A暂时还是处于不可回收状态，因为有软引用存在并且内存还够用。\n\nimg\n\n如果内存出现不够用的情况，对象A就处于可回收状态，可以被垃圾回收器回收。\n\nimg\n\n这样做有什么好处？如果对象A是一个缓存，平时会保存在内存中，如果想访问数据可以快速访问。但是如果内存不够用了，我们就可以将这部分缓存清理掉释放内存。即便缓存没了，也可以从数据库等地方获取数据，不会影响到业务正常运行，这样可以减少内存溢出产生的可能性。\n\n特别注意：\n\n软引用对象本身，也需要被强引用，否则软引用对象也会被回收掉。\n\nimg\n\n软引用的使用方法\n软引用的执行过程如下：\n\n1.将对象使用软引用包装起来，new SoftReference<对象类型>(对象)。\n\n2.内存不足时，虚拟机尝试进行垃圾回收。\n\n3.如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象。\n\n4.如果依然内存不足，抛出OutOfMemory异常。\n\n代码：\n\n/**\n * 软引用案例2 - 基本使用\n */\npublic class SoftReferenceDemo2 {\n    public static void main(String[] args) throws IOException {\n\n        byte[] bytes = new byte[1024 * 1024 * 100];\n        SoftReference<byte[]> softReference = new SoftReference<byte[]>(bytes);\n        bytes = null;\n        System.out.println(softReference.get());\n\n        byte[] bytes2 = new byte[1024 * 1024 * 100];\n        System.out.println(softReference.get());\n//\n//        byte[] bytes3 = new byte[1024 * 1024 * 100];\n//        softReference = null;\n//        System.gc();\n//\n//        System.in.read();\n    }\n}\n添加虚拟机参数，限制最大堆内存大小为200m：\n\nimg\n\n执行后发现，第二个100m对象创建之后需，软引用中包含的对象已经被回收了。\n\nimg\n\n软引用对象本身怎么回收呢？\n如果软引用对象里边包含的数据已经被回收了，那么软引用对象本身其实也可以被回收了。\n\nSoftReference提供了一套队列机制：\n\n1、软引用创建时，通过构造器传入引用队列\n\nimg\n\n2、在软引用中包含的对象被回收时，该软引用对象会被放入引用队列\n\nimg\n\n3、通过代码遍历引用队列，将SoftReference的强引用删除\n\n代码\n\n/**\n * 软引用案例3 - 引用队列使用\n */\npublic class SoftReferenceDemo3 {\n\n    public static void main(String[] args) throws IOException {\n\n        ArrayList<SoftReference> softReferences = new ArrayList<>();\n        ReferenceQueue<byte[]> queues = new ReferenceQueue<byte[]>();\n        for (int i = 0; i < 10; i++) {\n            byte[] bytes = new byte[1024 * 1024 * 100];\n            SoftReference studentRef = new SoftReference<byte[]>(bytes,queues);\n            softReferences.add(studentRef);\n        }\n\n        SoftReference<byte[]> ref = null;\n        int count = 0;\n        while ((ref = (SoftReference<byte[]>) queues.poll()) != null) {\n            count++;\n        }\n        System.out.println(count);\n\n    }\n}\n最终展示的结果是：\n\nimg\n\n这9个软引用对象中包含的数据已经被回收掉，所以可以手动从ArrayList中去掉，这样就可以释放这9个对象。\n\n软引用的缓存案例\n使用软引用实现学生信息的缓存，能支持内存不足时清理缓存。\n\nimg\n\n代码：\n\npackage chapter04.soft;\n\nimport java.lang.ref.ReferenceQueue;\nimport java.lang.ref.SoftReference;\nimport java.util.HashMap;\nimport java.util.Map;\n/**\n * 软引用案例4 - 学生信息的缓存\n */\npublic class StudentCache {\n\n    private static StudentCache cache = new StudentCache();\n\n    public static void main(String[] args) {\n        for (int i = 0; ; i++) {\n            StudentCache.getInstance().cacheStudent(new Student(i, String.valueOf(i)));\n        }\n    }\n\n    private Map<Integer, StudentRef> StudentRefs;// 用于Cache内容的存储\n    private ReferenceQueue<Student> q;// 垃圾Reference的队列\n\n    // 继承SoftReference，使得每一个实例都具有可识别的标识。\n    // 并且该标识与其在HashMap内的key相同。\n    private class StudentRef extends SoftReference<Student> {\n        private Integer _key = null;\n\n        public StudentRef(Student em, ReferenceQueue<Student> q) {\n            super(em, q);\n            _key = em.getId();\n        }\n    }\n\n    // 构建一个缓存器实例\n    private StudentCache() {\n        StudentRefs = new HashMap<Integer, StudentRef>();\n        q = new ReferenceQueue<Student>();\n    }\n\n    // 取得缓存器实例\n    public static StudentCache getInstance() {\n        return cache;\n    }\n\n    // 以软引用的方式对一个Student对象的实例进行引用并保存该引用\n    private void cacheStudent(Student em) {\n        cleanCache();// 清除垃圾引用\n        StudentRef ref = new StudentRef(em, q);\n        StudentRefs.put(em.getId(), ref);\n        System.out.println(StudentRefs.size());\n    }\n\n    // 依据所指定的ID号，重新获取相应Student对象的实例\n    public Student getStudent(Integer id) {\n        Student em = null;\n// 缓存中是否有该Student实例的软引用，如果有，从软引用中取得。\n        if (StudentRefs.containsKey(id)) {\n            StudentRef ref = StudentRefs.get(id);\n            em = ref.get();\n        }\n// 如果没有软引用，或者从软引用中得到的实例是null，重新构建一个实例，\n// 并保存对这个新建实例的软引用\n        if (em == null) {\n            em = new Student(id, String.valueOf(id));\n            System.out.println(\"Retrieve From StudentInfoCenter. ID=\" + id);\n            this.cacheStudent(em);\n        }\n        return em;\n    }\n\n    // 清除那些所软引用的Student对象已经被回收的StudentRef对象\n    private void cleanCache() {\n        StudentRef ref = null;\n        while ((ref = (StudentRef) q.poll()) != null) {\n            StudentRefs.remove(ref._key);\n        }\n    }\n\n//    // 清除Cache内的全部内容\n//    public void clearCache() {\n//        cleanCache();\n//        StudentRefs.clear();\n//        //System.gc();\n//        //System.runFinalization();\n//    }\n}\n\nclass Student {\n    int id;\n    String name;\n\n    public Student(int id, String name) {\n        this.id = id;\n        this.name = name;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public void setId(int id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n}\n弱引用\n弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时，不管内存够不够都会直接被回收。在JDK 1.2版之后提供了WeakReference类来实现弱引用，弱引用主要在ThreadLocal中使用。\n\n弱引用对象本身也可以使用引用队列进行回收。\n\npackage chapter04.weak;\n\nimport java.io.IOException;\nimport java.lang.ref.WeakReference;\n\n/**\n * 弱引用案例 - 基本使用\n */\npublic class WeakReferenceDemo2 {\n    public static void main(String[] args) throws IOException {\n\n        byte[] bytes = new byte[1024 * 1024 * 100];\n        WeakReference<byte[]> weakReference = new WeakReference<byte[]>(bytes);\n        bytes = null;\n        System.out.println(weakReference.get());\n\n        System.gc();\n\n        System.out.println(weakReference.get());\n    }\n}\n执行之后发现gc执行之后，对象已经被回收了。\n\nimg\n\n虚引用和终结器引用\n这两种引用在常规开发中是不会使用的。\n\n虚引用也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是当对象被垃圾回收器回收时可以接收到对应的通知。Java中使用PhantomReference实现了虚引用，直接内存中为了及时知道直接内存对象不再使用，从而回收内存，使用了虚引用来实现。\n\n终结器引用指的是在对象需要被回收时，终结器引用会关联对象并放置在Finalizer类中的引用队列中，在稍后由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法，在对象第二次被回收时，该对象才真正的被回收。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，但是不建议这样做。\n\npackage chapter04.finalreference;\n\n/**\n * 终结器引用案例\n */\npublic class FinalizeReferenceDemo {\n    public static FinalizeReferenceDemo reference = null;\n\n    public void alive() {\n        System.out.println(\"当前对象还存活\");\n    }\n\n    @Override\n    protected void finalize() throws Throwable {\n        try{\n            System.out.println(\"finalize()执行了...\");\n            //设置强引用自救\n            reference = this;\n        }finally {\n            super.finalize();\n        }\n    }\n\n    public static void main(String[] args) throws Throwable {\n        reference = new FinalizeReferenceDemo();\n       test();\n       test();\n    }\n\n    private static void test() throws InterruptedException {\n        reference = null;\n        //回收对象\n        System.gc();\n        //执行finalize方法的优先级比较低，休眠500ms等待一下\n        Thread.sleep(500);\n        if (reference != null) {\n            reference.alive();\n        } else {\n            System.out.println(\"对象已被回收\");\n        }\n    }\n}\n4.4 垃圾回收算法\nJava是如何实现垃圾回收的呢？简单来说，垃圾回收要做的有两件事：\n\n1、找到内存中存活的对象\n\n2、释放不再存活对象的内存，使得程序能再次利用这部分空间\n\nimg\n\n垃圾回收算法的历史和分类\n1960年John McCarthy发布了第一个GC算法：标记-清除算法。\n\n1963年Marvin L. Minsky 发布了复制算法。\n\n本质上后续所有的垃圾回收算法，都是在上述两种算法的基础上优化而来。\n\nimg\n\n垃圾回收算法的评价标准\nJava垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要停止所有的用户线程。这个过程被称之为Stop The World简称STW，如果STW时间过长则会影响用户的使用。\n\n如下图，用户代码执行和垃圾回收执行让用户线程停止执行（STW）是交替执行的。\n\nimg\n\n所以判断GC算法是否优秀，可以从三个方面来考虑：\n\n1.吞吐量\n吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 /（执行用户代码时间 + GC时间）。吞吐量数值越高，垃圾回收的效率就越高。\n\nimg\n\n2.最大暂停时间\n最大暂停时间指的是所有在垃圾回收过程中的STW时间最大值。比如如下的图中，黄色部分的STW就是最大暂停时间，显而易见上面的图比下面的图拥有更少的最大暂停时间。最大暂停时间越短，用户使用系统时受到的影响就越短。\n\nimg\n\n3.堆使用效率\n不同垃圾回收算法，对堆内存的使用方式是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法。\n\n上述三种评价标准：堆使用效率、吞吐量，以及最大暂停时间不可兼得。\n\n一般来说，堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就会降低吞吐量。\n\nimg\n\n没有一个垃圾回收算法能兼顾上述三点评价标准，所以不同的垃圾回收算法它的侧重点是不同的，适用于不同的应用场景。\n\n标记清除算法\n标记清除算法的核心思想分为两个阶段：\n\n1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。\n\n2.清除阶段，从内存中删除没有被标记也就是非存活对象。\n\n第一个阶段，从GC Root对象开始扫描，将对象A、B、C在引用链上的对象标记出来：\n\nimg\n\n第二个阶段，将没有标记的对象清理掉，所以对象D就被清理掉了。\n\nimg\n\n优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。\n\n缺点：1.碎片化问题\n\n由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。\n\n如下图，红色部分已经被清理掉了，总共回收了9个字节，但是每个都是一个小碎片，无法为5个字节的对象分配空间。\n\nimg\n\n标记清除算法的缺点：\n\n2.分配速度慢。由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间。 我们需要用一个链表来维护，哪些空间可以分配对象，很有可能需要遍历这个链表到最后，才能发现这块空间足够我们去创建一个对象。如下图，遍历到最后才发现有足够的空间分配3个字节的对象了。如果链表很长，遍历也会花费较长的时间。\n\nimg\n\n复制算法\n复制算法的核心思想是：\n\n1.准备两块空间From空间和To空间，每次在对象分配阶段，只能使用其中一块空间（From空间）。\n\n对象A首先分配在From空间：\n\nimg\n\n2.在垃圾回收GC阶段，将From中存活对象复制到To空间。\n\n在垃圾回收阶段，如果对象A存活，就将其复制到To空间。然后将From空间直接清空。\n\nimg\n\n3.将两块空间的From和To名字互换。\n\n接下来将两块空间的名称互换，下次依然在From空间上创建对象。\n\nimg\n\n完整的复制算法的例子：\n\n1.将堆内存分割成两块From空间 To空间，对象分配阶段，创建对象。\n\nimg\n\n2.GC阶段开始，将GC Root搬运到To空间\n\nimg\n\n3.将GC Root关联的对象，搬运到To空间\n\nimg\n\n4.清理From空间，并把名称互换\n\nimg\n\n优点：\n\n吞吐量高，复制算法只需要遍历一次存活对象复制到To空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动\n不会发生碎片化，复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。\n缺点：\n\n内存使用效率低，每次只能让一半的内存空间来为创建对象使用。\n\n标记整理算法\n标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。\n\n核心思想分为两个阶段：\n\n1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。\n\n2.整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。\n\nimg\n\n优点：\n\n内存使用效率高，整个堆内存都可以使用，不会像复制算法只能使用半个堆内存\n不会发生碎片化，在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间\n缺点：\n\n整理阶段的效率不高，整理算法有很多种，比如Lisp2整理算法需要对整个堆中的对象搜索3次，整体性能不佳。可以通过Two-Finger、表格算法、ImmixGC等高效的整理算法优化此阶段的性能。\n\n分代垃圾回收算法\n现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法组合进行使用，其中应用最广的就是分代垃圾回收算法(Generational GC)。\n\n分代垃圾回收将整个内存区域划分为年轻代和老年代：\n\nimg\n\n我们通过arthas来验证下内存划分的情况：\n\n在JDK8中，添加-XX:+UseSerialGC参数使用分代回收的垃圾回收器，运行程序。\n\n在arthas中使用memory命令查看内存，显示出三个区域的内存情况。\n\nimg\n\nEden + survivor 这两块区域组成了年轻代。\n\ntenured_gen指的是晋升区域，其实就是老年代。\n\n另外还可以选择的虚拟机参数如下\n\n参数名	参数含义	示例\n-Xms	设置堆的最小和初始大小，必须是1024倍数且大于1MB	比如初始大小6MB的写法： -Xms6291456 -Xms6144k -Xms6m\n-Xmx	设置最大堆的大小，必须是1024倍数且大于2MB	比如最大堆80 MB的写法： -Xmx83886080 -Xmx81920k -Xmx80m\n-Xmn	新生代的大小	新生代256 MB的写法： -Xmn256m -Xmn262144k -Xmn268435456\n-XX:SurvivorRatio	伊甸园区和幸存区的比例，默认为8 新生代1g内存，伊甸园区800MB,S0和S1各100MB	比例调整为4的写法：-XX:SurvivorRatio=4\n-XX:+PrintGCDetailsverbose:gc	打印GC日志	无\n代码：\n\npackage chapter04.gc;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 垃圾回收器案例1\n */\n//-XX:+UseSerialGC  -Xms60m -Xmn20m -Xmx60m -XX:SurvivorRatio=3  -XX:+PrintGCDetails\npublic class GcDemo0 {\n\n    public static void main(String[] args) throws IOException {\n        List<Object> list = new ArrayList<>();\n        int count = 0;\n        while (true){\n            System.in.read();\n            System.out.println(++count);\n            //每次添加1m的数据\n            list.add(new byte[1024 * 1024 * 1]);\n        }\n    }\n}\n使用arthas的memory展示出来的效果：\n\nimg\n\nheap展示的是可用堆，survivor区每次只有一块能使用，所以60 - 4 = 56m。\n\n1、分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。\n\nimg\n\n2、随着对象在Eden区越来越多，如果Eden区满，新创建的对象已经无法放入，就会触发年轻代的GC，称为Minor GC或者Young GC。\n\nMinor GC会把需要eden中和From需要回收的对象回收，把没有回收的对象放入To区。\n\nimg\n\n3、接下来，S0会变成To区，S1变成From区。当eden区满时再往里放入对象，依然会发生Minor GC。\n\nimg\n\n此时会回收eden区和S1(from)中的对象，并把eden和from区中剩余的对象放入S0。\n\n注意：每次Minor GC中都会为对象记录他的年龄，初始值为0，每次GC完加1。\n\nimg\n\n4、如果Minor GC后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。\n\nimg\n\nimg\n\n当老年代中空间不足，无法放入新的对象时，先尝试minor gc如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收。\n\n如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常。\n\nimg\n\n下图中的程序为什么会出现OutOfMemory？\n\nimg\n\n从上图可以看到，Full GC无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常。\n\n继续使用这段代码测试：\n\n//-XX:+UseSerialGC  -Xms60m -Xmn20m -Xmx60m -XX:SurvivorRatio=3  -XX:+PrintGCDetails\npublic class GcDemo0 {\n\n    public static void main(String[] args) throws IOException {\n        List<Object> list = new ArrayList<>();\n        int count = 0;\n        while (true){\n            System.in.read();\n            System.out.println(++count);\n            //每次添加1m的数据\n            list.add(new byte[1024 * 1024 * 1]);\n        }\n    }\n}\n结果如下：\n\nimg\n\n老年代已经满了，而且垃圾回收无法回收掉对象，如果还想往里面放就发生了OutOfMemoryError。\n\n4.5 垃圾回收器\n为什么分代GC算法要把堆分成年轻代和老年代？首先我们要知道堆内存中对象的特性：\n\n系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。\n老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。\n在虚拟机的默认设置中，新生代大小要远小于老年代的大小。\n分代GC算法将堆分成年轻代和老年代主要原因有：\n\n1、可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。\n\n2、新生代和老年代使用不同的垃圾回收算法，新生代一般选择复制算法，老年代可以选择标记-清除和标记-整理算法，由程序员来选择灵活度较高。\n\n3、分代的设计中允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收(full gc),STW时间就会减少。\n\n垃圾回收器是垃圾回收算法的具体实现。\n\n由于垃圾回收器分为年轻代和老年代，除了G1之外其他垃圾回收器必须成对组合进行使用。\n\n具体的关系图如下：\n\nimg\n\n年轻代-Serial垃圾回收器\nSerial是是一种单线程串行回收年轻代的垃圾回收器。\n\nimg\n\n回收年代和算法：\n\n年轻代\n\n复制算法\n\n优点\n\n单CPU处理器下吞吐量非常出色\n\n缺点\n\n多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待\n\n适用场景\n\nJava编写的客户端程序或者硬件配置有限的场景\n\n老年代-SerialOld垃圾回收器\nSerialOld是Serial垃圾回收器的老年代版本，采用单线程串行回收\n\n-XX:+UseSerialGC 新生代、老年代都使用串行回收器。\n\nimg\n\n回收年代和算法：\n\n老年代\n\n标记-整理算法\n\n优点\n\n单CPU处理器下吞吐量非常出色\n\n缺点\n\n多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待\n\n适用场景\n\n与Serial垃圾回收器搭配使用，或者在CMS特殊情况下使用\n\n年轻代-ParNew垃圾回收器\nParNew垃圾回收器本质上是对Serial在多CPU下的优化，使用多线程进行垃圾回收\n\n-XX:+UseParNewGC 新生代使用ParNew回收器， 老年代使用串行回收器\n\nimg\n\n回收年代和算法：\n\n年轻代\n\n复制算法\n\n优点\n\n多CPU处理器下停顿时间较短\n\n缺点\n\n吞吐量和停顿时间不如G1，所以在JDK9之后不建议使用\n\n适用场景\n\nJDK8及之前的版本中，与CMS老年代垃圾回收器搭配使用\n\n老年代- CMS(Concurrent Mark Sweep)垃圾回收器\nCMS垃圾回收器关注的是系统的暂停时间，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少了用户线程的等待时间。\n\n参数：XX:+UseConcMarkSweepGC\n\nimg\n\n回收年代和算法：\n\n老年代\n\n标记清除算法\n\n优点\n\n系统由于垃圾回收出现的停顿时间较短，用户体验好\n\n缺点\n\n1、内存碎片问题\n\n2、退化问题\n\n3、浮动垃圾问题\n\n适用场景\n\n大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等\n\nCMS执行步骤：\n\n1.初始标记，用极短的时间标记出GC Roots能直接关联到的对象。\n\n2.并发标记, 标记所有的对象，用户线程不需要暂停。\n\n3.重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。\n\n4.并发清理，清理死亡的对象，用户线程不需要暂停。\n\n缺点：\n\n1、CMS使用了标记-清除算法，在垃圾收集结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。这样会导致用户线程暂停，可以使用-XX:CMSFullGCsBeforeCompaction=N 参数（默认0）调整N次Full GC之后再整理。\n\n2.、无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。\n\n3、如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代。\n\n并发线程数：\n\n在CMS中并发阶段运行时的线程数可以通过-XX:ConcGCThreads参数设置，默认值为0，由系统计算得出。\n\n计算公式为(-XX:ParallelGCThreads定义的线程数 + 3) / 4， ParallelGCThreads是STW停顿之后的并行线程数\n\nParallelGCThreads是由处理器核数决定的：\n\n1、当cpu核数小于8时，ParallelGCThreads = CPU核数\n\n2、否则 ParallelGCThreads = 8 + (CPU核数 – 8 )*5/8\n\n我的电脑上逻辑处理器有12个，所以ParallelGCThreads = 8 + （12 - 8）* 5/8 = 10，ConcGCThreads = (-XX:ParallelGCThreads定义的线程数 + 3) / 4 = （10 + 3） / 4 = 3\n\nimg\n\n最终可以得到这张图：\n\nimg\n\n并发标记和并发清理阶段，会使用3个线程并行处理。重新标记阶段会使用10个线程处理。\n\n由于CPU的核心数有限，并发阶段会影响用户线程执行的性能。\n\nimg\n\n年轻代-Parallel Scavenge垃圾回收器\nParallel Scavenge是JDK8默认的年轻代垃圾回收器，多线程并行回收，关注的是系统的吞吐量。具备自动调整堆内存大小的特点。\n\nimg\n\n回收年代和算法：\n\n年轻代\n\n复制算法\n\n优点\n\n吞吐量高，而且手动可控。为了提高吞吐量，虚拟机会动态调整堆的参数\n\n缺点\n\n不能保证单次的停顿时间\n\n适用场景\n\n后台任务，不需要与用户交互，并且容易产生大量的对象。比如：大数据的处理，大文件导出\n\n常用参数：\n\nParallel Scavenge允许手动设置最大暂停时间和吞吐量。Oracle官方建议在使用这个组合时，不要设置堆内存的最大值，垃圾回收器会根据最大暂停时间和吞吐量自动调整内存大小。\n\n最大暂停时间，-XX:MaxGCPauseMillis=n 设置每次垃圾回收时的最大停顿毫秒数\n吞吐量，-XX:GCTimeRatio=n 设置吞吐量为n（用户线程执行时间 = n/n + 1）\n自动调整内存大小, -XX:+UseAdaptiveSizePolicy设置可以让垃圾回收器根据吞吐量和最大停顿的毫秒数自动调整内存大小\n老年代-Parallel Old垃圾回收器\nParallel Old是为Parallel Scavenge收集器设计的老年代版本，利用多线程并发收集。\n\n参数： -XX:+UseParallelGC 或\n\n​ -XX:+UseParallelOldGC可以使用Parallel Scavenge + Parallel Old这种组合。\n\nimg\n\n回收年代和算法：\n\n老年代\n\n标记-整理算法\n\n优点\n\n并发收集，在多核CPU下效率较高\n\n缺点\n\n暂停时间会比较长\n\n适用场景\n\n与Parallel Scavenge配套使用\n\nG1垃圾回收器\nJDK9之后默认的垃圾回收器是G1（Garbage First）垃圾回收器。Parallel Scavenge关注吞吐量，允许用户设置最大暂停时间 ，但是会减少年轻代可用空间的大小。CMS关注暂停时间，但是吞吐量方面会下降。\n\n而G1设计目标就是将上述两种垃圾回收器的优点融合：\n\n1.支持巨大的堆空间回收，并有较高的吞吐量。\n\n2.支持多CPU并行垃圾回收。\n\n3.允许用户设置最大暂停时间。\n\nJDK9之后强烈建议使用G1垃圾回收器。\n\nG1出现之前的垃圾回收器，年轻代和老年代一般是连续的，如下图：\n\nimg\n\nG1的整个堆会被划分成多个大小相等的区域，称之为区Region，区域不要求是连续的。分为Eden、Survivor、Old区。Region的大小通过堆空间大小/2048计算得到，也可以通过参数-XX:G1HeapRegionSize=32m指定(其中32m指定region大小为32M)，Region size必须是2的指数幂，取值范围从1M到32M。\n\nimg\n\nG1垃圾回收有两种方式：\n\n1、年轻代回收（Young GC）\n\n2、混合回收（Mixed GC）\n\n年轻代回收\n年轻代回收（Young GC），回收Eden区和Survivor区中不用的对象。会导致STW，G1中可以通过参数\n\n-XX:MaxGCPauseMillis=n（默认200） 设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地保证暂停时间。\n\n1、新创建的对象会存放在Eden区。当G1判断年轻代区不足（max默认60%），无法分配对象时需要回收时会执行Young GC。\n\nimg\n\n2、标记出Eden和Survivor区域中的存活对象，\n\n3、根据配置的最大暂停时间选择某些区域将存活对象复制到一个新的Survivor区中（年龄+1），清空这些区域。\n\nimg\n\nimg\n\nG1在进行Young GC的过程中会去记录每次垃圾回收时每个Eden区和Survivor区的平均耗时，以作为下次回收时的参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个Region区域了。\n\n比如 -XX:MaxGCPauseMillis=n（默认200），每个Region回收耗时40ms，那么这次回收最多只能回收4个Region。\n\n4、后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。\n\nimg\n\nimg\n\n5、当某个存活对象的年龄到达阈值（默认15），将被放入老年代。\n\nimg\n\n6、部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为Humongous区。比如堆内存是4G，每个Region是2M，只要一个大对象超过了1M就被放入Humongous区，如果对象过大会横跨多个Region。\n\nimg\n\n7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时\n\n（-XX:InitiatingHeapOccupancyPercent默认45%）会触发混合回收MixedGC。回收所有年轻代和部分老年代的对象以及大对象区。采用复制算法来完成。\n\nimg\n\nimg\n\n混合回收\n混合回收分为：初始标记（initial mark）、并发标记（concurrent mark）、最终标记（remark或者Finalize Marking）、并发清理（cleanup）\n\nG1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1（Garbage first）名称的由来。\n\nimg\n\nG1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1（Garbage first）名称的由来。最后清理阶段使用复制算法，不会产生内存碎片。\n\nimg\n\n注意：如果清理过程中发现没有足够的空Region存放转移的对象，会出现Full GC。单线程执行标记-整理算法，此时会导致用户线程的暂停。所以尽量保证应该用的堆内存有一定多余的空间。\n\nimg\n\nG1 – Garbage First 垃圾回收器\n参数1： -XX:+UseG1GC 打开G1的开关，JDK9之后默认不需要打开\n\n参数2：-XX:MaxGCPauseMillis=毫秒值 最大暂停的时\n\n回收年代和算法：\n\n年轻代+老年代\n\n复制算法\n\n优点\n\n对比较大的堆如超过6G的堆回收时，延迟可控\n\n不会产生内存碎片\n\n并发标记的SATB算法效率高\n\n缺点\n\nJDK8之前还不够成熟\n\n适用场景\n\nJDK8最新版本、JDK9之后建议默认使用\n\n使用以下代码测试g1垃圾回收器，打印出每个阶段的时间:\n\npackage chapter04.gc;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * 垃圾回收器案例3\n */\n//-XX:+UseG1GC   -Xmn8g -Xmx16g -XX:SurvivorRatio=8  -XX:+PrintGCDetails -verbose:gc \npublic class GcDemo2 {\n\n    public static void main(String[] args) throws IOException {\n        int count = 0;\n        List<Object> list = new ArrayList<>();\n        while (true){\n            //System.out.println(++count);\n            if(count++ % 10240 == 0){\n                list.clear();\n            }\n//            byte[] bytes = new byte[1024 * 1024 * 1];\n            list.add(new byte[1024 * 1024 * 1 / 2]);\n//            System.gc();\n        }\n    }\n}\n每个region大小为2m，一共有84个young区，26个幸存者区。\n\nimg\n\n初始标记花了0.0478秒。\n\nimg\n\n并发标记总共耗时10ms，不会产生STW。\n\nimg\n\n总结\n垃圾回收器的组合关系虽然很多，但是针对几个特定的版本，比较好的组合选择如下：\n\nJDK8及之前：\n\nParNew + CMS（关注暂停时间）、Parallel Scavenge + Parallel Old (关注吞吐量)、 G1（JDK8之前不建议，较大堆并且关注暂停时间）\n\nJDK9之后:\n\nG1（默认）\n\n从JDK9之后，由于G1日趋成熟，JDK默认的垃圾回收器已经修改为G1，所以强烈建议在生产环境上使用G1。\n\nG1的实现原理将在《原理篇》中介绍，更多前沿技术ZGC、GraalVM将在《高级篇》中介绍。',28,'JAVA','JVM',1,3,0,1,'2024-05-17 16:20:24','2024-05-17 16:20:24'),(14,'验证回文串（力扣125）','','http://114.132.41.159/admin/dist/img/rand/5.jpg','# 题目描述\n如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 回文串 。\n\n字母和数字都属于字母数字字符。\n\n给你一个字符串 s，如果它是 回文串 ，返回 true ；否则，返回 false 。\n\n示例 1：\n\n输入: s = \"A man, a plan, a canal: Panama\"\n输出：true\n解释：\"amanaplanacanalpanama\" 是回文串。\n示例 2：\n\n输入：s = \"race a car\"\n输出：false\n解释：\"raceacar\" 不是回文串。\n示例 3：\n\n输入：s = \" \"\n输出：true\n解释：在移除非字母数字字符之后，s 是一个空字符串 \"\" 。\n由于空字符串正着反着读都一样，所以是回文串。\n# 解析\n第一步：将代码过滤\n第二步：首尾比较\n\n# 代码\n    class Solution {\n         public boolean isPalindrome(String s) {\n            char[] crr=new char[s.length()];\n            int n=0;\n            for (int i = 0; i < crr.length; i++) {\n                char c=s.charAt(i);\n                if(c<=\'Z\'&&c>=\'A\'){\n                    crr[n]=Character.toLowerCase(c);\n                    n++;\n                }else if(c<=\'z\'&&c>=\'a\'){\n                    crr[n]=c;\n                    n++;\n                }else if(c<=\'9\'&&c>=\'0\'){\n                    crr[n]=c;\n                    n++;\n                }\n            }\n    \n            for (int i = 0,j=n-1; i < j; i++,j--) {\n                if(crr[i]!=crr[j]){\n                    return false;\n                }\n            }\n            return true;\n        }\n    \n    }',29,'算法','字符串',1,24,0,0,'2024-05-19 15:46:01','2024-05-19 15:46:01'),(15,'ASCII码','','http://114.132.41.159/admin/dist/img/rand/37.jpg','| 二进制   | 十进制 | 十六进制 | 字符/缩写                                    | 解释                               |\n| -------- | ------ | -------- | -------------------------------------------- | ---------------------------------- |\n| 00000000 | 0      | 00       | NUL (NULL)                                   | 空字符                             |\n| 00000001 | 1      | 01       | SOH (Start Of Headling)                      | 标题开始                           |\n| 00000010 | 2      | 02       | STX (Start Of Text)                          | 正文开始                           |\n| 00000011 | 3      | 03       | ETX (End Of Text)                            | 正文结束                           |\n| 00000100 | 4      | 04       | EOT (End Of Transmission)                    | 传输结束                           |\n| 00000101 | 5      | 05       | ENQ (Enquiry)                                | 请求                               |\n| 00000110 | 6      | 06       | ACK (Acknowledge)                            | 回应/响应/收到通知                 |\n| 00000111 | 7      | 07       | BEL (Bell)                                   | 响铃                               |\n| 00001000 | 8      | 08       | BS (Backspace)                               | 退格                               |\n| 00001001 | 9      | 09       | HT (Horizontal Tab)                          | 水平制表符                         |\n| 00001010 | 10     | 0A       | LF/NL(Line Feed/New Line)                    | 换行键                             |\n| 00001011 | 11     | 0B       | VT (Vertical Tab)                            | 垂直制表符                         |\n| 00001100 | 12     | 0C       | FF/NP (Form Feed/New Page)                   | 换页键                             |\n| 00001101 | 13     | 0D       | CR (Carriage Return)                         | 回车键                             |\n| 00001110 | 14     | 0E       | SO (Shift Out)                               | 不用切换                           |\n| 00001111 | 15     | 0F       | SI (Shift In)                                | 启用切换                           |\n| 00010000 | 16     | 10       | DLE (Data Link Escape)                       | 数据链路转义                       |\n| 00010001 | 17     | 11       | DC1/XON (Device Control 1/Transmission On)   | 设备控制1/传输开始                 |\n| 00010010 | 18     | 12       | DC2 (Device Control 2)                       | 设备控制2                          |\n| 00010011 | 19     | 13       | DC3/XOFF (Device Control 3/Transmission Off) | 设备控制3/传输中断                 |\n| 00010100 | 20     | 14       | DC4 (Device Control 4)                       | 设备控制4                          |\n| 00010101 | 21     | 15       | NAK (Negative Acknowledge)                   | 无响应/非正常响应/拒绝接收         |\n| 00010110 | 22     | 16       | SYN (Synchronous Idle)                       | 同步空闲                           |\n| 00010111 | 23     | 17       | ETB (End of Transmission Block)              | 传输块结束/块传输终止              |\n| 00011000 | 24     | 18       | CAN (Cancel)                                 | 取消                               |\n| 00011001 | 25     | 19       | EM (End of Medium)                           | 已到介质末端/介质存储已满/介质中断 |\n| 00011010 | 26     | 1A       | SUB (Substitute)                             | 替补/替换                          |\n| 00011011 | 27     | 1B       | ESC (Escape)                                 | 逃离/取消                          |\n| 00011100 | 28     | 1C       | FS (File Separator)                          | 文件分割符                         |\n| 00011101 | 29     | 1D       | GS (Group Separator)                         | 组分隔符/分组符                    |\n| 00011110 | 30     | 1E       | RS (Record Separator)                        | 记录分离符                         |\n| 00011111 | 31     | 1F       | US (Unit Separator)                          | 单元分隔符                         |\n| 00100000 | 32     | 20       | (Space)                                      | 空格                               |\n| 00100001 | 33     | 21       | !                                            |                                    |\n| 00100010 | 34     | 22       | \"                                            |                                    |\n| 00100011 | 35     | 23       | #                                            |                                    |\n| 00100100 | 36     | 24       | $                                            |                                    |\n| 00100101 | 37     | 25       | %                                            |                                    |\n| 00100110 | 38     | 26       | &                                            |                                    |\n| 00100111 | 39     | 27       | \'                                            |                                    |\n| 00101000 | 40     | 28       | (                                            |                                    |\n| 00101001 | 41     | 29       | )                                            |                                    |\n| 00101010 | 42     | 2A       | *                                            |                                    |\n| 00101011 | 43     | 2B       | +                                            |                                    |\n| 00101100 | 44     | 2C       | ,                                            |                                    |\n| 00101101 | 45     | 2D       | -                                            |                                    |\n| 00101110 | 46     | 2E       | .                                            |                                    |\n| 00101111 | 47     | 2F       | /                                            |                                    |\n| 00110000 | 48     | 30       | 0                                            |                                    |\n| 00110001 | 49     | 31       | 1                                            |                                    |\n| 00110010 | 50     | 32       | 2                                            |                                    |\n| 00110011 | 51     | 33       | 3                                            |                                    |\n| 00110100 | 52     | 34       | 4                                            |                                    |\n| 00110101 | 53     | 35       | 5                                            |                                    |\n| 00110110 | 54     | 36       | 6                                            |                                    |\n| 00110111 | 55     | 37       | 7                                            |                                    |\n| 00111000 | 56     | 38       | 8                                            |                                    |\n| 00111001 | 57     | 39       | 9                                            |                                    |\n| 00111010 | 58     | 3A       | :                                            |                                    |\n| 00111011 | 59     | 3B       | ;                                            |                                    |\n| 00111100 | 60     | 3C       | <                                            |                                    |\n| 00111101 | 61     | 3D       | =                                            |                                    |\n| 00111110 | 62     | 3E       | >                                            |                                    |\n| 00111111 | 63     | 3F       | ?                                            |                                    |\n| 01000000 | 64     | 40       | @                                            |                                    |\n| 01000001 | 65     | 41       | A                                            |                                    |\n| 01000010 | 66     | 42       | B                                            |                                    |\n| 01000011 | 67     | 43       | C                                            |                                    |\n| 01000100 | 68     | 44       | D                                            |                                    |\n| 01000101 | 69     | 45       | E                                            |                                    |\n| 01000110 | 70     | 46       | F                                            |                                    |\n| 01000111 | 71     | 47       | G                                            |                                    |\n| 01001000 | 72     | 48       | H                                            |                                    |\n| 01001001 | 73     | 49       | I                                            |                                    |\n| 01001010 | 74     | 4A       | J                                            |                                    |\n| 01001011 | 75     | 4B       | K                                            |                                    |\n| 01001100 | 76     | 4C       | L                                            |                                    |\n| 01001101 | 77     | 4D       | M                                            |                                    |\n| 01001110 | 78     | 4E       | N                                            |                                    |\n| 01001111 | 79     | 4F       | O                                            |                                    |\n| 01010000 | 80     | 50       | P                                            |                                    |\n| 01010001 | 81     | 51       | Q                                            |                                    |\n| 01010010 | 82     | 52       | R                                            |                                    |\n| 01010011 | 83     | 53       | S                                            |                                    |\n| 01010100 | 84     | 54       | T                                            |                                    |\n| 01010101 | 85     | 55       | U                                            |                                    |\n| 01010110 | 86     | 56       | V                                            |                                    |\n| 01010111 | 87     | 57       | W                                            |                                    |\n| 01011000 | 88     | 58       | X                                            |                                    |\n| 01011001 | 89     | 59       | Y                                            |                                    |\n| 01011010 | 90     | 5A       | Z                                            |                                    |\n| 01011011 | 91     | 5B       | [                                            |                                    |\n| 01011100 | 92     | 5C       | \\                                            |                                    |\n| 01011101 | 93     | 5D       | ]                                            |                                    |\n| 01011110 | 94     | 5E       | ^                                            |                                    |\n| 01011111 | 95     | 5F       | _                                            |                                    |\n| 01100000 | 96     | 60       | `                                            |                                    |\n| 01100001 | 97     | 61       | a                                            |                                    |\n| 01100010 | 98     | 62       | b                                            |                                    |\n| 01100011 | 99     | 63       | c                                            |                                    |\n| 01100100 | 100    | 64       | d                                            |                                    |\n| 01100101 | 101    | 65       | e                                            |                                    |\n| 01100110 | 102    | 66       | f                                            |                                    |\n| 01100111 | 103    | 67       | g                                            |                                    |\n| 01101000 | 104    | 68       | h                                            |                                    |\n| 01101001 | 105    | 69       | i                                            |                                    |\n| 01101010 | 106    | 6A       | j                                            |                                    |\n| 01101011 | 107    | 6B       | k                                            |                                    |\n| 01101100 | 108    | 6C       | l                                            |                                    |\n| 01101101 | 109    | 6D       | m                                            |                                    |\n| 01101110 | 110    | 6E       | n                                            |                                    |\n| 01101111 | 111    | 6F       | o                                            |                                    |\n| 01110000 | 112    | 70       | p                                            |                                    |\n| 01110001 | 113    | 71       | q                                            |                                    |\n| 01110010 | 114    | 72       | r                                            |                                    |\n| 01110011 | 115    | 73       | s                                            |                                    |\n| 01110100 | 116    | 74       | t                                            |                                    |\n| 01110101 | 117    | 75       | u                                            |                                    |\n| 01110110 | 118    | 76       | v                                            |                                    |\n| 01110111 | 119    | 77       | w                                            |                                    |\n| 01111000 | 120    | 78       | x                                            |                                    |\n| 01111001 | 121    | 79       | y                                            |                                    |\n| 01111010 | 122    | 7A       | z                                            |                                    |\n| 01111011 | 123    | 7B       | {                                            |                                    |\n| 01111100 | 124    | 7C       | \\|                                           |                                    |\n| 01111101 | 125    | 7D       | }                                            |                                    |\n| 01111110 | 126    | 7E       | ~                                            |                                    |\n| 01111111 | 127    | 7F       | DEL (Delete)                                 | 删除                               |',30,'计算机','计算机基础',1,24,0,0,'2024-05-19 15:57:45','2024-05-19 15:57:45'),(16,'两数之和-输入有序数组（力扣167）','','http://114.132.41.159/admin/dist/img/rand/5.jpg','# 项目描述\n给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。\n\n以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。\n\n你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。\n\n你所设计的解决方案必须只使用常量级的额外空间。\n\n \n示例 1：\n\n输入：numbers = [2,7,11,15], target = 9\n输出：[1,2]\n解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n示例 2：\n\n输入：numbers = [2,3,4], target = 6\n输出：[1,3]\n解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。\n示例 3：\n\n输入：numbers = [-1,0], target = -1\n输出：[1,2]\n解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。\n \n\n提示：\n\n2 <= numbers.length <= 3 * 104\n-1000 <= numbers[i] <= 1000\nnumbers 按 非递减顺序 排列\n-1000 <= target <= 1000\n仅存在一个有效答案\n\n# 代码\n```java\nclass Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int n1=0,n2=numbers.length-1;\n        while (n1<n2){\n           if(numbers[n1]+numbers[n2]==target){\n               return new int[]{n1+1,n2+1};\n           } else if (numbers[n1]+numbers[n2]<target) {\n               n1++;\n           }else {\n               n2--;\n           }\n        }\n        return new int[]{n1+1,n2+1};\n    }\n}\n```\n\n# 代码解释\n初始时两个指针分别指向第一个元素位置和最后一个元素的位置。每次计算两个指针指向的两个元素之和，并和目标值比较。如果两个元素之和等于目标值，则发现了唯一解。如果两个元素之和小于目标值，则将左侧指针右移一位。如果两个元素之和大于目标值，则将右侧指针左移一位。移动指针之后，重复上述操作，直到找到答案。\n\n使用双指针的实质是缩小查找范围。那么会不会把可能的解过滤掉？答案是不会。假设 numbers[i]+numbers[j]=target\\textit{numbers}[i]+\\textit{numbers}[j]=\\textit{target}numbers[i]+numbers[j]=target 是唯一解，其中 0≤i<j≤numbers.length−10 \\leq i<j \\leq \\textit{numbers}.\\textit{length}-10≤i<j≤numbers.length−1。初始时两个指针分别指向下标 000 和下标 numbers.length−1\\textit{numbers}.\\textit{length}-1numbers.length−1，左指针指向的下标小于或等于 iii，右指针指向的下标大于或等于 jjj。除非初始时左指针和右指针已经位于下标 iii 和 jjj，否则一定是左指针先到达下标 iii 的位置或者右指针先到达下标 jjj 的位置。\n\n如果左指针先到达下标 iii 的位置，此时右指针还在下标 jjj 的右侧，sum>target\\textit{sum}>\\textit{target}sum>target，因此一定是右指针左移，左指针不可能移到 iii 的右侧。\n\n如果右指针先到达下标 jjj 的位置，此时左指针还在下标 iii 的左侧，sum<target\\textit{sum}<\\textit{target}sum<target，因此一定是左指针右移，右指针不可能移到 jjj 的左侧。\n\n由此可见，在整个移动过程中，左指针不可能移到 iii 的右侧，右指针不可能移到 jjj 的左侧，因此不会把可能的解过滤掉。由于题目确保有唯一的答案，因此使用双指针一定可以找到答案。\n\n、',29,'算法','双指针',1,19,0,0,'2024-05-19 17:02:42','2024-05-19 17:02:42'),(17,'三数之和（力扣15）','','http://114.132.41.159/admin/dist/img/rand/36.jpg','# 描述\n给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请\n\n你返回所有和为 0 且不重复的三元组。\n\n注意：答案中不可以包含重复的三元组。\n\n \n\n \n\n示例 1：\n\n输入：nums = [-1,0,1,2,-1,-4]\n输出：[[-1,-1,2],[-1,0,1]]\n解释：\nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。\n不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。\n注意，输出的顺序和三元组的顺序并不重要。\n示例 2：\n\n输入：nums = [0,1,1]\n输出：[]\n解释：唯一可能的三元组和不为 0 。\n示例 3：\n\n输入：nums = [0,0,0]\n输出：[[0,0,0]]\n解释：唯一可能的三元组和为 0 。\n \n\n提示：\n\n3 <= nums.length <= 3000\n-105 <= nums[i] <= 105\n# 分析\n首先，我们需要可以使用暴力法分析，即从首到尾选一个，然后每一个又选一个，最后再选一个，此时需要n^3次方。\n但是，我们可以知道，每一个都有重复的值，且都可能导致重复，所以我们需要进行排序。\n排序后，我们可以从小到大选一个first，并用一个target当作first对应的负数。\n此时，我们就只需要选取两个，由于我们已经排序了，我们可以使用双指针首尾收缩，逐个匹配值\n\n# 代码\n```java\nclass Solution {\n     public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> res=new ArrayList<>();\n        int first=0,second=0,third=0;\n        for (;first<nums.length-2;++first){\n            if(first>0&&nums[first]==nums[first-1]){\n                continue;\n            }   \n            int target=-nums[first];\n             third=nums.length-1;\n            for (second=first+1;second<nums.length-1;++second){\n                if(second > first + 1&&nums[second]==nums[second-1]){\n                    continue;\n                }  \n                while (second<third&&nums[second]+nums[third]>target){\n                    third--;\n                }\n                if (second == third) {\n                    break;\n                }\n\n                if(nums[second]+nums[third]==target){\n                    List<Integer> list=new ArrayList<>();\n                    list.add(nums[first]);\n                    list.add(nums[second]);\n                    list.add(nums[third]);\n                    res.add(list);\n                }\n            }\n        }\n        return res;\n    }\n}\n\n```',29,'算法','双指针',1,22,0,0,'2024-05-19 23:40:40','2024-05-19 23:40:40'),(18,'轮转数组（力扣189）','','http://114.132.41.159/admin/dist/img/rand/1.jpg','# 描述\n给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。\n\n \n\n示例 1:\n\n输入: nums = [1,2,3,4,5,6,7], k = 3\n输出: [5,6,7,1,2,3,4]\n解释:\n向右轮转 1 步: [7,1,2,3,4,5,6]\n向右轮转 2 步: [6,7,1,2,3,4,5]\n向右轮转 3 步: [5,6,7,1,2,3,4]\n示例 2:\n\n输入：nums = [-1,-100,3,99], k = 2\n输出：[3,99,-1,-100]\n解释: \n向右轮转 1 步: [99,-1,-100,3]\n向右轮转 2 步: [3,99,-1,-100]\n \n\n提示：\n\n1 <= nums.length <= 105\n-231 <= nums[i] <= 231 - 1\n0 <= k <= 105\n \n# 分析\n第一步，将数组反转\n\n第二步，将前k个数倒转\n\n第三步，将后面数倒转\n# 代码\n    class Solution {\n        public void rotate(int[] nums, int k) {\n            k %= nums.length;\n            reverse(nums, 0, nums.length - 1);\n            reverse(nums, 0, k - 1);\n            reverse(nums, k, nums.length - 1);\n        }\n    \n        public void reverse(int[] nums, int start, int end) {\n            while (start < end) {\n                int temp = nums[start];\n                nums[start] = nums[end];\n                nums[end] = temp;\n                start += 1;\n                end -= 1;\n            }\n        }\n    \n    }',29,'算法','数组',1,60,0,0,'2024-05-20 20:25:28','2024-05-20 20:25:28'),(19,'Redis基础','','http://114.132.41.159/admin/dist/img/rand/28.jpg','# 理论\n\n### SQL与NoSQL\n\n![image-20240426210225561](./3、Redis.assets/image-20240426210225561.png)\n\n- 扩展性\n\n  - 关系型数据库集群模式一般是主从，主从数据一致，起到数据备份的作用，称为垂直扩展。\n\n  - 非关系型数据库可以将数据拆分，存储在不同机器上，可以保存海量数据，解决内存大小有限的问题，称为水平扩展。\n\n  - 关系型数据库因为表之间存在关联关系，如果做水平扩展会给数据查询带来很多麻烦。\n\n### Redis特征\n\n- 键值（key-value）型，value支持多种不同数据结构，功能丰富\n\n- 单线程，每个命令具备原子性\n\n- 低延迟，速度快（基于内存、IO多路复用、良好的编码）\n\n- 支持数据持久化\n\n- 支持主从集群、分片集群\n\n- 支持多语言客户端\n\n### Redis应用场景\n\n**Redis 适合的场景**\n\n1. 缓存：减轻 MySQL 的查询压力，提升系统性能；\n2. 排行榜：利用 Redis 的 SortSet（有序集合）实现；\n3. 计数器/限速器：利用 Redis 中原子性的自增操作，我们可以统计类似用户点赞数、用户访问数等。这类操作如果用 MySQL，频繁的读写会带来相当大的压力；限速器比较典型的使用场景是限制某个用户访问某个 API 的频率，常用的有抢购时，防止用户疯狂点击带来不必要的压力；\n4. 好友关系：利用集合的一些命令，比如求交集、并集、差集等。可以方便解决一些共同好友、共同爱好之类的功能；\n5. 消息队列：除了 Redis 自身的发布/订阅模式，我们也可以利用 List 来实现一个队列机制，比如：到货通知、邮件发送之类的需求，不需要高可靠，但是会带来非常大的 DB 压力，完全可以用 List 来完成异步解耦；\n6. Session 共享：Session 是保存在服务器的文件中，如果是集群服务，同一个用户过来可能落在不同机器上，这就会导致用户频繁登陆；采用 Redis 保存 Session 后，无论用户落在那台机器上都能够获取到对应的 Session 信息。\n\n**Redis 不适合的场景**\n\n数据量太大、数据访问频率非常低的业务都不适合使用 Redis，数据太大会增加成本，访问频率太低，保存在内存中纯属浪费资源。\n\n\n\n\n\n\n\n# 原理\n\n# 基础/语法\n\n## Redis服务端\n\n### 安装：\n\n- 使用Ubuntu\n\n- 安装c编译器\n\n- 下载redis（https://redis.io/download/）\n\n- 解压并进入redis目录\n\n- 运行：make && make install（一般需要安装make指令）\n\n- 安装完成：/usr/local/bin\n\n### 默认启动/关闭\n\n- 启动：redis-server![img](https://api2.mubu.com/v3/document_image/374398f5-ccf8-4702-8f37-16a5f76e1b20-18846868.jpg)\n\n- 关闭：窗口叉掉 或者 CTRL + C\n\n### 配置：redis.conf\n\n- 允许访问的地址：bind 0.0.0.0\n\n  - 默认是127.0.0.1，会导致只能在本地访问\n\n  - 修改为0.0.0.0则可以在任意IP访问，生产环境不要设置为0.0.0.0\n\n- 守护进程：daemonize yes\n  - 修改为yes后即可后台运行\n\n- 密码：requirepass 123456\n\n- 监听的端口：port 6379\n\n- 工作目录：dir .\n  - 默认是当前目录，也就是运行redis-server时的命令，日志、持久化等文件会保存在这个目录\n\n- 数据库数量：databases 1\n  - 设置为1，代表只使用1个库，默认有16个库，编号0~15\n\n- 设置redis能够使用的最大内存：maxmemory 512mb\n\n- 日志文件：logfile \"redis.log\"\n  - 默认为空，不记录日志，可以指定日志文件名\n\n### 配置后台启动/关闭\n\n- 修改配置：\n\n  - 1 默认daemonize no              改为  daemonize yes\n\n  - 2 默认protected-mode  yes    改为  protected-mode no\n\n  - 3 默认bind 127.0.0.1             改为  直接注释掉(默认bind 127.0.0.1只能本机访问)或改成本机IP地址，否则影响远程IP连接\n\n  - 4 添加redis密码                      改为 requirepass 你自己设置的密码\n\n- 启动（在redis-7.2.4目录下）：redis-server /opt/redis-7.2.4/redis.conf\n\n- 关闭：redis-cli -u 123321 shutdown\n\n### 开机自启动：\n\n- 配置：\n\n  - 1、创建并添加：/etc/systemd/system/redis.service\n\n    ```\n    [Unit]\n    Description=redis-server\n    After=network.target\n    [Service]\n    Type=forking\n    ExecStart=/usr/local/bin/redis-server /usr/local/src/redis-6.2.6/redis.conf\n    PrivateTmp=true\n    [Install]\n    WantedBy=multi-user.target\n    ```\n\n  - 2、重载系统服务：systemctl daemon-reload\n\n- 命令：\n\n  - \\# 启动：systemctl start redis\n\n  - \\# 停止：systemctl stop redis\n\n  - \\# 重启：systemctl restart redis\n\n  - \\# 查看状态：systemctl status redis\n\n## Redis客户端\n\n### 命令行客户端：\n\n- 连接：redis-cli [options] [commonds]\n\n  ![image-20240426210613190](./3、Redis.assets/image-20240426210613190.png)\n\n  - options\n\n    - -h 127.0.0.1：指定要连接的redis节点的IP地址，默认是127.0.0.1\n\n    - -p 6379：指定要连接的redis节点的端口，默认是6379\n\n    - -a 123321：指定redis的访问密码 \n\n  - commonds\n    - ping：与redis服务端做心跳测试，服务端正常会返回pong\n\n- 关闭redis服务器：shutdown\n\n## Redis常用命令\n\n https://redis.io/commands \n\n- KEYS  ...：查看符合模板的所有key![img](https://api2.mubu.com/v3/document_image/e65e72c2-f26d-40a4-a3a8-0e40e8d6bcd5-18846868.jpg)\n\n- DEL  ...：删除一个指定的key![img](https://api2.mubu.com/v3/document_image/1ac5c46b-8a38-4d2f-b822-db851780ba13-18846868.jpg)\n\n- EXISTS  ...：判断key是否存在\n\n- EXPIRE  ...：给一个key设置有效期，有效期到期时该key会被自动删除（单位：秒）![img](https://api2.mubu.com/v3/document_image/9826412b-c76f-411d-884e-869da218ffbb-18846868.jpg)\n\n- TTL  ...：查看一个KEY的剩余有效期\n\n- help ...：查看命令功能![img](https://api2.mubu.com/v3/document_image/c047efac-5fe6-4db8-afe7-83c73238652c-18846868.jpg)\n\n## Redis数据结构\n\n### String\n\n- key：[项目名]:[业务名]:[类型]:[id]\n  - 允许有多个单词形成层级结构，多个单词之间用\':\'隔开![img](https://api2.mubu.com/v3/document_image/aa1d7997-2f31-40a8-bb29-17c7b8b49987-18846868.jpg)\n\n- value：（底层都是字节数组形式存储，只不过是编码方式不同）\n\n  - string：普通字符串\n\n  - int：整数类型，可以做自增、自减操作\n\n  - float：浮点类型，可以做自增、自减操作\n\n- 命令：\n\n  - SET：添加或者修改已经存在的一个String类型的键值对\n\n  - GET：根据key获取String类型的value\n\n  - MSET：批量添加多个String类型的键值对\n\n  - MGET：根据多个key获取多个String类型的value\n\n  - INCR：让一个整型的key自增1\n\n  - INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2\n\n  - INCRBYFLOAT：让一个浮点类型的数字自增并指定步长\n\n  - SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行（互斥锁）\n\n  - SETEX：添加一个String类型的键值对，并且指定有效期\n\n### List：\n\n一个双向链表结构，支持正向检索和 反向检索\n\n- key-values：![img](https://api2.mubu.com/v3/document_image/6594311a-1027-4964-bc35-a1d98cb48772-18846868.jpg)\n\n- 命令：\n\n  - LPUSH key  element ... ：向列表左侧插入一个或多个元素![img](https://api2.mubu.com/v3/document_image/5d934992-3bef-473b-a5fb-96707ebedb5c-18846868.jpg)\n\n  - LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil\n\n  - RPUSH key  element ... ：向列表右侧插入一个或多个元素\n\n  - RPOP key：移除并返回列表右侧的第一个元素\n\n  - LRANGE key star end：返回一段角标范围内的所有元素\n\n  - BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil\n\n### Set：\n\n- 特点：\n\n  - 无序\n\n  - 元素不可重复\n\n  - 查找快\n\n  - 支持交集、并集、差集等功能\n\n- 命令：\n\n  - SADD key member ... ：向set中添加一个或多个元素\n\n  - SREM key member ... : 移除set中的指定元素\n\n  - SCARD key： 返回set中元素的个数\n\n  - SISMEMBER key member：判断一个元素是否存在于set中\n\n  - SMEMBERS：获取set中的所有元素\n\n  - SINTER key1 key2 ... ：求key1与key2的交集\n\n### SortedSet\n\nSortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表\n\n- 特性：\n\n  - 可排序\n\n  - 元素不重复\n\n  - 查询速度快\n\n- 命令：\n\n  - ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值\n\n  - ZREM key member：删除sorted set中的一个指定元素\n\n  - ZSCORE key member : 获取sorted set中的指定元素的score值\n\n  - ZRANK key member：获取sorted set 中的指定元素的排名\n\n  - ZCARD key：获取sorted set中的元素个数\n\n  - ZCOUNT key min max：统计score值在给定范围内的所有元素的个数\n\n  - ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值\n\n  - ZRANGE key min max：按照score排序后，获取指定排名范围内的元素\n\n  - ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素\n\n  - ZDIFF、ZINTER、ZUNION：求差集、交集、并集\n\n  - 注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可\n\n### HashSet：\n\n- key-value结构：![img](https://api2.mubu.com/v3/document_image/2d2ef11e-577d-4930-9db9-32ac24ca108a-18846868.jpg)\n\n- 命令：\n\n  - HSET key field value：添加或者修改hash类型key的field的值![img](https://api2.mubu.com/v3/document_image/3a607b2b-dffb-42d8-8c3d-e4d811082872-18846868.jpg)\n\n  - HGET key field：获取一个hash类型key的field的值\n\n  - HMSET：批量添加多个hash类型key的field的值\n\n  - HMGET：批量获取多个hash类型key的field的值\n\n  - HGETALL：获取一个hash类型的key中的所有的field和value![img](https://api2.mubu.com/v3/document_image/bf8750b7-5ef4-4c36-9a6c-8c54d4ad8982-18846868.jpg)\n\n  - HKEYS：获取一个hash类型的key中的所有的field\n\n  - HVALS：获取一个hash类型的key中的所有的value\n\n  - HINCRBY:让一个hash类型key的字段值自增并指定步长\n\n  - HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行\n\n## 客户端类型![img](https://api2.mubu.com/v3/document_image/ee8d2b91-7eb3-453e-8618-8d2da16a6b94-18846868.jpg)\n\n## Jedis：\n\nhttps://github.com/redis/jedis\n\n### 基础步骤\n\n- 1、引入依赖\n\n  ```\n  <!--jedis-->\n  <dependency>\n      <groupId>redis.clients</groupId>\n      <artifactId>jedis</artifactId>\n      <version>3.7.0</version>\n  </dependency>\n  <!--单元测试-->\n  <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter</artifactId>\n      <version>5.7.0</version>\n      <scope>test</scope>\n  </dependency>\n  ```\n\n- 2、创建连接、使用、关闭\n\n  ```\n  package com.example.jedis1;\n  import org.junit.jupiter.api.AfterEach;\n  import org.junit.jupiter.api.BeforeEach;\n  import org.junit.jupiter.api.Test;\n  import org.springframework.boot.test.context.SpringBootTest;\n  import redis.clients.jedis.Jedis;\n  import java.util.Map;\n  @SpringBootTestclass\n   Jedis1ApplicationTests {\n  private Jedis jedis;\n  @BeforeEach\n      public void set(){\n  // 1.建立连接         jedis = new Jedis(\"192.168.126.131\", 6379);\n  // 2.设置密码        jedis.auth(\"123456\");\n  // 3.选择库        jedis.select(0);\n      }\n  @Test\n      void testString() {\n  // 存入数据        String result = jedis.set(\"name\", \"虎哥\");\n          System.out.println(\"result = \" + result);\n  // 获取数据        String name = jedis.get(\"name\");\n          System.out.println(\"name = \" + name);\n      }\n  @Test\n      void testHash() {\n  // 插入hash数据        jedis.hset(\"user:1\", \"name\", \"Jack\");\n  jedis.hset(\"user:1\", \"age\", \"21\");\n  // 获取        Map<String, String> map = jedis.hgetAll(\"user:1\");\n          System.out.println(map);\n      }\n  @AfterEach\n  ​    void tearDown() {\n  if (jedis != null) {\n  jedis.close();\n          }\n      }\n  }\n  \n  - \n  ```\n\n  连接![img](https://api2.mubu.com/v3/document_image/93ef4b89-adc6-4c53-b22e-a77d63ad2966-18846868.jpg)\n\n  - 使用![img](https://api2.mubu.com/v3/document_image/22f95f3e-9444-4f67-ab6a-d61ba89e81e2-18846868.jpg)\n\n  - 关闭![img](https://api2.mubu.com/v3/document_image/3c5f5d13-6a48-482d-86f3-c0efc3b73467-18846868.jpg)\n\n### 连接池步骤：\n\n- 1、添加依赖\n\n  ```\n  <!--jedis-->\n  <dependency>\n      <groupId>redis.clients</groupId>\n      <artifactId>jedis</artifactId>\n      <version>3.7.0</version>\n  </dependency>\n  <!--单元测试-->\n  <dependency>\n      <groupId>org.junit.jupiter</groupId>\n      <artifactId>junit-jupiter</artifactId>\n      <version>5.7.0</version>\n      <scope>test</scope>\n  </dependency>\n  ```\n\n- 2、配置连接池类\n\n  ```\n  import redis.clients.jedis.*;\n  public class JedisConnectionFactory {\n  private static JedisPool jedisPool;\n  static {\n  // 配置连接池        JedisPoolConfig poolConfig = new JedisPoolConfig();\n          poolConfig.setMaxTotal(8);\n          poolConfig.setMaxIdle(8);\n          poolConfig.setMinIdle(0);\n          poolConfig.setMaxWaitMillis(1000);\n  // 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码        jedisPool = new JedisPool(poolConfig, \"192.168.126.131\", 6379, 1000, \"123456\");\n      }\n  public static Jedis getJedis(){\n  return jedisPool.getResource();\n      }\n  }\n  ```\n\n- 3、创建连接、使用、关闭\n\n  ```\n  import org.junit.jupiter.api.AfterEach;\n  import org.junit.jupiter.api.BeforeEach;\n  import org.junit.jupiter.api.Test;\n  import org.springframework.boot.test.context.SpringBootTest;\n  import redis.clients.jedis.Jedis;\n  import java.util.Map;\n  @SpringBootTestclass\n   Jedis1ApplicationTests {\n  private Jedis jedis;\n  @BeforeEach\n      public void set(){\n  // 1.建立连接//         jedis = new Jedis(\"192.168.126.131\", 6379);        jedis = JedisConnectionFactory.getJedis();\n  // 2.设置密码        jedis.auth(\"123456\");\n  // 3.选择库        jedis.select(0);\n      }\n  @Test\n      void testString() {\n  // 存入数据        String result = jedis.set(\"name\", \"虎哥\");\n          System.out.println(\"result = \" + result);\n  // 获取数据        String name = jedis.get(\"name\");\n          System.out.println(\"name = \" + name);\n      }\n  @Test \n     void testHash() {\n  // 插入hash数据        jedis.hset(\"user:1\", \"name\", \"Jack\");\n  jedis.hset(\"user:1\", \"age\", \"21\");\n  // 获取        Map<String, String> map = jedis.hgetAll(\"user:1\");\n          System.out.println(map);\n      }\n  @AfterEach\n  ​    void tearDown() {\n  if (jedis != null) {\n  jedis.close();\n          }\n      }\n  }\n  ```\n\n## SpringDataRedis\n\nhttps://spring.io/projects/spring-data-redis\n\n### 特点：\n\n- 提供了对不同Redis客户端的整合（Lettuce和Jedis）\n\n- 提供了RedisTemplate统一API来操作Redis\n\n- 支持Redis的发布订阅模型\n\n- 支持Redis哨兵和Redis集群\n\n- 支持基于Lettuce的响应式编程\n\n- 支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化\n\n- 支持基于Redis的JDKCollection实现\n\n### 基础步骤：\n\n- 1、添加依赖\n\n  ```\n  <!--   redis     -->\n  <dependency>\n      <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-redis</artifactId>\n  </dependency>\n  <!--common-pool-->\n  <dependency>\n      <groupId>org.apache.commons</groupId>\n      <artifactId>commons-pool2</artifactId>\n  </dependency>\n  <!--Jackson依赖-->\n  <dependency>\n      <groupId>com.fasterxml.jackson.core</groupId>\n      <artifactId>jackson-databind</artifactId>\n  </dependency>\n  ```\n\n  - spring-boot-starter-data-redis：这Spring Boot提供的Redis集成的起始器，自动配置Redis相关的bean，包括连接池、RedisTemplate等\n\n  - commons-pool2：Apache Commons Pool 2库，提供了一个通用的对象池实现，用于管理与Redis服务器的连接，在Spring Boot中，被用作Redis连接池的实现，确保在多个线程之间共享和重复使用连接，提高性能和效率\n\n  - jackson-databind：Jackson库的核心模块，用于处理Java对象和JSON之间的序列化和反序列化，在Spring Boot中，被用来将Java对象转换为JSON格式存储到Redis中，或者从Redis中读取JSON数据并转换为Java对象\n\n- 2、全局配置\n\n  ```\n  spring.redis.host=192.168.126.131\n  spring.redis.port=6379\n  spring.redis.password=123456\n  ```\n\n- 自定义RedisTemplate\n\n  ```\n  @Configuration\n  public class RedisConfig {\n      @Bean\n      public RedisTemplate redisTemplate(RedisConnectionFactory connectionFactory){\n          // 创建RedisTemplate对象\n          RedisTemplate template = new RedisTemplate<>();\n          // 设置连接工厂\n          template.setConnectionFactory(connectionFactory);\n          // 创建JSON序列化工具\n          GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();\n          // 设置Key的序列化\n          template.setKeySerializer(RedisSerializer.string());\n          template.setHashKeySerializer(RedisSerializer.string());\n          // 设置Value的序列化\n          template.setValueSerializer(jsonRedisSerializer);\n          template.setHashValueSerializer(jsonRedisSerializer);\n          // 返回\n          return template;\n      }\n  }\n  ```\n\n- 3、依赖注入RedisTemplate使用\n\n  ```\n  @Autowired\n      private RedisTemplate edisTemplate;\n      @Test\n      void testString() {\n          // 写入一条String数据\n          redisTemplate.opsForValue().set(\"name\", \"虎哥\");\n          // 获取string数据\n          Object name = stringRedisTemplate.opsForValue().get(\"name\");\n          System.out.println(\"name = \" + name);\n      }\n  ```\n\n### 全局配置\n\n- springboot2.0\n\n  - \\# Redis数据库索引（默认为0）spring.redis.database=0\n\n  - \\# Redis服务器地址spring.redis.host=127.0.0.1\n\n  - \\# Redis服务器连接端口spring.redis.port=6379\n\n  - \\# Redis服务器连接密码（默认为空）spring.redis.password=\n\n  - \\# 连接池最大连接数（使用负值表示没有限制）spring.redis.jedis.pool.max-active=20\n\n  - \\# 连接池最大阻塞等待时间（使用负值表示没有限制）spring.redis.jedis.pool.max-wait=-1\n\n  - \\# 连接池中的最大空闲连接spring.redis.jedis.pool.max-idle=10\n\n  - \\# 连接池中的最小空闲连接spring.redis.jedis.pool.min-idle=0\n\n  - \\# 连接超时时间（毫秒）spring.redis.timeout=1000\n\n- springboot3.0\n\n  - \\# Redis 数据库索引（默认为0）\n    - spring.data.redis.database=0\n\n  - \\# Redis 服务的ip,我的是在虚拟机的服务器上。\n    - spring.data.redis.host=192.168.45.129\n\n  - \\# Redis 端口\n    - spring.data.redis.port=6379\n\n  - \\# Redis 密码，默认为空，可以修改 redis.conf配置文件\n    - spring.data.redis.password=\n\n  - \\# 最大可用连接数\n    - spring.redis.pool.max-active=200\n\n  - \\# 从连接池中获取连接最大等待时间\n    - spring.redis.pool.max-wait=-1\n\n  - \\# 最大空闲连接数\n    - spring.redis.pool.max-idle=10\n\n  - \\# 最小空闲连接数\n    - spring.redis.pool.min-idle=0\n\n  - \\# redis连接超时时间（单位为毫秒）\n    - spring.data.redis.timeout=1000\n\n### RedisTemplate\n\n#### 默认RedisTemplate\n\n- 特点：使用RedisTemplate进行Redis数据缓存操作时，内部默认使用的是JdkSerializationRedisSerializer序列化方式，所以进行数据缓存的实体类必须实现JDK自带的序列化接口（例如Serializable）\n\n- 授予步骤：\n\n  - 1、定义实体类\n\n  - 2、使用RedisTemplate\n\n    ```\n    @Autowiredprivate RedisTemplate redisTemplate;\n    @Testvoid testString() {\n    // 写入一条String数据\n        redisTemplate.opsForValue().set(\"name\", \"虎哥\");\n    // 获取string数据\n        Object name = redisTemplate.opsForValue().get(\"name\");\n        System.out.println(\"name = \" + name);\n    }\n    ```\n\n    \n\n#### 自定义RedisTemplate（JSON自动序列化）\n\n- 特点：能将Java对象自动的序列化为JSON字符串，并且查询时能自动把JSON反序列化为Java对象\n\n- 使用步骤：\n\n  - 1、定义RedisTemplate\n\n    ```\n    @Configuration\n    public class RedisConfig {\n        @Bean\n        public RedisTemplate redisTemplate(RedisConnectionFactory connectionFactory){\n            // 创建RedisTemplate对象\n            RedisTemplate template = new RedisTemplate<>();\n            // 设置连接工厂\n            template.setConnectionFactory(connectionFactory);\n            // 创建JSON序列化工具\n            GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();\n            // 设置Key的序列化\n            template.setKeySerializer(RedisSerializer.string());\n            template.setHashKeySerializer(RedisSerializer.string());\n            // 设置Value的序列化\n            template.setValueSerializer(jsonRedisSerializer);\n            template.setHashValueSerializer(jsonRedisSerializer);\n            // 返回\n            return template;\n        }\n    }\n    ```\n\n  - 2、使用\n\n    ```\n    @Autowired\n    private RedisTemplate redisTemplate;\n    @Test\n    void testString() {\n    // 写入一条String数据\n        User user=new User();\n        user.setAge(11);\n        user.setName(\"lee\");\n        redisTemplate.opsForValue().set(\"lyr\", user);\n        User user1=(User) redisTemplate.opsForValue().get(\"lyr\");\n    // 获取string数据\n        System.out.println(\"name = \" + user1);\n    }\n    ```\n\n  - 3、查看实体类序列化![img](https://api2.mubu.com/v3/document_image/605a20d4-cedb-4bbc-949c-7927a3d1d36f-18846868.jpg)\n\n- 方法：https://blog.csdn.net/zzvar/article/details/118388897![img](https://api2.mubu.com/v3/document_image/db2e9dea-95b3-40e9-9e1a-f24fadaadd5c-18846868.jpg)\n\n### StringRedisTemplate\n\n（String手动序列化）\n\n- 特点：为了节省内存空间，不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value\n\n- 区别：\n\n  - StringRedisTemplate 是 RedisTemplate 的子类，两个方法基本一致，不同之处在于 操作的数据类型不同：RedisTemplate 两个泛型都是 Object，意味着存储的 key 和 value 都可以是一个对象；StringRedisTemplate 两个泛型都是 String，意味着存储的 的 key 和 value 都只能是字符串。\n\n  - 注：使用 RedisTemplate 默认是将对象序列化到 Redis 中，所以 放入的对象必须实现对象序列化接口。\n\n  - 注：两者的 数据是不共通的；也就是说 StringRedisTemplate 只能管理 StringRedisTemplate 里面的数据，RedisTemplate 只能管理 RedisTemplate 中的数据。\n\n- 使用步骤：\n\n  ```\n  @Autowired\n  private\n   StringRedisTemplate stringRedisTemplate;\n  // JSON序列化工具\n  private static final ObjectMapper mapper = new ObjectMapper();\n  @Testvoid\n   testSaveUser() throws JsonProcessingException {\n  // 创建对象    User user = new User();\n      user.setName(\"李艺儒\");\n      user.setAge(22);\n  // 手动序列化\n      String json = mapper.writeValueAsString(user);\n  // 写入数据\n      stringRedisTemplate.opsForValue().set(\"user:200\", json);\n  // 获取数据\n      String jsonUser = stringRedisTemplate.opsForValue().get(\"user:200\");\n  // 手动反序列化\n      User user1 = mapper.readValue(jsonUser, User.class);\n      System.out.println(\"user1 = \" + user1);\n  }\n  ```\n\n## [Spring Boot 整合 Redis](https://blog.csdn.net/weixin_43749805/article/details/131399516)\n\n### 基于注解\n\n#### 步骤\n\n- 1、添加依赖\n\n  ```\n  <dependency> \n     <groupId>org.springframework.boot</groupId>\n      <artifactId>spring-boot-starter-data-redis</artifactId>\n  </dependency>\n  ```\n\n- 2、全局配置\n\n  ```\n  spring.redis.host=127.0.0.1\n  spring.redis.port=6379\n  spring.redis.password=\n  ```\n\n- 3、启动类添加 @ EnableCaching\n\n- 4、类实现序列化（字节流，便于存到缓存中，同时还能从缓存中反序列化）\n\n- 5、在对应service配置cache相关注解\n\n#### cache注解\n\n##### 步骤：\n\n- 1、启动类添加 @ EnableCaching![img](https://api2.mubu.com/v3/document_image/42539e26-a6e8-40db-8955-d1b9f1181679-18846868.jpg)\n\n- 2、在相关service层添加注解![img](https://api2.mubu.com/v3/document_image/9cabb169-fda3-421d-bf72-ae2b41534381-18846868.jpg)\n\n##### Cacheable注解（进行缓存）\n\n- 作用：\n\n  - 用于类或方法（通常用在数据查询方法上），用于对方法结果进行缓存存储\n\n  - 先进行缓存查询，如果为空则进行方法查询，并将结果进行缓存；如果缓存中有数据，不进行方法查询，而是直接使用缓存数据\n\n- 属性：@ Cacheable(属性=\"属性值\", ...)![img](https://api2.mubu.com/v3/document_image/d111592f-0134-417a-8f8b-c340188fa3d0-18846868.jpg)![img](https://api2.mubu.com/v3/document_image/5eef73a5-9544-4789-abe7-70408a0bf739-18846868.jpg)\n\n##### CachePut注解（更新缓存）\n\n- 属性：![img](https://api2.mubu.com/v3/document_image/d111592f-0134-417a-8f8b-c340188fa3d0-18846868.jpg)\n\n##### CacheEvict注解（删除缓存）\n\n- 属性：![img](https://api2.mubu.com/v3/document_image/d111592f-0134-417a-8f8b-c340188fa3d0-18846868.jpg)\n\n- 新属性\n\n  - allEntries属性： allEntries属性表示是否清除指定缓存空间中的所有缓存数据，默认值为false（即默认只删除指定key对应的缓存数据）\n\n  - beforeInvocation属性：beforeInvocation属性表示是否在方法执行之前进行缓存清除，默认值为false（即默认在执行方法后再进行缓存清除）\n\n##### Caching注解（复杂的缓存管理）\n\n- 意义：针对复杂规则的数据缓存管理，可以作用于类或方法，在Caching注解内部包含有Cacheable、put和evict三个属性，分别对应于@Cacheable、@CachePut和@ CacheEvict三个注解\n\n- 举例：![img](https://api2.mubu.com/v3/document_image/ae475a40-f463-4690-8b43-1d1b4dd0227f-18846868.jpg)\n\n##### CacheConfig注解（统筹管理）\n\n- 作用：统筹管理类中所有使用@Cacheable、@CachePut和@ CacheEvict注解标注方法中的公共属性，这些公共属性包括有cacheNames、keyGenerator、cacheManager和cacheResolver。\n\n- 举例![img](https://api2.mubu.com/v3/document_image/5afa67cf-c27c-4295-ab21-047c52c1cfa7-18846868.jpg)\n\n案例：[SpringBoot项目中使用缓存Cache](https://juejin.cn/post/7220292698854752313)\n\n### 基于RedisTemplate\n\n#### 默认RedisTemplate\n\n- RedisTemplate类源码\n\n  - 使用RedisTemplate进行Redis数据缓存操作时，内部默认使用的是JdkSerializationRedisSerializer序列化方式，所以进行数据缓存的实体类必须实现JDK自带的序列化接口（例如Serializable）\n\n  - 使用RedisTemplate进行Redis数据缓存操作时，如果自定义了缓存序列化方式defaultSerializer，那么将使用自定义的序列化方式\n\n#### 自定义RedisTemplate\n\n- RedisAutoConfiguration（自定义依据）\n\n  - (1) 在Redis自动配置类中，通过Redis连接工厂RedisConnectionFactory初始化了一个RedisTemplate；该类上方添加了@ConditionalOnMissingBean注解（顾名思义，当某个Bean不存在时生效），用来表明如果开发者自定义了一个名为redisTemplate的Bean，则该默认初始化的RedisTemplate会被覆盖。\n\n  - (2) 如果想要使用自定义序列化方式的RedisTemplate进行数据缓存操作，可以参考上述核心代码创建一个名为redisTemplate的Bean组件，并在该组件中设置对应的序列化方式即可。\n\n- 代码：在项目中创建创建一个Redis自定义配置类RedisConfig，通过@ Configuration注解定义了一个RedisConfig配置类，并使用@ Bean注解注入了一个默认名称为方法名的redisTemplate组件（注意，该Bean组件名称必须是redisTemplate）；在定义的Bean组件中，自定义了一个RedisTemplate，使用自定义的Jackson2JsonRedisSerializer数据序列化方式；在定制序列化方式中，定义了一个ObjectMapper用于进行数据转换设置。\n\n  ```\n  @Bean\n      public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) {\n          RedisTemplate<Object, Object> template = new RedisTemplate();\n          template.setConnectionFactory(redisConnectionFactory);\n          // 使用JSON格式序列化对象，对缓存数据key和value进行转换\n          Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class);\n          // 解决查询缓存转换异常的问题\n          ObjectMapper om = new ObjectMapper();\n          om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n          om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n          jacksonSeial.setObjectMapper(om);\n          // 设置RedisTemplate模板API的序列化方式为JSON \n         template.setDefaultSerializer(jacksonSeial);\n          return template;\n      }\n  ```\n\n#### 自定义RedisCacheManager\n\n原理：\n\n- 1. Spring Boot整合Redis组件提供的缓存自动配置类RedisCacheConfiguration,其内部是通过Redis连接工厂RedisConnectionFactory定义了一个缓存管理器RedisCacheManager；同时定制RedisCacheManager时，也默认使用了JdkSerializationRedisSerializer序列化方式。\n\n- 2. 如果想要使用自定义序列化方式的RedisCacheManager进行数据缓存操作，可以创建一个名为cacheManager的Bean组件，并在该组件中设置对应的序列化方式即可。\n\n代码：\n\n```\n@Bean\n      public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) {\n          // 分别创建String和JSON格式序列化对象，对缓存数据key和value进行转换 \n         RedisSerializer<String> strSerializer = new StringRedisSerializer();\n          Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class);\n          // 解决查询缓存转换异常的问题\n          ObjectMapper om = new ObjectMapper();\n          om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);\n          om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);\n          jacksonSeial.setObjectMapper(om);\n          // 定制缓存数据序列化方式及时效 \n         RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()\n                  .entryTtl(Duration.ofDays(1))\n       		       .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(strSerializer))\n                  .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jacksonSeial))\n                  .disableCachingNullValues();\n          RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(config).build();\n          return cacheManager;\n      }\n\n```\n\n基于Redission\n\n# 应用\n\n## 查询缓存\n\n缓存类别\n\n- 浏览器缓存：主要是存在于浏览器端的缓存\n\n- 应用层缓存：可以分为tomcat本地缓存，比如之前提到的map，或者是使用redis作为缓存\n\n- 数据库缓存：在数据库中有一片空间是 buffer pool，增改查数据都会先加载到mysql的缓存中\n\n- CPU缓存：当代计算机最大的问题是 cpu性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了cpu的L1，L2，L3级的缓存\n\n缓存添加步骤：RedisTemplate\n\n![img](./3、Redis.assets/f66d7557-7e4f-42b4-af72-d4c8b950393f-18846868.jpg)\n\n- 步骤![img](https://api2.mubu.com/v3/document_image/10a3ad18-b19f-41b3-b17c-de320d13bec8-18846868.jpg)\n\n- 缓存更新策略：\n\n  - 作用：节约内存、并解决数据不一致\n\n  - 缓存更新方法：\n\n    \n\n    - 内存淘汰：redis自动进行，当redis内存达到咱们设定的max-memery的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)\n\n    - 超时剔除：当我们给redis设置了过期时间ttl之后，redis会将超时的数据进行删除，方便咱们继续使用缓存\n\n    - 主动更新：我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题\n\n  - 数据库缓存不一致解决方案：缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案\n\n    - 删除缓存还是更新缓存：\n\n      - 更新缓存：每次更新数据库都更新缓存，无效写操作较多\n\n      - 删除缓存：更新数据库时让缓存失效，查询时再更新缓存\n\n    - 如何保证缓存与数据库的操作的同时成功或失败：\n\n      - 单体系统，将缓存与数据库操作放在一个事务\n\n      - 分布式系统，利用TCC等分布式事务方案\n\n    - 先操作缓存还是先操作数据库：![img](https://api2.mubu.com/v3/document_image/b834e59d-0f2f-4ae4-a39f-3f961c171f97-18846868.jpg)\n\n- 缓存更新步骤：\n\n  - 在更新方法添加：![img](https://api2.mubu.com/v3/document_image/6f370b17-7607-4661-80b7-529a2d48ba06-18846868.jpg)\n\n- 缓存穿透：数据库与redis都不存在数据\n\n  - 问题出现：缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库\n\n  - 解决方案：\n\n    - 缓存空对象\n\n      - 思路：当我们客户端访问不存在的数据时，先请求redis，但是此时redis中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如redis这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到redis中去，这样，下次用户过来访问这个不存在的数据，那么在redis中也能找到这个数据就不会进入到缓存了\n\n      - 优点：实现简单，维护方便\n\n      - 缺点：\n\n        - 额外的内存消耗\n\n        - 可能造成短期的不一致\n\n    - 布隆过滤\n\n      - 思路：布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，假设布隆过滤器判断这个数据不存在，则直接返回\n        - 这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突\n\n      - 优点：内存占用较少，没有多余key\n\n      - 缺点：\n\n        - 实现复杂\n\n        - 存在误判可能\n\n  - 解决步骤：\n\n    - 缓存空对象\n\n      - 1、定义方法![img](https://api2.mubu.com/v3/document_image/ea216ace-913e-4cf9-b56b-11c664f432d8-18846868.jpg)\n        public <R,ID> R queryWithPassThrough(\n                String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit){\n            String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存    String json = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在    if (StrUtil.isNotBlank(json)) {\n        // 3.存在，直接返回        return JSONUtil.toBean(json, type);\n            }\n        // 判断命中的是否是空值    if (json != null) {\n        // 返回一个错误信息        return null;\n            }\n        // 4.不存在，根据id查询数据库    R r = dbFallback.apply(id);\n        // 5.不存在，返回错误    if (r == null) {\n        // 将空值写入redis        stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES);\n        // 返回错误信息        return null;\n            }\n        // 6.存在，写入redis    this.set(key, r, time, unit);\n        return r;\n        }\n\n      - 2、调用方法![img](https://api2.mubu.com/v3/document_image/6b3d10e3-60a3-431a-b146-877aab3c78c8-18846868.jpg)\n\n  - 避免出现缓存穿透：\n\n    - 增强id的复杂度，避免被猜测id规律\n\n    - 做好数据的基础格式校验\n\n    - 加强用户权限校验\n\n    - 做好热点参数的限流\n\n- 缓存雪崩：大量的缓存key同时失效\n\n  - 问题出现：缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力\n\n  - 解决方案：\n\n    - 给不同的Key的TTL添加随机值\n\n    - 利用Redis集群提高服务的可用性\n\n    - 给缓存业务添加降级限流策略\n\n    - 给业务添加多级缓存\n\n- 缓存击穿：热点Key\n\n  - 问题出现：缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击\n\n    - 逻辑分析：假设线程1在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程1走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程1没有走完的时候，后续的线程2，线程3，线程4同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大![img](https://api2.mubu.com/v3/document_image/4c033c41-5d90-418b-861f-1a405569f518-18846868.jpg)\n\n  - 解决方案：\n\n    \n\n    - 互斥锁\n\n      \n\n      - 因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用tryLock方法 + double check来解决这样的问题。\n\n      - 假设现在线程1过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线程1就会一个人去执行逻辑，假设现在线程2过来，线程2在执行过程中，并没有获得到锁，那么线程2就可以进行到休眠，直到线程1把锁释放后，线程2获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。\n\n    - 逻辑过期\n\n      \n\n      - 之所以会出现这个缓存击穿问题，主要原因是在于对key设置了过期时间，假设不设置过期时间，就不会有缓存击穿的问题，但是不设置过期时间，这样数据就一直占用内存，可以采用逻辑过期方案\n\n      - 把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是后续通过逻辑去处理\n\n      - 假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个 线程去进行 以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。\n\n      - 这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。\n\n  - 解决步骤：\n\n    - 互斥锁\n\n      \n\n      - 定义方法：\n        public <R, ID> R queryWithMutex(\n                String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n            String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存    String shopJson = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在    if (StrUtil.isNotBlank(shopJson)) {\n        // 3.存在，直接返回        return JSONUtil.toBean(shopJson, type);\n            }\n        // 判断命中的是否是空值    if (shopJson != null) {\n        // 返回一个错误信息        return null;\n            }\n        // 4.实现缓存重建    // 4.1.获取互斥锁    String lockKey = LOCK_SHOP_KEY + id;\n        R r = null;\n        try {\n        boolean isLock = tryLock(lockKey);\n        // 4.2.判断是否获取成功        if (!isLock) {\n        // 4.3.获取锁失败，休眠并重试            Thread.sleep(50);\n        return queryWithMutex(keyPrefix, id, type, dbFallback, time, unit);\n                }\n        // 4.4.获取锁成功，根据id查询数据库        r = dbFallback.apply(id);\n        // 5.不存在，返回错误        if (r == null) {\n        // 将空值写入redis            stringRedisTemplate.opsForValue().set(key, \"\", CACHE_NULL_TTL, TimeUnit.MINUTES);\n        // 返回错误信息            return null;\n                }\n        // 6.存在，写入redis        this.set(key, r, time, unit);\n            } catch (InterruptedException e) {\n        throw new RuntimeException(e);\n            }finally {\n        // 7.释放锁        unlock(lockKey);\n            }\n        // 8.返回    return r;\n        }\n        private boolean tryLock(String key) {\n            Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, \"1\", 10, TimeUnit.SECONDS);\n        return BooleanUtil.isTrue(flag);\n        }\n        private void unlock(String key) {\n        stringRedisTemplate.delete(key);\n        }\n\n      - 调用方法：![img](https://api2.mubu.com/v3/document_image/510d45b7-60b7-4432-9a26-7a541aa96046-18846868.jpg)\n\n    - 逻辑过期\n\n      - 定义方法：\n        public <R, ID> R queryWithLogicalExpire(\n                String keyPrefix, ID id, Class<R> type, Function<ID, R> dbFallback, Long time, TimeUnit unit) {\n            String key = keyPrefix + id;\n        // 1.从redis查询商铺缓存\n            String json = stringRedisTemplate.opsForValue().get(key);\n        // 2.判断是否存在\n            if (StrUtil.isBlank(json)) {\n        // 3.存在，直接返回\n                return null;\n            }\n        // 4.命中，需要先把json反序列化为对象\n            RedisData redisData = JSONUtil.toBean(json, RedisData.class);\n        R r = JSONUtil.toBean((JSONObject) redisData.getData(), type);\n            LocalDateTime expireTime = redisData.getExpireTime();\n        // 5.判断是否过期\n            if(expireTime.isAfter(LocalDateTime.now())) {\n        // 5.1.未过期，直接返回店铺信息\n                return r;\n            }\n        // 5.2.已过期，需要缓存重建\n            // 6.缓存重建\n            // 6.1.获取互斥锁    String lockKey = LOCK_SHOP_KEY + id;\n        boolean isLock = tryLock(lockKey);\n        // 6.2.判断是否获取锁成功    if (isLock){\n        // 6.3.成功，开启独立线程，实现缓存重建        CACHE_REBUILD_EXECUTOR.submit(() -> {\n        try {\n        // 查询数据库                R newR = dbFallback.apply(id);\n        // 重建缓存                this.setWithLogicalExpire(key, newR, time, unit);\n                    } catch (Exception e) {\n        throw new RuntimeException(e);\n                    }finally {\n        // 释放锁                unlock(lockKey);\n                    }\n                });\n            }\n        // 6.4.返回过期的商铺信息    return r;\n        }',33,'Redis','redis',1,22,0,0,'2024-05-21 11:21:02','2024-05-21 11:21:02'),(20,'JVM之垃圾回收器','','http://114.132.41.159/admin/dist/img/rand/3.jpg','# 一、什么是垃圾回收器\n\n根据垃圾回收器这个名字我们可以知道，其主要作用是用来回收内存中已被判定无用的垃圾对象。但是垃圾回收器在扫描过程中，寻找并标记的其实是还在存活的对象。当查找完全部存活对象后将未标记的对象进行统一的回收。\n\n对于一个垃圾回收器,它其实主要需要完成三件事情\n\n分配内存：垃圾回收算法的设计往往决定了内存模型和内存分配的方式\n\n确保存活对象不会受到垃圾回收的影响\n\n回收垃圾对象\n\n## 二、垃圾回收器的分类\n\nJDK1到JDK13的发展历程中，一共出现了10种垃圾回收器：\n\n如上图中垃圾回收器之间存在连线，则表示他们可以搭配使用。\n每一种垃圾回收器都有各自的特点，没有最好的垃圾收集器，只有最适合的。我们可以根据他们之间不同的特点选择需要的垃圾回收器，甚至可以搭配使用，提升效率。\n\n针对不同的垃圾回收器的特点 有一个概念比较容易搞混\n\n## 并行，串行，并发之间的区别\n\n首先通过一个很简单的比喻区分并行和串行之间的区别：\n有一天小明要去银行注销掉一张许久不用的银行卡，因为这天是周六，银行办理业务的人非常多，大家需要通过排号系统按照不同的需求进行排队来办理自己的业务。\n\n## 那么什么是串行呢？？\n\n此时由于已经到中午12点，银行的业务人员大部分出去吃午饭了，此刻银行只开放了一个值班窗口，所有的人都要排队等候这一个值班窗口叫号。上一个办理业务的人如果没有办理完业务，下一个人需要一直等待。\n\n## 那什么叫并行呢？？\n\n过了午饭时间，银行因为工作人员的回归开放了其他的业务窗口，多个窗口可以在同一时间进行叫号并处理业务，虽然号码排在你前面的那个人的业务还没有处理完，但是随着其他窗口的空闲，你也能够被叫到号，这就是并行。\n\n那么最后一个问题就是什么叫做并发呢\n\n当排到你的时候，你突然想起要办理一张公积金联名卡，于是询问业务员是否可以在办理注销的同时申请一张新卡。业务员回答你由于他业务不熟练，无法做到办理注销的同时还能处理你申请新卡的业务，需要等办理注销结束后才能支持新卡的申请。这就是不支持并发，单次只能处理一种任务，无法做到通过任务排序分时执行不同的任务，达到并发。\n而如果此时是个熟练地业务员呢，他可以再你注销的同时帮你完成申请新卡的业务，有序的完成两个你交代的任务，同时处理，这就是支持并发。\n例子举得可能有些偏差，但是这三者之间的概念大致如此。\n\n## 1. Serial（串行收集器）\n\n特点：\n\n1.Serial只会使用一个CPU或者一条GC线程进行垃圾回收，并且在垃圾回收过程中暂停其他工作线程。是clinet模式的默认回收器。\n\n2.采用copy算法实现\n\n3.单核CPU效率最高，适合Clinet模式（应用内存小，不会创建太多对象，因此垃圾回收时间较短，即使停掉业务线程也不会感到明显的停顿）\n\n4.只有一条GC线程，避免了线程切换的开销\n\n\n## 2.ParNew\n\nParNew就是Serial的多线程版本\n\n特性\n\n1.ParNew由多条GC线程并行的进行垃圾清理工作，清理过程中需要停掉所有的业务线程，但由于是多线程运作，其效率要高于serial\n\n2.由于支持多线程运作，因此更适用于CPU较多的服务器环境。由于多线程之间的切换回造成额外的开销，因此在单CPU环境中表现并不如Serial。其默认开启线程数与CPU核数相同\n\n3.采用COPY算法实现\n\n## 3.Parallel Scavenge\n\n1.并行多线程回收器，常用于新生代，追求CPU吞吐量的优化，能在较短的时间内完成指定的任务，因此适合不需要太多交互的后台运算。\n\n吞吐量是指用户线程运行时间占CPU总时间的比例，其计算公式为：\n\n吞吐量=运行用户代码时间/（运行用户代码时间+GC的时间)\n\n吞吐量越高表示GC时间占比越低，用户体验越好\n\n## 2.采用复制算法实现\n\n（1）降低停顿时间的两种方式\n\n1.在多CPU环境中使用多条GC线程，从而垃圾回收的时间减小，从而使用户线程STW的时间减小。\n2.实现GC线程与用户线程并发运行，其所谓的并发指的其实是用户线程与GC线程交替运行，从而达到每次的停顿时间减小，用户的停顿感降低，单线程之间的不断切换也意味着需要额外的开销，从而垃圾回收和用户线程的总时间将会延长。\n\n（2）Parallel Scavenge提供的参数\n\n-XX:GCTimeRadio\n直接设置吞吐量大小,GC时间占总时间比率.相当于是吞吐量的倒数\n-XX:MaxGCPauseMillis\n设置最大GC停顿时间\n\nparallel 会根据这个值来决定新生代的大小，如果这个值越小，新生代就会越小，从而收集器就能以较短的时间来进行一次回收。\n\n-XX:+UseAdaptiveSizePolicy\n通过命令就能开启GC 自适应的调节策略(区别于ParNew).我们只要设置最大堆(-Xmx)和MaxGCPauseMillis或GCTimeRadio,收集器会自动调整新生代的大小、Eden和Survior的比例、对象进入老年代的年龄,以最大程度上接近我们设置的MaxGCPauseMillis或GCTimeRadio\n\n## 4.Serial Old\n\nSerial Old 收集器是Serial的老年代版本,他们都是单线程收集器,也就是垃圾收集时只启动一条GC线程,因此都适合客户端的应用,他们之间的主要区别其实就是Serial old常被用于老年代,其实现算法为mark-compact\n\n## 5.Parallel Old\n\nParallel Old 收集器是PS收集器的老年代版本,一般他们搭配使用,追求CPU的吞吐量。\n他们在垃圾手机时都是由多条GC线程并行执行，并暂停一切用户线程，使用mark-compact算法。\n\n## 6.CMS （concurrent mark sweep）\n\nCMS作用于老年代，是一种以获取最短停顿时间为目标的收集器。给予标记-清除算法实现。整个过程分为四步\n\n1.初始标记\n\n停止一切用户线程，因使用一条初始标记线程对所有与GC Roots关联的对象进行标记。\n2.并发标记\n\n使用多条并发标记线程并行执行，并与用户线程并发执行。此过程进行可达性分析，标记出所有废弃的对象，速度很慢。\n3.重新标记\n\n使用多条线程并行执行，将刚才并发过程中新出现的废弃对象标出来。\n4.并发清除\n\n使用一条并发清除线程，和业务线程并发执行，清除无用对象，这个过程非常耗时。\n\n\n\nCMS的特点\n\n吞吐量低\n\n由于CMS在垃圾收集过程使用用户线程和GC线程并发执行，从而线程之间切换会有额外的开销，因此CPU吞吐量就不如在业务线程全部通知的情况下高。\n无法处理浮动垃圾\n由于垃圾清理过程中，可能会产生浮动垃圾，当浮动垃圾过多时，可能会导致频繁的GC。\n浮动垃圾：在并发标记的情况下，GC线程标记对象未存活对象后用户线程不再会用此对象，该对象此时没有任何的引用，这种对象被称为浮动垃圾\n\n使用mark-sweep算法实现没会产生内存碎片\n可以通过开启-XX:+UseCMSCompactAtFullCollection参数是每次fgc后进行一次内存压缩。还可以配置-XX:CMSFullGCsBeforeCompaction告诉CMS经历多少次FGC后进行一次内存整理\n\n## 7.G1（GarBage-First）\n\nG1可以看做是CMS的加强版。G1的算法流程和CMS相似，其所不同的有：\n\n1.G1通过mark-compact算法实现，这意味着每次GC结束获得的都是连续的空间。\n\n2.G1虽然依旧采用了分代的处理方式，但是他的内存模型有了巨大的变化。他的内存基本结构被分成了一块又一块的Region。G1负责维护一个Region的列表。每次需要进行GC的时候，他首先会评估每个Region的回收价值，然后回收掉价值最大的Region，从而获得最大的GC回收效率。\n\n\n（1）G1的回收过程\n\n初始标记：\n\n标记与GC Root对象直接关联的对象，停止所有业务线程（STW），只启动一条初始标记线程，这个过程很快。\n\n并发标记：\n\n进行全面的可达性分析，开启一条并发标记线程记性有用对象标记，此线程与用户线程并行执行，这个过程较长。\n\n最终标记\n\n标记出并发标记过程中业务线程产生的浮动垃圾，停止所有业务线程（STW），执行多条最终标记线程。\n筛选回收\n回收无用对象，此时也是STW状态，使用多条筛选回收线程执行。\n\n（2）G1的特性\n\nCMS因为并发引起的问题G1同样也存在，但是G1可以避免因为Mark-Sweep算法引起的内存不连续问题。\nG1由于可以在用户指定时间范围内进行垃圾回收，所以具备软实时的特性。\n如上图，G1拥有一个特殊的区域叫做Humongous。\n什么事Humongous：如果一个对象占用的空间达到或者超过了分区大小的50%以上，G1收集器会认为这是一个巨型对象。这种巨型对象会被默认分配到老年代，但是如果这个巨型对象只会短期存在，就会影响G1的垃圾回收效率，为了解决这个问题，G1专门划分了Humongous区域来存放巨型对象，当一个Humongous区域存放不下一个巨型对象时，G1会寻找连续的H分区来存储，有时为了寻找连续的H区，不得不启动FULL GC。\n\n## 8.小结\n\n上述七种垃圾回收器中分别应用于不同的场景。其中Serial，parNew，parallel scavenger（PS）三种回收器作用于新生代，通过copy算法实现。其中Serial适合单核的Client端，ParNew适合多核服务器。而PS和ParNew类似，只不过更加注重吞吐量。另外，PS不能与CMS一起搭配使用。\nSerial Old,ParNew Old和CMS常用来针对老年代的回收。Serial Old 采用的都是Mark-Compact算法实现，而CMS使用的是Mark-Sweep算法，因此会产生内存碎片。\nG1是一个横跨新生代和老年代的处理器，他区别于上述回收器的分代模型的是采用了全新的分区模型。通过region的划分，每个区域都可以充当新生代或者老年代。G1采用的Mark-compact算法，不会产生内存碎片。',31,'JVM','垃圾回收器',1,27,0,0,'2024-05-22 15:42:39','2024-05-22 15:42:39'),(21,'不同版本JDK的区别','','http://114.132.41.159/admin/dist/img/rand/33.jpg','# JDK版本区别\n\n## JDK 8：\n\nLambda表达式：Lambda表达式允许以更简洁的方式表示匿名函数，这是JDK 8中最重要的新特性之一。\n\n新的日期API：JDK 8引入了新的日期和时间API，以改进旧的Date和Calendar类的不足。\n\nOptional类：Optional类是一个可以为null的容器对象，如果值存在则isPresent()方法返回true，调用get()方法会返回该对象。\n\nBase64编码/解码：JDK 8内置了对Base64编码的支持。\n\n\n接口的默认方法和静态方法：JDK 8允许在接口中添加默认方法和静态方法。\n\nStream API：Stream API允许以声明性方式处理数据集合，如过滤、映射、排序和聚合等。\n\n其他特性还包括方法引用、注解相关的改变等。\n\n## JDK 11：\n\n性能优化：JDK 11对JVM和线程调度进行了优化，使多线程程序在运行时更加高效。\n\nTLS 1.3支持：JDK 11引入了对TLS 1.3的支持，提高了网络传输数据的安全性。\n\n飞行记录器（JFR）：JDK 11将Java飞行记录器从Oracle JDK开源到了Open JDK，使其成为JDK 11的一部分。JFR是一种低开销的事件信息收集框架，用于对应用程序和JVM进行故障检查和分析。\n\n局部变量类型推断：JDK 11增强了局部变量类型推断的能力，允许在lambda表达式中使用var关键字来声明参数类型。\n\nHTTP Client API标准化：JDK 11标准化了Java 9中引入的HTTP Client API，并在Java 10中进行了更新，现在已完全支持异步非阻塞。\n\n## JDK 17：\n\nSwitch表达式新增匹配模式：JDK 17增强了switch表达式的功能，允许使用类型模式和守卫模式进行匹配。\n\n文本块：JDK 17引入了文本块（多行字符串字面量），使编写多行字符串更加简洁和易读。\n\n密封类（sealed class）：密封类是一种限制子类化的类，可以提高代码的可读性和可维护性。\n\n特定于上下文的反序列化过滤器：JDK 17提供了特定于上下文的反序列化过滤器，可以提高应用程序的安全性。\n\n其他新特性还包括增强的伪随机数生成器、对NullPointerExceptions的优化等。\n\n## JDK 21：\n\n虚拟线程（Virtual Threads）：JDK 21引入了虚拟线程的概念，也称为轻量级线程或纤程。虚拟线程可以极大地提高并发编程的效率和可伸缩性。\n\n字符串模板：JDK 21提供了更强大的字符串模板功能，可以方便地构建和格式化字符串。\n\n序列集合：JDK 21引入了序列集合的概念，可以方便地处理有序集合和映射。\n\n分代ZGC：JDK 21改进了垃圾回收机制，引入了分代ZGC（Z Garbage Collector），可以进一步提高应用程序的性能和响应速度。\n\n记录模式和switch模式匹配：JDK 21进一步扩展了JDK 17中的模式匹配功能，允许在记录类型和switch表达式中使用更复杂的模式匹配。\n\n\n# 发行区别\n\n| 名称                       | 作者    | 支持版本                  | 社区活跃度（github star） | 特性                                                         | 适用场景                             |\n| -------------------------- | ------- | ------------------------- | ------------------------- | ------------------------------------------------------------ | ------------------------------------ |\n| HotSpot (Oracle JDK版)     | Oracle  | 所有版本                  | 高(闭源)                  | 使用最广泛，稳定可靠，社区活跃JIT支持Oracle JDK默认虚拟机    | 默认                                 |\n| HotSpot (Open JDK版)       | Oracle  | 所有版本                  | 中(16.1k)                 | 同上开源，Open JDK默认虚拟机                                 | 默认对JDK有二次开发需求              |\n| GraalVM                    | Oracle  | 11, 17,19企业版支持8      | 高（18.7k）               | 多语言支持高性能、JIT、AOT支持                               | 微服务、云原生架构需要多语言混合编程 |\n| Dragonwell JDK龙井         | Alibaba | 标准版 8,11,17扩展版11,17 | 低(3.9k)                  | 基于OpenJDK的增强高性能、bug修复、安全性提升JWarmup、ElasticHeap、Wisp特性支持 | 电商、物流、金融领域对性能要求比较高 |\n| Eclipse OpenJ9 (原 IBM J9) | IBM     | 8,11,17,19,20             | 低(3.1k)                  | 高性能、可扩展JIT、AOT特性支持                               | 微服务、云原生架构                   |',28,'JAVA','jdk',1,47,0,0,'2024-05-22 17:10:26','2024-05-22 17:10:26'),(22,'GC类型','','http://114.132.41.159/admin/dist/img/rand/20.jpg','# 串行回收器（Serial Garbage Collector）：\n采用单线程进行垃圾回收，适合堆内存较小的场景。\n有Serial回收器和SerialOld回收器，前者采用复制算法对新生代进行垃圾回收，后者采用标记整理算法对老年代进行回收。\n在执行垃圾回收过程中会造成用户线程阻塞，也就是STW（Stop-The-World）问题。\n# 并行回收器（Parallel Garbage Collector）：\n也称为吞吐量优先回收器（Throughput Collector）。\n与串行回收器不同，它使用多线程进行垃圾回收，以加快垃圾回收的速度。\n有Paralle回收器和ParalleOld回收器，前者采用复制算法对新生代进行垃圾回收，后者采用标记整理算法对老年代进行回收。\n# 并发标记扫描回收器（CMS Garbage Collector）：\n主要目标是减少STW时间，使得垃圾回收时应用程序的响应速度更快。\n它使用标记-清除算法进行垃圾回收，并且会与用户线程并发执行。\n# G1回收器（G1 Garbage Collector）：\n适用于堆内存很大的情况。\n它将堆内存分割成不同的区域，并且并发地对其进行垃圾回收。\nG1也可以在回收内存之后对剩余的堆内存空间进行压缩。\n# Shenandoah GC\n这是Java中引入的一种新的GC，旨在解决CMS和G1中的一些问题。它试图在降低暂停时间的同时，保持高吞吐量。\n# ZGC\n这是Java 11中引入的一种低延迟垃圾收集器，它主要关注减少或消除STW（Stop-The-World）暂停时间。ZGC是并发的，并且可以与应用程序的线程同时运行。',31,'JVM','GC',1,16,0,0,'2024-05-24 15:04:16','2024-05-24 15:04:16'),(23,'字节码文件','','http://114.132.41.159/upload/20240524_17045715.jpg','# 组成\n\n### 基本信息\n\n##### 魔数\n\n四个字节、cafebabe、校验文件的类型\n\n##### 主副版本号\n\nJDK版本 = 主版本号 - 44 \n\n##### 访问标识\n\n标识是否是类、接口、注解、枚举等\n\n##### 类、父类、接口索引\n\n通过索引找到类、父类和接口信息\n\n### 常量池：\n\n保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用\n\n### 字段： \n\n当前类或接口声明的字段信息\n\n- 字节码中的字段指的是类或接口中声明的变量，用于存储对象的状态或数据。字段在字节码中用 `field_info` 结构表示，其中包含字段的名称、类型、访问标志等信息。字节码指令可以通过字段的名称或索引来读取或写入字段的值。\n- 字段表示类或接口中声明的变量，用于存储对象的状态或数据。\n\n### 方法\n\n当前类或接口声明的方法信息，核心内容为方法的字节码指令\n\n### 属性\n\n类的属性，比如源码的文件名、内部类的列表等\n\n- 字节码中的属性是一种用于附加额外信息于类、字段、方法或代码段的机制。属性在字节码中用 `attribute_info` 结构表示，常见的属性包括源文件信息、行号表、局部变量表、异常表等。属性提供了额外的元数据，用于调试、优化或其他用途。\n- 属性表示与类、字段、方法或代码段相关的附加信息。',31,'JVM','jvm',1,10,0,0,'2024-05-24 16:55:34','2024-05-24 16:55:34'),(24,'类加载器','','http://114.132.41.159/upload/20240524_17061927.jpg','# 类生命周期\n\n### 加载\n\n（1）根据类的全限定名通过不同的渠道以二进制流的方式获取字节码信息\n\n（2）类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到方法区中，方法区中生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息\n\n（3）Java虚拟机同时会在堆上生成与方法区中数据类似的java.lang.Class对象，作用是在Java代码中去获取类的信息以及存储静态字段的数据\n\n### 连接\n\n##### 	验证\n\n验证的主要目的是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与。\n\n##### 	准备\n\n为静态变量（static）分配内存并设置初值\n\n##### 	解析\n\n将常量池中的符号引用替换为直接引用\n\n### 初始化\n\n执行字节码文件中clinit（class init 类的初始化）方法的字节码指令，包含了静态代码块中的代码，并为静态变量赋值。\n\n### 使用\n\n包括方法调用、变量操作、控制流程等。类的实例化、调用静态方法等方式都是在这个阶段进行的\n\n### 卸载\n\n类实例的垃圾回收：当类的实例被垃圾回收器回收时，会标记该类实例为不再使用。\n\n类的引用计数为零：当类的所有实例都不再被引用时，类的引用计数为零。\n\n类的类加载器被回收：当类的类加载器不再被引用时，类的类加载器被回收。\n\n类的卸载：当类的引用计数为零且类的类加载器被回收时，JVM会卸载该类，释放类占用的内存。\n\n# 类加载器\n\n### 分类\n\n##### 启动类加载器\n\n由Hotspot虚拟机提供的、使用C++编写的类加载器、默认加载Java安装目录/jre/lib下的类文件\n\n##### 扩展类加载器\n\n使用Java编写的类加载器、默认加载Java安装目录/jre/lib/ext下的类文件\n\n##### 应用程序类加载器\n\n使用Java编写的类加载器、默认加载的是项目中的类以及通过maven引入的第三方jar包中的类\n\n### 双亲委派机制\n\n向上查找\n\n向下加载\n\n### 打破双亲委派机制\n\n自定义类加载器并且重写loadClass方法。Tomcat通过这种方式实现应用之间类隔离',31,'JVM','jvm',1,10,0,0,'2024-05-24 17:06:21','2024-05-24 17:06:21'),(25,'运行时数据区','','http://114.132.41.159/upload/20240527_16151097.jpg','# 程序计数器\n\n也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址。\n\n# 虚拟机栈\n\n### 栈帧：先进后出\n\n#### 局部变量表\n\n局部变量表的作用是在运行过程中存放所有的局部变量\n\n#### 操作数栈\n\n操作数栈是栈帧中虚拟机在执行指令过程中用来存放临时数据的一块区域\n\n#### 帧数据\n\n帧数据主要包含动态链接、方法出口、异常表的引用\n\n##### 动态链接\n\n当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系。\n\n##### 方法出口\n\n方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址。\n\n##### 异常表\n\n异常表存放的是代码中异常的处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。\n\n### 栈内存\n\n默认大小：2m\n\n设置大小：\n\n- 语法：-Xss栈大小\n- 单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)\n\n```Java\n-Xss1048576 \n-Xss1024K      \n-Xss1m\n-Xss1g\n```\n\n### 数据类型\n\nJava中的8大数据类型在虚拟机中的实现：\n\n\n### 栈中的数据要保存到堆上或者从堆中加载到栈上时怎么处理\n\n#### 堆中的数据加载到栈上\n\n由于栈上的空间大于或者等于堆上的空间，所以直接处理但是需要注意下符号位。\n\nboolean、char为无符号，低位复制，高位补0\n\nbyte、short为有符号，低位复制，高位非负则补0，负则补1\n\n#### 栈中的数据要保存到堆上\n\nbyte、char、short由于堆上存储空间较小，需要将高位去掉。boolean比较特殊，只取低位的最后一位保存。\n\n# 本地方法栈\n\n功能与服务对象：\n\n- 虚拟机栈（Virtual Machine Stack）：主要是为执行Java方法服务，是JVM执行Java方法时的工作区域，每个线程都拥有自己独立的虚拟机栈。每当一个Java方法被调用时，都会为该方法创建一个栈帧（Stack Frame），用于存储局部变量、操作数栈、动态链接和方法出口等信息。\n- 本地方法栈（Native Method Stack）：与虚拟机栈相似，但其服务的是Native方法（非Java编写的方法，如C/C++编写的方法）。当线程调用Native方法时，会进入本地方法栈。需要注意的是，本地方法栈并不是Java虚拟机规范的一部分，而是由具体实现来决定的。\n\n内存分配与共享：\n\n- 虚拟机栈：每个线程在创建时都会创建一个虚拟机栈，它是线程私有的，即不能实现线程间的共享。每个线程都只能访问自己的虚拟机栈中的栈帧。\n- 本地方法栈：同样地，本地方法栈也是线程私有的，与虚拟机栈类似，不同的线程在本地方法栈中不会有数据的共享。\n\n异常处理：\n\n- 当栈空间不足以存储新创建的栈帧时，或者尝试访问栈以外的内存时，两种栈都会抛出`StackOverflowError`异常。\n- 如果虚拟机栈或本地方法栈的扩展无法满足内存分配需求时，将会抛出`OutOfMemoryError`异常。\n\n实现与合并：\n\n- 在某些JVM实现中（如HotSpot VM），本地方法栈与虚拟机栈是合并实现的，这意味着Java方法和Native方法都使用同一个栈。但需要注意的是，这种合并实现并不改变两者在逻辑上的区别。\n\n性能与特点：\n\n- 虚拟机栈和本地方法栈都是由系统自动分配和释放的，它们的存储速度都相对较快，因为栈是机器系统提供的数据结构，计算机会在底层对栈提供分配和释放的支持。\n\n综上所述，虚拟机栈和本地方法栈的主要区别在于它们服务的方法和内存管理的细节上。虚拟机栈服务于Java方法，而本地方法栈服务于Native方法；两者都是线程私有的，不能共享；在异常处理和内存分配上，两者也有各自的特点。在某些JVM实现中，两者可能合并实现，但逻辑上仍然保持独立。\n\n# 堆\n\n一般Java程序中堆内存是空间最大的一块内存区域。创建出来的对象都存在于堆上。栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。\n\n#### 堆内存的溢出\n\n通过new关键字不停创建对象，放入集合中，模拟堆内存的溢出，观察堆溢出之后的异常信息。\n\n#### 三个重要的值\n\n堆空间有三个需要关注的值，used、total、max。used指的是当前已使用的堆内存，total是java虚拟机已经分配的可用堆内存，max是java虚拟机可以分配的最大堆内存。\n\n要修改堆的大小，可以使用虚拟机参数 –Xmx（max最大值）和-Xms (初始的total)。\n\n语法：`-Xmx值 -Xms值`\n\n单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)\n\n限制：Xmx必须大于 2 MB，Xms必须大于1MB\n\n```Java\n-Xms6291456\n-Xms6144k\n-Xms6m\n-Xmx83886080\n-Xmx81920k\n-Xmx80m\n```\n\n**建议：**\n\nJava服务端程序开发时，建议将-Xmx和-Xms设置为相同的值，这样在程序启动之后可使用的总内存就是最大内存，而无需向java虚拟机再次申请，减少了申请并分配内存时间上的开销，同时也不会出现内存过剩之后堆收缩的情况。-Xmx具体设置的值与实际的应用程序运行环境有关，在《实战篇》中会给出设置方案。\n\n### 对象\n\n\n对象头（Header）：\n\n- Mark Word：\n  - 锁信息：包括锁状态（如未锁定状态、偏向锁状态、轻量级锁状态、重量级锁状态）和锁标志（如是否启用偏向锁、是否启用自旋等）。\n  - 对象的哈希码：在某些JVM实现中，哈希码存储在Mark Word中。\n  - GC标志：用于标记对象的垃圾回收状态，如对象是否被标记为垃圾，是否经过了写屏障等。\n- 类型指针（Klass Pointer）：指向对象的类元数据的地址，即对象的类型信息。\n\n实例数据（Instance Data）：\n\n- 实例数据存放一个对象中的其他信息，即类中声明的成员变量（包括从父类继承的和本类定义的）。\n\n对齐填充（Padding）：\n\n- 用于保证对象占用内存空间的整数倍，以达到空间存储的优化。对齐填充并不是JVM对象内容必须的部分，而是为了保证JVM空间管理上的性能。\n\n### 锁状态\n\n1. 无锁状态（Unlocked）\n   - 对象的初始状态，没有任何线程持有该对象的锁。\n   - 在Mark Word中，偏向锁位与锁标志位合起来表示为“001”。\n2. 偏向锁状态（Biased Locking）\n   - 当一个线程首次访问某个同步代码块并获取锁时，JVM会尝试将锁偏向给这个线程，以减少CAS（Compare-And-Swap）操作，从而提高性能。\n   - 在Mark Word中，偏向锁位与锁标志位合起来表示为“101”。\n   - 如果后续没有其他线程竞争该锁，持有偏向锁的线程将一直执行，无需再次进行同步判断。\n3. 轻量级锁状态（Lightweight Locking）\n   - 当有另外一个线程参与锁竞争时，偏向锁会升级为轻量级锁。\n   - 轻量级锁通过自旋（Spinning）的方式尝试获取锁，避免线程挂起和恢复的开销。\n   - 如果自旋成功，则获得锁；如果自旋失败，则升级为重量级锁。\n4. 重量级锁状态（Heavyweight Locking）\n   - 当多个线程同时竞争锁时，轻量级锁会升级为重量级锁。\n   - 重量级锁通过让未获得锁的线程阻塞（Blocking）来等待锁的释放，从而保证线程安全。\n   - 重量级锁的开销较大，因为它涉及线程的挂起和恢复操作。\n\n### 锁标志\n\n1. 是否启用偏向锁（Biased Locking Enabled）\n   - JVM的一个配置选项，用于决定是否启用偏向锁。\n   - 如果启用，则当线程首次访问某个同步代码块时，会尝试将锁偏向给该线程。\n2. 是否启用自旋（Spinning Enabled）\n   - 与轻量级锁相关的一个配置选项，用于决定是否启用自旋机制。\n   - 如果启用，则当线程尝试获取轻量级锁失败时，会进行自旋操作，等待锁的释放。\n   - 自旋的次数和持续时间可以通过JVM参数进行配置。\n\n\n### 元数据的指针\n\nKlass pointer元数据的指针指向方法区中保存的InstanceKlass对象：\n\n\n### 指针压缩\n\nJVM（Java Virtual Machine）的指针压缩（CompressedOops）技术主要用于64位JVM环境中，以优化内存使用和垃圾收集（GC）性能。在64位JVM中，每个native指针通常占用8个字节，这会导致内存占用增加和GC停顿时间变长。为了解决这个问题，JVM引入了指针压缩技术。\n\n指针压缩的原理是利用Java对象通常是对齐的这一特点。由于对象对齐，大多数对象的偏移量是可以预测的。因此，JVM可以使用对象的偏移量来计算对象的地址，而不必使用完整的指针。在64位JVM中，压缩指针可以将64位指针压缩为32位，这意味着每个指针只需要占用4字节的内存空间。这样，JVM可以使用较小的指针来定位对象，从而节省了堆内存的使用量。\n\n具体来说，当堆内存小于32GB时，压缩指针是有效的。在压缩过程中，JVM将堆的基地址和对象的偏移量分开存储。偏移量被除以8后保存到32位地址中，而基地址则保存在JVM的内部数据结构中。当需要访问对象时，JVM使用基地址和32位偏移量来重新计算完整的64位地址。\n\n启用指针压缩后，JVM会压缩以下类型的指针：\n\n1. 每个Class的属性指针（静态成员变量）\n2. 每个对象的属性指针\n3. 普通对象数组的每个元素指针\n\n然而，压缩指针并不是万能的。对于某些特殊类型的指针，如指向PermGen的Class对象指针、本地变量、堆栈元素、入参、返回值和NULL指针，JVM不会进行优化。\n\n需要注意的是，当堆内存大于32GB时，压缩指针会失效，JVM将强制使用64位指针来寻址Java对象。此外，在64位平台的HotSpot JVM中使用32位指针（实际存储用64位）时，内存使用会多出1.5倍左右。这是因为较大的指针在主内存和缓存之间移动数据时需要占用更多的带宽，同时GC也会承受更大的压力。因此，在配置JVM堆内存时，应谨慎选择以避免过大的堆内存导致性能下降。\n\n#### 32G原因\n\n1. **寻址空间**：当堆内存达到32GB（即2的35次方字节，因为JVM的堆内存通常是以8字节对齐的）时，32位的压缩指针就无法再有效地寻址整个堆内存空间了。32位指针的最大寻址空间是2的32次方字节，即4GB。因此，当堆内存超过这个范围时，JVM就需要使用完整的64位指针来确保能够访问堆中的每一个对象。\n2. **内存对齐**：Java对象在内存中通常是按照8字节对齐的。这意味着对象在内存中的起始地址是8的倍数。在32位指针压缩的情况下，JVM通过一定的算法和技巧来管理和使用这些地址。但是，当堆内存超过32GB时，这些算法和技巧就不再适用，因为32位指针无法直接表示所有的对齐地址。\n\n\n\n### 总结\n\nJava中的锁状态和锁标志是JVM为了提高并发性能和降低锁竞争开销而引入的机制。通过合理地配置和使用这些机制，可以优化多线程应用程序的性能。需要注意的是，这些机制的实现细节可能会因JVM版本和配置的不同而有所差异。\n\n# 方法区\n\n类的元信息，保存了所有类的基本信息\n\n运行时常量池，保存了字节码文件中的常量池内容\n\n字符串常量池，保存了字符串常量\n\n\n\n# 直接内存\n\n在 JDK 1.4 中引入了 NIO 机制，使用了直接内存，主要为了解决以下两个问题:\n\n1、Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。\n\n2、IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。\n\n现在直接放入直接内存即可，同时Java堆上维护直接内存的引用，减少了数据复制的开销。写文件也是类似的思路。\n\n使用堆创建对象的过程：\n\n\n使用直接内存创建对象的过程，不需要进行复制对象，数据直接存放在直接内存中：\n\n\n### 使用方法：\n\n要创建直接内存上的数据，可以使用`ByteBuffer`。\n\n语法： `ByteBuffer directBuffer = ByteBuffer.allocateDirect(size);`\n\n注意事项： arthas的memory命令可以查看直接内存大小，属性名direct。\n\n\n### 设置内存\n\n将 直接内存大小设置为 1024 KB：\n\n```Java\n-XX:MaxDirectMemorySize=1m\n-XX:MaxDirectMemorySize=1024k\n-XX:MaxDirectMemorySize=1048576\n```\n\n\n\n# 不同版本区别\n![](http://114.132.41.159/upload/20240527_16142136.png)\n#### JDK8之后\n\n静态变量移到元空间\n\n字符串常量池仍在堆区',31,'JVM','jvm',1,19,0,0,'2024-05-27 16:15:13','2024-05-27 16:15:13'),(26,'对象的访问定位的两种方式','','http://114.132.41.159/upload/20240528_01291320.jpg','Java 程序通过栈上的引用数据来操作堆上的具体对象。\n目前主流的对象访问方式有：句柄 和 直接指针。\n\n# 1. 使用句柄\n如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，引用中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。\n\n# 2. 直接指针\n如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象的地址。\n\n# 各自的优点\n\n1、 使用句柄来访问的最大好处是引用中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而引用本身不需要修改；\n\n2、使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。',31,'JVM','jvm问题',1,21,0,0,'2024-05-28 01:29:16','2024-05-28 01:29:16'),(27,'垃圾回收是从哪里开始的','','http://114.132.41.159/upload/20240528_01352733.jpg','查找哪些对象是正在被当前系统使用的。上面分析的堆和栈的区别，其中栈是真正进行程序执行地方，所以要获取哪些对象正在被使用，则需要从 Java 栈开始。同时，一个栈是与一个线程对应的，因此，如果有多个线程的话，则必须对这些线程对应的所有的栈进行检查。\n\n\n同时，除了栈外，还有系统运行时的寄存器等，也是存储程序运行数据的。这样，以栈或寄存器中的引用为起点，我们可以找到堆中的对象，又从这些对象找到对堆中其他对象的引用，这种引用逐步扩展，最终以 null 引用或者基本类型结束，这样就形成了一颗以 Java 栈中引用所对应的对象为根节点的一颗对象树。如果栈中有多个引用，则最终会形成多颗对象树。在这些对象树上的对象，都是当前系统运行所需要的对象，不能被垃圾回收。而其他剩余对象，则可以视为无法被引用到的对象，可以被当做垃圾进行回收。',31,'JVM','jvm问题',1,15,0,0,'2024-05-28 01:35:29','2024-05-28 01:35:29'),(28,'垃圾回收机制全过程','','http://114.132.41.159/upload/20240528_01425652.jpg','## 1、标记（Marking）：\n\n在标记阶段，垃圾回收器会从根对象开始，通过可达性分析算法遍历对象图，标记所有可以被访问到的对象。根对象通常是指应用程序中的静态变量、线程栈中的变量以及常量池中的对象等。垃圾回收器会递归地访问对象，并标记其为“存活”对象。如果一个对象无法通过任何途径与根对象连接，那么该对象就会被标记为“非存活”对象。\n\n## 2、清除（Sweeping）：\n\n在清除阶段，垃圾回收器会扫描整个堆，回收所有未被标记为“存活”的对象所占用的内存空间。这些未被标记的对象将被认定为垃圾，其所占用的内存将被释放。这样，堆中就会腾出一些空闲的内存空间，以便后续的对象分配使用。\n\n## 3、整理（Compacting，可选）：\n\n在某些垃圾回收算法中，还会包括内存整理的过程。在整理阶段，垃圾回收器会对存活的对象进行整理，将它们向堆的一端移动，从而释放出更多的连续内存空间。这有助于减少内存碎片化，并提高堆内存的利用率和分配效率。',31,'JVM','jvm问题',1,35,0,0,'2024-05-28 01:42:57','2024-05-28 01:42:57'),(29,'链式调用','','http://liyiru.site/upload/20240528_19173217.jpg','在Java中，链式调用（Chaining）是一种常见的设计模式，它允许你在一个对象上连续调用多个方法，而无需在每次调用后都返回一个新的对象。这通常是通过在每个方法结束时返回this（即当前对象）来实现的。\n\n### 不使用注解\n\n```java\npublic class Person {  \n    private String name;  \n    private int age;  \n  \n    // 构造方法  \n    public Person(String name, int age) {  \n        this.name = name;  \n        this.age = age;  \n    }  \n  \n    // setName方法，返回当前对象（this）以支持链式调用  \n    public Person setName(String name) {  \n        this.name = name;  \n        return this;  \n    }  \n  \n    // setAge方法，同样返回当前对象（this）  \n    public Person setAge(int age) {  \n        this.age = age;  \n        return this;  \n    }  \n  \n    // 其他方法...  \n  \n    // toString方法，用于打印Person对象的详细信息  \n    @Override  \n    public String toString() {  \n        return \"Person{\" +  \n                \"name=\'\" + name + \'\\\'\' +  \n                \", age=\" + age +  \n                \'}\';  \n    }  \n  \n    public static void main(String[] args) {  \n        // 使用链式调用设置Person对象的属性  \n        Person person = new Person(\"\", 0)  \n                .setName(\"Alice\")  \n                .setAge(30);  \n  \n        // 打印Person对象的详细信息  \n        System.out.println(person);  \n    }  \n}\n```\n\n### 使用注解\n\n    import lombok.Accessors;  \n    import lombok.AllArgsConstructor;  \n    import lombok.Data;  \n    import lombok.NoArgsConstructor;  \n      \n    @AllArgsConstructor  \n    @NoArgsConstructor  \n    @Data  \n    @Accessors(chain = true) // 开启链式调用  \n    class Student {  \n        private Integer id;  \n        private String studentName;  \n        private String major;  \n    }  \n      \n    public class Main {  \n        public static void main(String[] args) {  \n            // 使用链式调用创建并设置Student对象  \n            Student student = new Student()  \n                    .setId(1)  \n                    .setStudentName(\"Alice\")  \n                    .setMajor(\"Computer Science\");  \n      \n            // 打印Student对象的详细信息  \n            System.out.println(student);  \n        }  \n    }',28,'JAVA','java',1,27,0,0,'2024-05-28 19:17:33','2024-05-28 19:17:33'),(30,'函数式编程','','http://liyiru.site/upload/20240528_19302934.jpg','函数式编程：Lambda表达式+Stream流式调用+Chain链式调用+Java8函数式接口\n\n**Lambda表达式**\n\n\n\n    (parameters) -> expression  \n    或  \n    (parameters) -> { statements; }\n\nparameters：这是Lambda表达式的参数列表。类型可以从上下文推断出来，所以通常可以省略。\n\n->：这是Lambda操作符，它分隔了参数列表和Lambda体。\n\nexpression 或 { statements; }：这是Lambda体，可以是一个表达式（返回该表达式的值）或是一个语句块（包含多条语句）。\n\n**Stream流式调用**\n\n\n\n    import java.util.Arrays;  \n    import java.util.List;  \n    import java.util.function.Function;  \n    import java.util.stream.Collectors;  \n      \n    public class FunctionalProgrammingExample {  \n      \n        public static void main(String[] args) {  \n            // 创建一个整数列表  \n            List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);  \n      \n            // 使用Stream API和Lambda表达式来过滤偶数并计算它们的平方和  \n            int sumOfSquaresOfEvens = numbers.stream()  \n                    .filter(n -> n % 2 == 0) // 过滤偶数  \n                    .map(n -> n * n) // 计算平方  \n                    .mapToInt(Integer::intValue) // 转换为int流以便求和  \n                    .sum(); // 计算总和  \n      \n            // 输出结果  \n            System.out.println(\"Sum of squares of even numbers: \" + sumOfSquaresOfEvens);  \n      \n            // 使用Function接口和链式调用来转换列表中的每个元素  \n            List<String> strings = numbers.stream()  \n                    .map(String::valueOf) // 将每个整数转换为字符串  \n                    .collect(Collectors.toList()); // 收集到新的列表中  \n      \n            // 输出结果  \n            System.out.println(\"List of string representations: \" + strings);  \n      \n            // 使用Consumer接口来处理列表中的每个元素  \n            numbers.forEach(n -> System.out.print(n + \" \")); // 打印每个元素  \n            System.out.println(); // 换行  \n      \n            // 使用Supplier接口来生成一个值  \n            Supplier<Integer> randomNumberGenerator = () -> (int) (Math.random() * 100);  \n            int randomNumber = randomNumberGenerator.get(); // 获取随机生成的整数  \n      \n            // 输出结果  \n            System.out.println(\"Random number: \" + randomNumber);  \n        }  \n    }\n\n**Chain链式调用**\n\n[http://liyiru.site/blog/29](http://liyiru.site/blog/29 \"http://liyiru.site/blog/29\")\n\n**函数式接口：**\n\n- Runnable：无参数、无返回值\n\n\n- Function：接受一个参数，并且有返回值\n\n\n- Consumer：接受一个参数，没有返回值\n\n\n- BiConsumer：接受两个参数，没有返回值\n\n\n- Supplier：没有参数，有返回值\n\n# 案例\n\n    package com.bilibili.juc.cf;\n    \n    import lombok.*;\n    import lombok.experimental.Accessors;\n    \n    import java.awt.print.Book;\n    import java.math.BigDecimal;\n    import java.util.ArrayList;\n    import java.util.Arrays;\n    import java.util.List;\n    import java.util.concurrent.CompletableFuture;\n    import java.util.concurrent.ExecutionException;\n    import java.util.concurrent.ThreadLocalRandom;\n    import java.util.concurrent.TimeUnit;\n    import java.util.stream.Collectors;\n    \n    /**\n     *\n     * 案例说明：电商比价需求，模拟如下情况：\n     *\n     * 1需求：\n     *  1.1 同一款产品，同时搜索出同款产品在各大电商平台的售价;\n     *  1.2 同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少\n     *\n     * 2输出：出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<String>\n     * 《mysql》 in jd price is 88.05\n     * 《mysql》 in dangdang price is 86.11\n     * 《mysql》 in taobao price is 90.43\n     *\n     * 3 技术要求\n     *   3.1 函数式编程\n     *   3.2 链式编程\n     *   3.3 Stream流式计算\n     */\n    public class CompletableFutureMallDemo\n    {\n        static List<NetMall> list = Arrays.asList(\n                new NetMall(\"jd\"),\n                new NetMall(\"dangdang\"),\n                new NetMall(\"taobao\"),\n                new NetMall(\"pdd\"),\n                new NetMall(\"tmall\")\n        );\n    \n        /**\n         * step by step 一家家搜查\n         * List<NetMall> ----->map------> List<String>\n         * @param list\n         * @param productName\n         * @return\n         */\n        public static List<String> getPrice(List<NetMall> list,String productName)\n        {\n            //《mysql》 in taobao price is 90.43\n            return list\n                    .stream()\n                    .map(netMall ->\n                            String.format(productName + \" in %s price is %.2f\",\n                                    netMall.getNetMallName(),\n                                    netMall.calcPrice(productName)))\n                    .collect(Collectors.toList());\n        }\n    \n        /**\n         * List<NetMall> ----->List<CompletableFuture<String>>------> List<String>\n         * @param list\n         * @param productName\n         * @return\n         */\n        public static List<String> getPriceByCompletableFuture(List<NetMall> list,String productName)\n        {\n            return list.stream()\n                    .map(\n                        netMall ->\n                        CompletableFuture.supplyAsync(() -> String.format(productName + \" in %s price is %.2f\",\n                        netMall.getNetMallName(),\n                        netMall.calcPrice(productName)))\n                    )\n                    .collect(\n                        Collectors.toList()\n                    )\n                    .stream()\n                    .map(\n                        s -> s.join()\n                    )\n                    .collect(\n                        Collectors.toList()\n                    );\n        }\n    \n    \n        public static void main(String[] args)\n        {\n            long startTime = System.currentTimeMillis();\n    \n            List<String> list1 = getPrice(list, \"mysql\");\n            for (String element : list1) {\n                System.out.println(element);\n            }\n            long endTime = System.currentTimeMillis();\n            System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\");\n    \n            System.out.println(\"--------------------\");\n    \n            long startTime2 = System.currentTimeMillis();\n            List<String> list2 = getPriceByCompletableFuture(list, \"mysql\");\n            for (String element : list2) {\n                System.out.println(element);\n            }\n            long endTime2 = System.currentTimeMillis();\n            System.out.println(\"----costTime: \"+(endTime2 - startTime2) +\" 毫秒\");\n        }\n    }\n    \n    class NetMall\n    {\n        @Getter\n        private String netMallName;\n    \n        public NetMall(String netMallName)\n        {\n            this.netMallName = netMallName;\n        }\n    \n        public double calcPrice(String productName)\n        {\n            try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\n    \n            return ThreadLocalRandom.current().nextDouble() * 2 + productName.charAt(0);\n        }\n    }',28,'JAVA','java',1,28,0,0,'2024-05-28 19:30:30','2024-05-28 19:30:30'),(31,'流处理','','http://liyiru.site/upload/20240528_19523192.jpg','流处理\n    步骤：\n        1.流对象获取数据\n            Stream<>  stream=***.stream()\n\n        2.操作处理\n            stream=stream.filter(......)\n\n        3.流对象封装回数据\n            T t=stream.collect(Collectors.to..)\n\n\n    Stream接口（转为流，并进行流处理）\n        意义：将数据转为流来处理，操作处理数据，收集流\n        方法\n\n    Optional类（存储数据）\n        概要：\n            Optional是final类\n            对象为null会报错，可以设置默认值\n            存在一个values值保存具体值（final修饰），一个对象只能保存一个具体值\n\n        方法：\n            创建Optional\n                有值：\n                    返回对象：.of(value)\n                    返回值非空对象：.ofNullable(value)\n\n                无值：\n                    .empty()\n\n\n            设置默认值\n                orElse(默认值)\n\n            返回values\n                get()\n\n            判断条件\n                filter：符合条件返回实例\n\n            判断null\n                isPewsent()\n                    非空返回true\n                    空返回false\n\n\n\n\n    Collectors类（操作数据）\n        方法\n\n    应用\n        归集（将流转换为集合）\n            （集合）List,Set,ArrayList\n            （数组）Array\n\n        聚合（获取流中特殊值）\n            //最大值\n                Collectors.maxBy();\n\n            //最小值\n                Collectors.minBy();\n\n            //总和\n                Collectors.summingInt();\n                Collectors.summingDouble();\n                Collectors.summingLong();\n\n            //平均值\n                Collectors.averagingInt();\n                Collectors.averagingDouble();\n                Collectors.averagingLong();\n\n            //总个数\n                Collectors.counting();\n\n\n        分组（根据属性分组）\n            //接收一个 Function 参数\n                groupingBy(Function classifier)\n\n            //接收两个参数: 1.Function 参数  2.Collector多级分组\n                groupingBy(Function classifier,Collector downstream) \n\n\n        分区（只有两个分区，true/false）\n            概要\n            //1.一个参数\n                partitioningBy(Predicate predicate)\n                Map<Boolean, List<Student>> partitionMap = studentStream.collect(Collectors.partitioningBy(s -> s.getScore() > 60));\n\n            //2.两个参数(多级分区)\n                partitioningBy(Predicate predicate, Collector downstream)\n\n\n        拼接（把元素按一定条件拼接）\n            //无参数--等价于 joining(\"\");\n                joining()\n\n            //一个参数\n                joining(CharSequence delimiter)\n\n            //三个参数(前缀+后缀)\n                joining(CharSequence delimiter, CharSequence prefix,CharSequence suffix)\n\n\n        数据过滤(筛选数据)\n            filter\n                stream.filter(n->n%2==1)\n\n            distinct\n                过滤\n\n            limit\n                获取前n个元素\n                limit(n);\n\n            skip\n                忽略前n个元素\n                skip(n)\n\n\n        数据映射(获取新对象)\n            Stream<>  stream2=stream1.map()\n                获取具体数据（新流对象可能与旧流对象元素类型不同）\n\n\n        数据查找(查找符合条件信息)\n            概要：\n                返回值为boolean或者Optional\n\n            allMatch\n                判断流中全部元素是否符合同一条件\n\n            anyMatch\n                判断流中是否有元素符合条件\n\n            noneMatch\n                判断流中是否所有元素不符合条件\n\n            findFirst\n                获取第一个满足条件的元素\n\n\n        数据收集(过滤+映射)\n            数据统计   stream.collect(Collectors.xxx\n                数目：counting()\n                最大数：maxBy(Comparator.comparing(类名::属性))\n                最小数：maxBy(Comparator.comparing(类名::属性))\n                和：summingXXX(类名::属性)\n                返回各数据：summarizingdouble(类名::属性)\n\n            数据分组\n                一级分组\n                    分组：Map<String,List> map  =  stream.collect(Collectors.groupingBy(类名::属性))\n                    获取组：List list=map.get(某分类名字)\n                    遍历list来遍历一个组元素\n\n                多级分组\n                    分组Map<String,Map<String,List>> map  =  stream.collect(Collectors.groupingBy(类名::属性,groupingBy(类名::属性)))\n                    获取组\n                        Map<String,List> map1  =map.get(某分类名)',28,'JAVA','java',1,1,0,1,'2024-05-28 19:52:32','2024-05-28 19:52:32'),(32,'流处理','','http://liyiru.site/upload/20240528_20390274.jpg','# 介绍\n\n### 流处理\n\nJava 流处理（Stream Processing）在 Java 8 及之后的版本中是一个核心概念，它允许我们以声明性方式处理数据集合（如列表、集合等）。通过使用流（`Stream`），我们可以对集合中的元素执行复杂的查询和操作，而无需修改原始数据结构。流处理提供了一种更加简洁、易读和高效的方式来处理集合数据。\n\nJava 中的流是数据序列的抽象表示，它允许我们进行一系列的操作，如过滤（`filter`）、映射（`map`）、排序（`sorted`）、归约（`reduce`）等，这些操作可以通过链式调用组合在一起，形成一个流管道（pipeline）。流处理的过程是惰性的（lazy），即只有当我们需要结果时（如调用 `collect` 方法），流上的操作才会被执行。\n\n### Java 流处理的关键点和特点：\n\n1. **声明性**：通过流，我们可以使用声明性语法来描述数据转换和操作，而无需编写复杂的循环和条件语句。\n2. **函数式编程**：流操作通常使用 Lambda 表达式或方法引用来定义，这符合函数式编程的风格。\n3. **惰性求值**：流操作是惰性的，这意味着它们不会立即执行。只有当需要结果时（如调用 `collect`、`findFirst` 等终端操作），流上的操作才会被执行。\n4. **内部迭代**：与传统的外部迭代（使用循环）不同，流处理使用内部迭代来遍历集合中的元素。这意味着迭代逻辑被封装在流操作中，我们无需关心具体的迭代过程。\n5. **并行处理**：流支持并行处理，可以自动将数据划分为多个部分并在多个线程上并行执行操作。这可以显著提高处理大型数据集的性能。\n\n### 使用流处理而不使用遍历\n\n1. **简洁性和可读性**：流处理提供了一种更为简洁和优雅的方式来操作集合数据，通过链式操作可以清晰地表达数据的处理流程，使得代码更加简洁和易读。\n2. **函数式编程思想**：流处理借鉴了函数式编程的思想，鼓励使用函数式接口、Lambda 表达式等来处理数据。这种编程范式使得代码更为简洁、可读，同时也更容易并行化和优化。\n3. **延迟计算**：流处理中的中间操作是延迟执行的，只有在遇到终端操作时才会触发实际的计算。这种延迟计算的机制可以提高性能，同时也可以节省内存和资源。\n4. **并行处理**：流处理提供了并行流的支持，可以轻松地将流操作并行化，充分利用多核处理器的优势来加速数据处理。这在处理大量数据时尤为重要。\n5. **错误减少**：由于流处理提供了一系列的中间操作和终端操作，开发者可以更加集中地处理数据的流动和转换，减少了出错的可能性，提高了代码的可靠性和稳定性。\n6. **适应性**：流处理提供了丰富的中间操作和终端操作，可以满足各种不同的需求，例如过滤、映射、排序、聚合等，同时也支持自定义操作，具有较高的适应性和灵活性。\n\n# Stream 类\n\n- `Stream` 类提供了对集合进行流式操作的功能，它允许在一组数据上进行一系列的中间操作和终端操作。\n- 中间操作可以是过滤、映射、排序等操作，它们不会触发实际的计算，只是在流上构建操作链。\n- 终端操作会触发流的处理，例如 forEach、collect、reduce 等。\n- Stream 的使用可以大大简化集合数据的处理，使代码更加清晰和易读。\n\n## 基本使用步骤\n\n```\n0.创建集合\n\n1.流对象获取数据\n\nStream<>  stream=集合对象.stream()\n\n2.操作处理\n\nstream=stream.filter(......)\n\n3.流对象封装回数据\n\nT t=stream.collect(Collectors.to..)\n```\n\n\n\n### 初始操作（转为stream）\n\n1. **集合（Collections）**：Java 中的集合类都可以通过 `stream()` 方法转换为 Stream 对象，例如 List、Set、Map 等。\n\n   ```\n    List<String> list = Arrays.asList(\"a\", \"b\", \"c\");\n   Stream<String> stream = list.stream();\n   ```\n\n2. **数组（Arrays）**：可以通过 `Arrays.stream()` 方法将数组转换为 Stream 对象。\n\n   ```\n   int[] array = {1, 2, 3, 4, 5};\n   IntStream stream = Arrays.stream(array);\n   ```\n\n3. **IO 流（IO Streams）**：Java 中的 IO 流也可以被转换为 Stream 对象，例如 BufferedReader 的 `lines()` 方法返回的就是一个 Stream 对象。\n\n   ```\n   BufferedReader reader = new BufferedReader(new FileReader(\"file.txt\"));\n   Stream<String> lines = reader.lines();\n   ```\n\n4. **数值范围（Numeric Ranges）**：可以使用 `IntStream.range()`、`LongStream.range()` 等方法创建一个数值范围的 Stream 对象。\n\n   ```\n    IntStream range = IntStream.range(1, 10); // 1 到 9\n   ```\n\n5. **其他数据源（Other Sources）**：Java 8 中还引入了一些其他方式创建 Stream 对象的方法，如 `Stream.of()`、`Stream.iterate()` 等。\n\n   ```\n   Stream<String> stream = Stream.of(\"a\", \"b\", \"c\");\n   Stream<Integer> stream = Stream.iterate(0, n -> n + 1).limit(10); // 从0开始，每次加1，限制长度为10\n   ```\n\n### 中间操作（过滤）\n\n#### 方法\n\n- `filter(Predicate<? super T> predicate)`: 保留满足给定条件的元素。\n- `map(Function<? super T, ? extends R> mapper)`: 对流中的每个元素应用函数。\n- `flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)`: 将流中的每个元素映射为一个流，然后将所有流连接成一个流。\n- `distinct()`: 返回一个元素唯一的流（根据元素的 `hashCode` 和 `equals` 方法）。\n- `sorted()`: 返回一个排序后的流（自然顺序）。\n- `sorted(Comparator<? super T> comparator)`: 返回一个根据指定比较器排序的流。\n- `peek(Consumer<? super T> action)`: 对流中的每个元素执行给定的操作，然后返回流本身。这主要用于调试目的。\n- `limit(long maxSize)`: 截断流，使其包含不超过给定数量的元素。\n- `skip(long n)`: 跳过流中的前 n 个元素。\n\n#### 案例\n\n```\nmap(Function mapper)：将流中的每个元素都映射成另一个元素。\nstream.map(x -> x * 2)\n\nfilter(Predicate predicate)：根据指定条件过滤流中的元素。\nstream.filter(x -> x > 0)\n\nsorted() / sorted(Comparator comparator)：对流中的元素进行排序，默认是自然顺序，也可以指定自定义排序规则。\nstream.sorted()\nstream.sorted((a, b) -> b.compareTo(a)) // 逆序排序\n\ndistinct()：去除流中的重复元素。\nstream.distinct()\n\nlimit(long maxSize)：限制流中元素的数量。\nstream.limit(10)\n\nskip(long n)：跳过流中的前n个元素。\nstream.skip(5)\n\nflatMap(Function mapper)：将流中的每个元素映射成一个流，然后将所有流连接成一个流。\nstream.flatMap(List::stream)\n```\n\n\n\n### 终端操作（返回结果）\n\n#### 方法\n\n1. **forEach(Consumer action)**：对流中的每个元素执行指定操作。\n\n   ```\n   stream.forEach(System.out::println)\n   ```\n\n2. **collect(Collector collector)**：将流中的元素收集到一个集合中。\n\n   ```\n   List<Integer> list = stream.collect(Collectors.toList())\n   ```\n\n3. **count()**：返回流中元素的数量。\n\n   ```\n   long count = stream.count()\n   ```\n\n4. **anyMatch(Predicate predicate)** / **allMatch(Predicate predicate)** / **noneMatch(Predicate predicate)**：检查流中的元素是否满足指定条件。\n\n   ```\n   boolean anyMatch = stream.anyMatch(x -> x > 10)\n   boolean allMatch = stream.allMatch(x -> x > 0)\n   boolean noneMatch = stream.noneMatch(x -> x < 0)\n   ```\n\n5. **findFirst()** / **findAny()**：返回流中的第一个元素或者任意一个元素。\n\n   ```\n   Optional<Integer> first = stream.findFirst()\n   Optional<Integer> any = stream.findAny()\n   ```\n\n6. **reduce(BinaryOperator accumulator)** / **reduce(T identity, BinaryOperator accumulator)**：将流中的元素归约成一个值。\n\n   ```\n   Optional<Integer> sum = stream.reduce(Integer::sum)\n   Integer sum = stream.reduce(0, Integer::sum)\n   ```\n\n- `forEach(Consumer<? super T> action)`: 对流中的每个元素执行一个操作。\n- `forEachOrdered(Consumer<? super T> action)`: 顺序地（在并行流上）对流中的每个元素执行一个操作。\n- `toArray()`: 返回一个包含流中所有元素的数组。\n- `reduce(T identity, BinaryOperator<T> accumulator)`: 对流中的元素执行归约操作，如求和、最大值等。\n- `reduce(U identity, Function<? super T, ? extends U> mapper, BinaryOperator<U> reducer)`: 执行映射归约操作，先将流中的元素映射到一个新的类型，然后归约。\n- `collect(Collector<? super T, A, R> collector)`: 使用`Collector`对流中的元素进行归约操作，如收集到列表中、集合中等。\n- `min(Comparator<? super T> comparator)`: 返回流中的最小元素（根据提供的比较器）。\n- `max(Comparator<? super T> comparator)`: 返回流中的最大元素（根据提供的比较器）。\n- `count()`: 返回流中的元素数量。\n- `anyMatch(Predicate<? super T> predicate)`: 检查流中是否存在任何满足给定条件的元素。\n- `allMatch(Predicate<? super T> predicate)`: 检查流中的所有元素是否都满足给定条件。\n- `noneMatch(Predicate<? super T> predicate)`: 检查流中是否没有任何元素满足给定条件。\n- `findFirst()`: 返回流中的第一个元素（如果存在），否则返回一个空的`Optional`。\n- `findAny()`: 返回流中的任何元素（对于并行流可能返回任意元素），否则返回一个空的`Optional`。\n\n#### 案例\n\n```\nimport java.util.Arrays;  \nimport java.util.List;  \nimport java.util.stream.Collectors;  \n  \npublic class StreamTerminalOperations {  \n    public static void main(String[] args) {  \n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);  \n  \n        // 使用中间操作 filter 和 map，以及终端操作 forEach  \n        numbers.stream()  \n                .filter(n -> n % 2 != 0) // 过滤出奇数  \n                .map(n -> n * n) // 将每个奇数平方  \n                .forEach(System.out::println); // 打印每个平方数  \n  \n        // 使用终端操作 reduce 计算流中所有元素的和  \n        int sum = numbers.stream()  \n                .mapToInt(Integer::intValue) // 将流转换为int流以便进行数学运算  \n                .sum();  \n        System.out.println(\"Sum: \" + sum);  \n  \n        // 使用终端操作 collect 收集结果到列表中  \n        List<String> strings = numbers.stream()  \n                .map(String::valueOf) // 将每个整数转换为字符串  \n                .collect(Collectors.toList());  \n        System.out.println(strings);  \n    }  \n}\n```\n\n## 应用场景\n\n\n\n### 归集（将流转换为集合）\n\n- `List`, `Set`, `ArrayList`：使用 `collect` 方法配合适当的收集器（如 `Collectors.toList()`, `Collectors.toSet()`）可以将流转换为集合。\n\n### 聚合（获取流中特殊值）\n\n- `maxBy`, `minBy`：使用 `Collectors.maxBy()` 或 `Collectors.minBy()` 可以找到流中的最大值或最小值，需要传入一个比较器。\n- `summingInt`, `summingDouble`, `summingLong`：这些收集器用于计算流中元素的和。\n- `averagingInt`, `averagingDouble`, `averagingLong`：计算平均值。\n- `counting`：计算流中元素的数量。\n\n### 分组（根据属性分组）\n\n- `groupingBy`：根据某个属性对流中的元素进行分组。可以配合其他收集器进行多级分组。\n\n### 分区（只有两个分区，true/false）\n\n- `partitioningBy`：根据某个条件对流中的元素进行分区，通常分为 `true` 和 `false` 两个组。\n\n### 拼接（把元素按一定条件拼接）\n\n- `joining`：使用 `Collectors.joining()` 可以将流中的元素拼接成一个字符串。\n\n### 数据过滤(筛选数据)\n\n- `filter`：根据条件过滤流中的元素。\n- `distinct`：去除流中的重复元素。\n- `limit`：限制流中元素的数量。\n- `skip`：跳过流中的前N个元素。\n\n### 数据映射(获取新对象)\n\n- `map`：对流中的每个元素应用一个函数，产生一个新的流。\n\n### 数据查找(查找符合条件信息)\n\n- `allMatch`：检查流中的所有元素是否都满足某个条件。\n- `anyMatch`：检查流中是否至少有一个元素满足某个条件。\n- `noneMatch`：检查流中是否没有元素满足某个条件。\n- `findFirst`：返回流中第一个满足条件的元素（返回一个 `Optional`）。\n\n### 数据收集(过滤+映射)\n\n- 使用 `collect` 方法配合各种收集器（如 `Collectors.counting()`, `Collectors.maxBy()`, `Collectors.groupingBy()` 等）可以对流中的元素进行统计、分组等操作。\n\n### 注意事项\n\n- 在使用 `maxBy` 和 `minBy` 时，确保比较器（Comparator）的创建是合适的，因为这两个操作返回的是 `Optional<T>`，其中 `T` 是流中元素的类型。\n- 在使用 `groupingBy` 进行多级分组时，第二个参数（downstream collector）可以是一个 `groupingBy` 收集器，以实现更复杂的分组结构。\n- 在使用 `joining` 时，要注意元素中可能包含的特殊字符（如分隔符），它们可能会干扰拼接结果。\n- 在进行过滤和映射操作时，要确保传递给 `filter` 和 `map` 的 lambda 表达式是正确和高效的。\n- 在使用流时，要注意流的中间操作（如 `filter`, `map`）是惰性的，只有在终端操作（如 `collect`, `forEach`）被调用时才会执行。\n\n\n\n# Optional 类(处理stream流空值)\n\n## 介绍\n\n- `Optional` 类是 Java 8 引入的一种用来表示可能为 null 的值的容器类型。\n- 它可以避免空指针异常，通过提供一系列方法来处理可能为 null 的情况，例如 `orElse`、`orElseGet`、`orElseThrow` 等。\n- Optional 类的设计鼓励开发者显式地处理空值情况，使得代码更加健壮和可读。\n\n## 使用\n\n### 1. 创建 Optional 对象\n\n- **使用 `Optional.of(T value)` 创建一个包含非空值的 Optional**：\n\n```java\nOptional<String> optional = Optional.of(\"Hello, World!\");\n```\n\n- **使用 `Optional.empty()` 创建一个不包含值的 Optional**：\n\n```java\nOptional<String> emptyOptional = Optional.empty();\n```\n\n- **使用 `Optional.ofNullable(T value)` 创建一个可能包含空值的 Optional**：\n\n```java\nOptional<String> optionalNullable = Optional.ofNullable(null); // 不包含值  \nOptional<String> optionalNotNullable = Optional.ofNullable(\"Hello, World!\"); // 包含值\n```\n\n### 2. 检索 Optional 中的值\n\n- **使用 `get()` 方法获取值（如果值不存在，会抛出 `NoSuchElementException`）**：\n\n```java\nString value = optional.get(); // 如果 optional 包含值，则返回该值\n```\n\n- **使用 `isPresent()` 方法检查值是否存在**：\n\n```java\nboolean isPresent = optional.isPresent(); // 如果 optional 包含值，则返回 true\n```\n\n- **使用 `ifPresent(Consumer<? super T> consumer)` 方法处理值（如果值存在）**：\n\n```java\noptional.ifPresent(System.out::println); // 如果 optional 包含值，则打印该值\n```\n\n- **使用 `orElse(T other)` 方法返回值或默认值**：\n\n```java\nString defaultValue = optional.orElse(\"Default Value\"); // 如果 optional 不包含值，则返回 \"Default Value\"\n```\n\n- **使用 `orElseGet(Supplier<? extends T> other)` 方法返回值或调用函数获取的默认值**：\n\n```java\nString lazyDefaultValue = optional.orElseGet(() -> \"Lazy Default Value\"); // 如果 optional 不包含值，则调用函数获取默认值\n```\n\n- **使用 `orElseThrow(Supplier<? extends X> exceptionSupplier)` 方法返回值或抛出异常**：\n\n```java\ntry {  \n    String value = optional.orElseThrow(() -> new RuntimeException(\"Value not found\"));  \n} catch (RuntimeException e) {  \n    // 处理异常  \n}\n```\n\n### 3. 转换 Optional 中的值\n\n- **使用 `map(Function<? super T, ? extends U> mapper)` 方法转换值**：\n\n```java\n\nOptional<Integer> optionalLength = optional.map(String::length); // 如果 optional 包含字符串，则返回其长度\n```\n\n- **使用 `flatMap(Function<? super T, Optional<U>> mapper)` 方法转换值为另一个 Optional**：\n\n```java\nOptional<Optional<String>> optionalOfOptional = Optional.of(optional);  \nOptional<String> flattenedOptional = optionalOfOptional.flatMap(Function.identity()); // 扁平化 Optional\n```\n\n### 4. 过滤 Optional 中的值\n\n- **使用 `filter(Predicate<? super T> predicate)` 方法过滤值**：\n\n```java\nOptional<String> filteredOptional = optional.filter(s -> s.startsWith(\"Hello\")); // 如果 optional 包含以 \"Hello\" 开头的字符串，则返回该 optional，否则返回空的 optional\n```\n\n## 处理stream\n\n### 示例 1：从Stream中找到第一个元素（可能为空）\n\n```java\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\");  \n  \n// 使用Stream的findFirst方法，它返回一个Optional<T>  \nOptional<String> firstElement = list.stream().findFirst();  \n  \n// 使用ifPresent检查元素是否存在并处理  \nfirstElement.ifPresent(System.out::println);  \n  \n// 或者使用orElse提供一个默认值  \nString defaultElement = firstElement.orElse(\"No element found\");  \nSystem.out.println(defaultElement);\n```\n\n### 示例 2：从Stream中映射并过滤，然后收集到Optional\n\n有时你可能想从一个 `Stream` 中找到满足某个条件的唯一元素。如果这样的元素存在，你希望得到一个包含它的 `Optional`；如果不存在，你希望得到一个空的 `Optional`。这可以通过 `Stream` 的 `filter`、`findFirst` 或 `reduce` 方法与 `Optional` 一起实现。\n\n```java\nList<Person> people = ... // 假设这里有一个Person类的列表  \n  \n// 查找年龄为30岁的第一个人  \nOptional<Person> personOptional = people.stream()  \n    .filter(p -> p.getAge() == 30)  \n    .findFirst();  \n  \n// 处理Optional  \npersonOptional.ifPresent(p -> System.out.println(p.getName()));\n```\n\n### 示例 3：将Stream的结果转换为单个值（可能是null）并使用Optional封装\n\n在某些情况下，你可能有一个 `Stream`，你知道它只会产生一个元素或没有元素，并且你希望将这个元素封装在 `Optional` 中。虽然这通常不是 `Stream` 的典型用法（因为 `Stream` 是为了处理多个元素而设计的），但你可以通过 `reduce` 方法来实现这一点。\n\n```java\nList<String> uniqueList = Arrays.asList(\"uniqueValue\"); // 假设列表只包含一个元素  \n  \n// 使用reduce和Optional来封装可能的单个值  \nOptional<String> singleValue = uniqueList.stream()  \n    .reduce((a, b) -> {  \n        throw new IllegalStateException(\"Stream should contain only one element\");  \n    })  \n    .map(Optional::ofNullable) // 实际上，这个map调用在这里是多余的，因为我们知道reduce不会调用  \n    .orElse(Optional.empty()); // 但为了演示目的，我们假设reduce可能不返回任何值  \n  \n// 但更常见的做法是直接使用findFirst或类似的方法  \nOptional<String> singleValueFromFindFirst = uniqueList.stream().findFirst();\n```\n\n\n\n\n\n# Collectors 类（收集stream）\n\n## 介绍\n\n- `Collectors` 类提供了一系列静态工厂方法，用于将流中的元素收集到不同类型的结果容器中，例如 List、Set、Map 等。\n- 它提供了丰富的收集器，可以满足各种不同的需求，例如分组、分区、聚合等。\n- Collectors 类的使用可以使得流式操作更加灵活和高效，使得代码更加简洁和可维护。\n- 它包含了一系列静态方法，用于对流（Stream）进行归约操作（如收集到集合、汇总等）。`Collectors` 类中的方法可以被用在 `Stream` 的 `collect()` 方法中，将流中的元素收集到各种容器中，或者进行汇总操作。\n\n## 使用\n\n### 1. 收集到 List\n\n```java\nList<String> list = Arrays.asList(\"a\", \"b\", \"c\", \"d\");  \nList<String> collectedList = list.stream().collect(Collectors.toList());\n```\n\n### 2. 收集到 Set\n\n```java\nList<String> list = Arrays.asList(\"a\", \"b\", \"a\", \"c\");  \nSet<String> collectedSet = list.stream().collect(Collectors.toSet()); // 自动去重\n```\n\n### 3. 收集到 Map（基于某个属性分组）\n\n```java\nList<Person> people = ... // 假设这里有一个Person类的列表  \nMap<String, List<Person>> byDepartment = people.stream()  \n    .collect(Collectors.groupingBy(Person::getDepartment)); // 假设Person类有一个getDepartment()方法\n```\n\n### 4. 收集到 Map（同时包含键和值的转换）\n\n```java\nList<Person> people = ... // 假设这里有一个Person类的列表  \nMap<String, Integer> nameToAgeMap = people.stream()  \n    .collect(Collectors.toMap(Person::getName, Person::getAge)); // 假设Person类有getName()和getAge()方法\n```\n\n### 5. 汇总操作（求和、平均值等）\n\n```java\nList<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);  \n  \n// 求和  \nint sum = numbers.stream().mapToInt(Integer::intValue).sum();  \n  \n// 平均值  \ndouble average = numbers.stream().mapToDouble(Integer::doubleValue).average().orElse(0);  \n  \n// 使用Collectors汇总  \nIntSummaryStatistics stats = numbers.stream()  \n    .mapToInt(Integer::intValue)  \n    .collect(Collectors.summarizingInt(Integer::intValue));  \nSystem.out.println(\"Sum: \" + stats.getSum());  \nSystem.out.println(\"Average: \" + stats.getAverage());\n```\n\n### 6. 连接字符串（使用分隔符）\n\n```java\nList<String> words = Arrays.asList(\"Hello\", \"world\", \"!\");  \nString sentence = words.stream().collect(Collectors.joining(\" \")); // 输出 \"Hello world !\"\n```\n\n### 7. 自定义收集器\n\n可以通过实现 `Collector` 接口或使用 `Collectors.collectingAndThen()`、`Collectors.teeing()` 等方法来创建自定义收集器。这通常在需要更复杂的收集逻辑时有用。',28,'JAVA','java',1,70,0,0,'2024-05-28 20:39:03','2024-05-28 20:39:03'),(33,'JUC辅助类','','http://liyiru.site/upload/20240528_23411824.jpg','## JUC辅助类\n\n### 理论\n\n### 语法\n\n#### CountDownLatch: 减少计数\n\nCountDownLatch 类可以设置一个计数器，然后通过 countDown 方法来进行减 1 的操作，使用 await 方法等待计数器不大于 0，然后继续执行 await 方法之后的语句。\n• 其它线程调用 countDown 方法会将计数器减 1(调用 countDown 方法的线程不会阻塞)\n• 当计数器的值变为 0 时，因 await 方法阻塞的线程会被唤醒，继续执行\n\n**构造方法：**\n\n- `CountDownLatch(int count)`: 创建一个 CountDownLatch 实例，指定需要等待的线程数量，即需要调用 `countDown()` 方法的次数。\n\n**等待方法：**\n\n- `await() throws InterruptedException`: 让当前线程等待，直到计数器减为零，或者等待过程中被中断。如果计数器已经为零，则此方法立即返回。\n\n**减少计数器方法：**\n\n- `countDown()`: 使计数器减 1。当计数器减为零时，所有因调用 `await()` 方法而在等待的线程都会被释放，可以继续执行。\n\n```\n//场景: 6 个同学陆续离开教室后值班同学才可以关门。\n//1：设置初始值\n//2：消耗初始值\n//3：主线程等待值为0\n\npublic class CountDownLatchDemo {\n    //6个同学陆续离开教室之后，班长锁门\n    public static void main(String[] args) throws InterruptedException {\n\n        //创建CountDownLatch对象，设置初始值\n        CountDownLatch countDownLatch = new CountDownLatch(6);\n\n        //6个同学陆续离开教室之后\n        for (int i = 1; i <=6; i++) {\n            new Thread(()->{\n                System.out.println(Thread.currentThread().getName()+\" 号同学离开了教室\");\n\n                //计数  -1\n                countDownLatch.countDown();\n\n            },String.valueOf(i)).start();\n        }\n\n        //等待\n        countDownLatch.await();\n\n        System.out.println(Thread.currentThread().getName()+\" 班长锁门走人了\");\n    }\n}\n```\n\n#### CyclicBarrier: 循环栅栏\n\n允许一组线程互相等待，直到到达某个公共屏障点，然后同时继续执行\n\nCyclicBarrier 看英文单词可以看出大概就是循环阻塞的意思，在使用中CyclicBarrier 的构造方法第一个参数是目标障碍数，每次执行 CyclicBarrier 一次障碍数会加一，如果达到了目标障碍数，才会执行 cyclicBarrier.await()之后的语句。可以将 CyclicBarrier 理解为加 1 操作\n\n**构造方法：**\n\n- `CyclicBarrier(int parties)`: 创建一个 CyclicBarrier 实例，指定需要等待的线程数量。\n- `CyclicBarrier(int parties, Runnable barrierAction)`: 创建一个 CyclicBarrier 实例，同时指定所有线程到达屏障点后执行的动作。\n\n**等待方法：**\n\n- `await() throws InterruptedException, BrokenBarrierException`: 让当前线程等待，直到所有线程都到达屏障点。如果当前线程不是最后一个到达的线程，则会被阻塞，直到所有线程到达；如果当前线程是最后一个到达的线程，则会唤醒所有等待的线程，并继续执行。\n\n- `int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException`: 让当前线程等待一段指定的时间，直到所有线程到达屏障点，或者超时。如果超时，会抛出 TimeoutException 异常。\n\n```\n//集齐7颗龙珠就可以召唤神龙\npublic class CyclicBarrierDemo {\n\n    //创建固定值\n    private static final int NUMBER = 7;\n\n    public static void main(String[] args) {\n        //创建CyclicBarrier\n        CyclicBarrier cyclicBarrier =\n                new CyclicBarrier(NUMBER,()->{\n                    System.out.println(\"*****集齐7颗龙珠就可以召唤神龙\");\n                });\n\n        //集齐七颗龙珠过程\n        for (int i = 1; i <=7; i++) {\n            new Thread(()->{\n                try {\n                    System.out.println(Thread.currentThread().getName()+\" 星龙被收集到了\");\n                    //等待\n                    cyclicBarrier.await();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}\n```\n\n#### Semaphore: 信号灯\n\nSemaphore 的构造方法中传入的第一个参数是最大信号量（可以看成最大线程池），每个信号量初始化为一个最多只能分发一个许可证。使用 acquire 方法获得许可证，release 方法释放许可\n\n用于控制同时访问特定资源的线程数量。Semaphore 维护了一组许可证（permits），线程在访问资源之前必须先获得许可证，每次许可证的获取都会将许可证数量减少，释放许可证则会增加数量。\n\n**构造方法：**\n\n- `Semaphore(int permits)`: 创建一个 Semaphore 实例，指定初始的许可证数量。\n\n**获取许可证方法：**\n\n- `acquire() throws InterruptedException`: 获取一个许可证，如果没有许可证可用，则当前线程会被阻塞，直到有许可证可用或者被中断。\n- `acquire(int permits) throws InterruptedException`: 获取指定数量的许可证，如果当前可用的许可证数量小于请求的数量，则当前线程会被阻塞，直到有足够的许可证可用或者被中断。\n- `tryAcquire()`: 尝试获取一个许可证，如果有可用的许可证，则立即返回 true；否则返回 false。\n- `tryAcquire(int permits)`: 尝试获取指定数量的许可证，如果有足够的可用许可证，则立即返回 true；否则返回 false。\n\n**释放许可证方法：**\n\n- `release()`: 释放一个许可证，将许可证数量加一。如果有等待的线程在等待许可证，则其中一个会被唤醒并获取许可证。\n- `release(int permits)`: 释放指定数量的许可证，将许可证数量加上指定数量。\n\n**其他方法：**\n\n- `int availablePermits()`: 获取当前可用的许可证数量。\n- `boolean hasQueuedThreads()`: 判断是否有线程在等待获取许可证。\n\n```\n//6辆汽车，停3个车位\npublic class SemaphoreDemo {\n    public static void main(String[] args) {\n        //创建Semaphore，设置许可数量\n        Semaphore semaphore = new Semaphore(3);\n\n        //模拟6辆汽车\n        for (int i = 1; i <=6; i++) {\n            new Thread(()->{\n                try {\n                    //抢占\n                    semaphore.acquire();\n\n                    System.out.println(Thread.currentThread().getName()+\" 抢到了车位\");\n\n                    //设置随机停车时间\n                    TimeUnit.SECONDS.sleep(new Random().nextInt(5));\n\n                    System.out.println(Thread.currentThread().getName()+\" ------离开了车位\");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                } finally {\n                    //释放\n                    semaphore.release();\n                }\n            },String.valueOf(i)).start();\n        }\n    }\n}\n```',32,'JUC','juc',1,28,0,0,'2024-05-28 23:41:19','2024-05-28 23:41:19'),(34,'阻塞队列','','http://liyiru.site/upload/20240528_23514644.jpg','## 阻塞队列\n\n### BlockingQueue\n\n#### 特点\n\nBlockingQueue 很好的解决了多线程中，如何高效安全“传输”数据的问题。通过这些高效并且线程安全的队列类，为我们快速搭建高质量的多线程程序带来极大的便利。本文详细介绍了 BlockingQueue 家庭中的所有成员，包括他们各自的功能以及常见使用场景。\n阻塞队列，顾名思义，首先它是一个队列, 通过一个共享的队列，可以使得数据由队列的一端输入，从另外一端输出；\n\n#### 原理\n\n![](http://liyiru.site/upload/20240528_23463440.png)\n当队列是空的，从队列中获取元素的操作将会被阻塞\n当队列是满的，从队列中添加元素的操作将会被阻塞\n试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素\n试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增\n\n在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起\n\n#### 为什么需要 BlockingQueue\n\n好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都给你一手包办了\n在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。多线程环境中，通过队列可以很容易实现数据共享，比如经典的“生产者”和“消费者”模型中，通过队列可以很便利地实现两者之间的数据共享。假设我们有若干生产者线程，另外又有若干个消费者线程。如果生产者线程需要把准备好的数据共享给消费者线程，利用队列的方式来传递数据，就可以很方便地解决他们之间的数据共享问题。但如果生产者和消费者在某个时间段内，万一发生数据处理速度不匹配的情况呢？理想情况下，如果生产者产出数据的速度大于消费者消费的速度，并且当生产出来的数据累积到一定程度的时候，那么生产者必须暂停等待一下（阻塞生产者线程），以便等待消费者线程把累积的数据处理完毕，反之亦然。\n• 当队列中没有数据的情况下，消费者端的所有线程都会被自动阻塞（挂起），直到有数据放入队列\n• 当队列中填满数据的情况下，生产者端的所有线程都会被自动阻塞（挂起），直到队列中有空的位置，线程被自动唤醒\n\n#### BlockingQueue 核心方法\n\n\n![](http://liyiru.site/upload/20240528_23491483.png)\n\n![](http://liyiru.site/upload/20240528_23504568.png)\n\n\n##### 放入数据\n\n• offer(anObject):表示如果可能的话,将 anObject 加到 BlockingQueue 里,即如果 BlockingQueue 可以容纳,则返回 true,否则返回 false.（本方法不阻塞当前执行方法的线程）\n• offer(E o, long timeout, TimeUnit unit)：可以设定等待的时间，如果在指定的时间内，还不能往队列中加入 BlockingQueue，则返回失败\n• put(anObject):把 anObject 加到 BlockingQueue 里,如果 BlockQueue 没有空间,则调用此方法的线程被阻断直到 BlockingQueue 里面有空间再继续.\n\n##### 获取数据\n\n• poll(time): 取走 BlockingQueue 里排在首位的对象,若不能立即取出,则可以等time 参数规定的时间,取不到时返回 null\n• poll(long timeout, TimeUnit unit)：从 BlockingQueue 取出一个队首的对象，如果在指定时间内，队列一旦有数据可取，则立即返回队列中的数据。否则知道时间超时还没有数据可取，返回失败。\n• take(): 取走 BlockingQueue 里排在首位的对象,若 BlockingQueue 为空,阻断进入等待状态直到 BlockingQueue 有新的数据被加入;\n• drainTo(): 一次性从 BlockingQueue 获取所有可用的数据对象（还可以指定获取数据的个数），通过该方法，可以提升获取数据效率；不需要多次分批加锁或释放锁。\n\n### ArrayBlockingQueue(常用)\n\n**由数组结构组成的有界阻塞队列**\n\n基于数组的阻塞队列实现，在 ArrayBlockingQueue 内部，维护了一个定长数组，以便缓存队列中的数据对象，这是一个常用的阻塞队列，除了一个定长数组外，ArrayBlockingQueue 内部还保存着两个整形变量，分别标识着队列的头部和尾部在数组中的位置。\nArrayBlockingQueue 在生产者放入数据和消费者获取数据，都是共用同一个锁对象，由此也意味着两者无法真正并行运行，这点尤其不同于LinkedBlockingQueue；按照实现原理来分析，ArrayBlockingQueue 完全可以采用分离锁，从而实现生产者和消费者操作的完全并行运行。Doug Lea 之所以没这样去做，也许是因为 ArrayBlockingQueue 的数据写入和获取操作已经足够轻巧，以至于引入独立的锁机制，除了给代码带来额外的复杂性外，其在性能上完全占不到任何便宜。 ArrayBlockingQueue 和LinkedBlockingQueue 间还有一个明显的不同之处在于，前者在插入或删除元素时不会产生或销毁任何额外的对象实例，而后者则会生成一个额外的Node 对象。这在长时间内需要高效并发地处理大批量数据的系统中，其对于GC 的影响还是存在一定的区别。而在创建 ArrayBlockingQueue 时，我们还可以控制对象的内部锁是否采用公平锁，默认采用非公平锁。\n\n### LinkedBlockingQueue(常用)\n\n**由链表结构组成的有界（但大小默认值为integer.MAX_VALUE）阻塞队列**\n\n基于链表的阻塞队列，同 ArrayListBlockingQueue 类似，其内部也维持着一个数据缓冲队列（该队列由一个链表构成），当生产者往队列中放入一个数据时，队列会从生产者手中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时（LinkedBlockingQueue 可以通过构造函数指定该值），才会阻塞生产者队列，直到消费者从队列中消费掉一份数据，生产者线程会被唤醒，反之对于消费者这端的处理也基于同样的原理。而 LinkedBlockingQueue 之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能。\nArrayBlockingQueue 和 LinkedBlockingQueue 是两个最普通也是最常用的阻塞队列，一般情况下，在处理多线程间的生产者消费者问题，使用这两个类足以。\n\n### DelayQueue\n\n**使用优先级队列实现的延迟无界阻塞队列**\n\nDelayQueue 中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。\n\n### PriorityBlockingQueue\n\n**支持优先级排序的无界阻塞队列**\n\n基于优先级的阻塞队列（优先级的判断通过构造函数传入的 Compator 对象来决定），但需要注意的是 PriorityBlockingQueue 并不会阻塞数据生产者，而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。在实现 PriorityBlockingQueue 时，内部控制线程同步的锁采用的是公平锁。\n\n### SynchronousQueue\n\n**不存储元素的阻塞队列，也即单个元素的队列**\n\n一种无缓冲的等待队列，类似于无中介的直接交易，有点像原始社会中的生产者和消费者，生产者拿着产品去集市销售给产品的最终消费者，而消费者必须亲自去集市找到所要商品的直接生产者，如果一方没有找到合适的目标，那么对不起，大家都在集市等待。相对于有缓冲的 BlockingQueue 来说，少了一个中间经销商的环节（缓冲区），如果有经销商，生产者直接把产品批发给经销商，而无需在意经销商最终会将这些产品卖给那些消费者，由于经销商可以库存一部分商品，因此相对于直接交易模式，总体来说采用中间经销商的模式会吞吐量高一些（可以批量买卖）；但另一方面，又因为经销商的引入，使得产品从生产者到消费者中间增加了额外的交易环节，单个产品的及时响应性能可能会降低。\n声明一个 SynchronousQueue 有两种不同的方式，它们之间有着不太一样的行为。\n\n##### 公平模式和非公平模式的区别:\n\n• 公平模式：SynchronousQueue 会采用公平锁，并配合一个 FIFO 队列来阻塞多余的生产者和消费者，从而体系整体的公平策略；\n• 非公平模式（SynchronousQueue 默认）：SynchronousQueue 采用非公平锁，同时配合一个 LIFO 队列来管理多余的生产者和消费者，而后一种模式，如果生产者和消费者的处理速度有差距，则很容易出现饥渴的情况，即可能有某些生产者或者是消费者的数据永远都得不到处理。\n\n### LinkedTransferQueue\n\n**由链表组成的无界阻塞队列**\n\nLinkedTransferQueue 是一个由链表结构组成的无界阻塞 TransferQueue 队列。相对于其他阻塞队列，LinkedTransferQueue 多了 tryTransfer 和transfer 方法。\nLinkedTransferQueue 采用一种预占模式。意思就是消费者线程取元素时，如果队列不为空，则直接取走数据，若队列为空，那就生成一个节点（节点元素为 null）入队，然后消费者线程被等待在这个节点上，后面生产者线程入队时发现有一个元素为 null 的节点，生产者线程就不入队了，直接就将元素填充到该节点，并唤醒该节点等待的线程，被唤醒的消费者线程取走元素，从调用的方法返回。\n\n### LinkedBlockingDeque\n\n **由链表组成的双向阻塞队列**\n\nLinkedBlockingDeque 是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除元素。\n对于一些指定的操作，在插入或者获取队列元素时如果队列状态不允许该操作可能会阻塞住该线程直到队列状态变更为允许操作，这里的阻塞一般有两种情况\n• 插入元素时: 如果当前队列已满将会进入阻塞状态，一直等到队列有空的位置时再讲该元素插入，该操作可以通过设置超时参数，超时后返回 false 表示操作失败，也可以不设置超时参数一直阻塞，中断后抛出 InterruptedException 异常\n• 读取元素时: 如果当前队列为空会阻塞住直到队列不为空然后返回元素，同样可以通过设置超时参数\n\n### 归纳\n\n1. 在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起\n2. 为什么需要 BlockingQueue? 在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须去自己控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。使用后我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切 BlockingQueue 都给你一手包办了',32,'JUC','juc',1,28,0,0,'2024-05-28 23:51:47','2024-05-28 23:51:47'),(35,'Fork/Join（拆分任务）','','http://liyiru.site/upload/20240528_23530240.jpg','## 拆分任务-Fork/Join\n\n### 理论\n\n#### （1）介绍\n\nFork/Join 它可以将一个大的任务拆分成多个子任务进行并行处理，最后将子任务结果合并成最后的计算结果，并进行输出。Fork/Join 框架要完成两件事情：\nFork：把一个复杂任务进行分拆，大事化小\nJoin：把分拆任务的结果进行合并\n\n1. 任务分割：首先 Fork/Join 框架需要把大的任务分割成足够小的子任务，如果子任务比较大的话还要对子任务进行继续分割\n2. 执行任务并合并结果：分割的子任务分别放到双端队列里，然后几个启动线程分别从双端队列里获取任务执行。子任务执行完的结果都放在另外一个队列里，启动一个线程从队列里取数据，然后合并这些数据。\n\n**ForkJoinTask**:我们要使用 Fork/Join 框架，首先需要创建一个 ForkJoin 任务。该类提供了在任务中执行 fork 和 join 的机制。通常情况下我们不需要直接集成 ForkJoinTask 类，只需要继承它的子类，Fork/Join 框架提供了两个子类：\n	a.RecursiveAction：用于没有返回结果的任务\n	b.RecursiveTask:用于有返回结果的任务\n**ForkJoinPool**:ForkJoinTask 需要通过 ForkJoinPool 来执行\n**RecursiveTask**: 继承后可以实现递归(自己调自己)调用的任务\n\n#### （2）Fork/Join 框架的实现原理\n\nForkJoinPool 由 ForkJoinTask 数组和 ForkJoinWorkerThread 数组组成，ForkJoinTask 数组负责将存放以及将程序提交给 ForkJoinPool，而ForkJoinWorkerThread 负责执行这些任务。\n\n#### （3）fork()与join方法()\n\n##### Fork 方法的实现原理：\n\n 当我们调用 ForkJoinTask 的 fork 方法时，程序会把任务放在 ForkJoinWorkerThread 的 pushTask 的 workQueue 中，异步地执行这个任务，然后立即返回结果\n\n```\npublic final ForkJoinTask<V> fork() {\nThread t;\nif ((t = Thread.currentThread()) instanceof ForkJoinWorkerThread)\n((ForkJoinWorkerThread)t).workQueue.push(this);\nelse\nForkJoinPool.common.externalPush(this);\nreturn this;\n}\n```\n\npushTask 方法把当前任务存放在 ForkJoinTask 数组队列里。然后再调用ForkJoinPool 的 signalWork()方法唤醒或创建一个工作线程来执行任务。\n\n```\nfinal void push(ForkJoinTask<?> task) {\nForkJoinTask<?>[] a; ForkJoinPool p;\nint b = base, s = top, n;\nif ((a = array) != null) { // ignore if queue removed\nint m = a.length - 1; // fenced write for task visibility\nU.putOrderedObject(a, ((m & s) << ASHIFT) + ABASE, task);\nU.putOrderedInt(this, QTOP, s + 1);\nif ((n = s - b) <= 1) {\nif ((p = pool) != null)\np.signalWork(p.workQueues, this);//执行\n}\nelse if (n >= m)\ngrowArray();\n}\n}\n```\n\n##### join 方法\n\nJoin 方法的主要作用是阻塞当前线程并等待获取结果。让我们一起看看ForkJoinTask 的 join 方法的实现\n\n```\npublic final V join() {\nint s;\nif ((s = doJoin() & DONE_MASK) != NORMAL)\nreportException(s);\nreturn getRawResult();\n}\n```\n\n它首先调用 doJoin 方法，通过 doJoin()方法得到当前任务的状态来判断返回什么结果，任务状态有 4 种：已完成（NORMAL）、被取消（CANCELLED）、信号（SIGNAL）和出现异常（EXCEPTIONAL）\n• 如果任务状态是已完成，则直接返回任务结果。\n• 如果任务状态是被取消，则直接抛出 CancellationException\n• 如果任务状态是抛出异常，则直接抛出对应的异常\n分析一下 doJoin 方法的实现\n\n```\nprivate int doJoin() {\nint s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue\nw;\nreturn (s = status) < 0 ? s :\n((t = Thread.currentThread()) instanceof ForkJoinWorkerThread) ?\n(w = (wt = (ForkJoinWorkerThread)t).workQueue).\ntryUnpush(this) && (s = doExec()) < 0 ? s :\nwt.pool.awaitJoin(w, this, 0L) :\nexternalAwaitDone();\n}\nfinal int doExec() {\nint s; boolean completed;\nif ((s = status) >= 0) {\ntry {\ncompleted = exec();\n} catch (Throwable rex) {\nreturn setExceptionalCompletion(rex);\n}\nif (completed)\ns = setCompletion(NORMAL);\n}\nreturn s;\n}\n```\n\n在 doJoin()方法流程如下:\n\n1. 首先通过查看任务的状态，看任务是否已经执行完成，如果执行完成，则直接返回任务状态；\n2. 如果没有执行完，则从任务数组里取出任务并执行。\n3. 如果任务顺利执行完成，则设置任务状态为 NORMAL，如果出现异常，则记录异常，并将任务状态设置为 EXCEPTIONAL。\n\n#### （4）Fork/Join 框架的异常处理\n\nForkJoinTask 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 ForkJoinTask 提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过 ForkJoinTask 的getException 方法获取异常。\n\ngetException 方法返回 Throwable 对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回 null。\n\n### 应用\n\n```\nclass MyTask extends RecursiveTask<Integer> {\n\n    //拆分差值不能超过10，计算10以内运算\n    private static final Integer VALUE = 10;\n    private int begin ;//拆分开始值\n    private int end;//拆分结束值\n    private int result ; //返回结果\n\n    //创建有参数构造\n    public MyTask(int begin,int end) {\n        this.begin = begin;\n        this.end = end;\n    }\n\n    //拆分和合并过程\n    @Override\n    protected Integer compute() {\n        //判断相加两个数值是否大于10\n        if((end-begin)<=VALUE) {\n            //相加操作\n            for (int i = begin; i <=end; i++) {\n                result = result+i;\n            }\n        } else {//进一步拆分\n            //获取中间值\n            int middle = (begin+end)/2;\n            //拆分左边\n            MyTask task01 = new MyTask(begin,middle);\n            //拆分右边\n            MyTask task02 = new MyTask(middle+1,end);\n            //调用方法拆分\n            task01.fork();\n            task02.fork();\n            //合并结果\n            result = task01.join()+task02.join();\n        }\n        return result;\n    }\n}\n\npublic class ForkJoinDemo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        //创建MyTask对象\n        MyTask myTask = new MyTask(0,100);\n        //创建分支合并池对象\n        ForkJoinPool forkJoinPool = new ForkJoinPool();\n        //创建合并池对象任务\n        ForkJoinTask<Integer> forkJoinTask = forkJoinPool.submit(myTask);\n        //获取最终合并之后结果\n        Integer result = forkJoinTask.get();\n        System.out.println(result);\n        //关闭池对象\n        forkJoinPool.shutdown();\n    }\n}\n```\n\n##',32,'JUC','juc',1,33,0,0,'2024-05-28 23:53:03','2024-05-28 23:53:03'),(36,'异步调用','','http://liyiru.site/upload/20240528_23572216.jpg','## Callable\n\n### 理论\n\n#### （1）callable原理分析\n\n##### Future 接口\n\n当 call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用 Future 对象。\n将 Future 视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦Callable 返回）。Future 基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下:\n• public boolean cancel（boolean mayInterrupt）：用于停止任务。如果尚未启动，它将停止任务。如果已启动，则仅在mayInterrupt 为 true时才会中断任务。\n• public Object get（）抛出 InterruptedException，ExecutionException：用于获取任务的结果。如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。\n\n• public boolean isDone（）：如果任务完成，则返回 true，否则返回 false可以看到 Callable 和 Future 做两件事-Callable 与 Runnable 类似，因为它封装了要在另一个线程上运行的任务，而 Future 用于存储从另一个线程获得的结果。实际上，future 也可以与 Runnable 一起使用。要创建线程，需要 Runnable。为了获得结果，需要 future。\n\n##### FutureTask\n\nJava 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建Thread 对象。因此，间接地使用 Callable 创建线程。\n\n#### （2）callable应用场景\n\n• 在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成, 当主线程将来需要时，就可以通过 Future对象获得后台作业的计算结果或者执行状态\n• 一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果\n• 仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。\n• 只计算一次\n\n#### （3）核心原理:\n\n在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成\n• 当主线程将来需要时，就可以通过 Future 对象获得后台作业的计算结果或者执行状态\n• 一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。\n• 仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法\n• 一旦计算完成，就不能再重新开始或取消计算\n• get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常\n• get 只计算一次,因此 get 方法放到最后\n\n### 语法\n\n与Runnable接口类似，但Callable接口的call()方法可以返回结果或抛出异常。可以通过FutureTask类包装Callable对象，然后传递给Thread类进行启动。\n\n```\nclass MyCallable implements Callable<Integer> {\n    public Integer call() {\n        // 线程执行的逻辑\n        return result;\n    }\n}\n\nFutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());\nThread thread = new Thread(futureTask);\nthread.start();\n```\n\n\n\n## FutureTask\n\n### 1、理论\n\n\n![](http://liyiru.site/upload/20240528_23563822.png)\n\n1. 定义与功能：\n   - FutureTask是Java并发编程中的一个类，结合了Future和Runnable接口，用于表示一个异步计算的结果。\n   - 它允许将耗时的计算任务提交给另一个线程去执行，而当前线程可以继续执行其他任务，从而实现并发执行的效果。\n   - FutureTask主要解决异步执行、获取计算结果、异常处理以及任务取消等问题。\n2. 状态管理：\n   - FutureTask内部维护了一个状态变量（如state），用于表示任务的不同状态，如未启动、运行中、已完成等。\n   - 状态变量的变化通过CAS（Compare-and-Swap）等原子操作来保证线程安全。\n3. 任务执行：\n   - FutureTask通常与Callable或Runnable接口一起使用。当使用Callable时，可以获取到任务执行的结果；当使用Runnable时，则无法获取结果。\n   - FutureTask实现了Runnable接口，因此可以直接提交给线程池执行，或者由调用线程直接执行（FutureTask.run()）。\n4. 结果获取：\n   - 通过调用Future.get()方法可以获取异步计算的结果。如果计算还没有完成，get()方法会阻塞调用线程，直到计算完成为止。\n   - 如果异步计算抛出了异常，那么调用get()方法时会抛出ExecutionException，从而可以方便地处理异常。\n5. 任务取消：\n   - 通过Future.cancel()方法可以取消还没有开始或者正在进行的异步计算。\n   - 取消操作的结果取决于任务是否已经启动、是否支持取消以及是否已经执行完成。\n6. 内部实现：\n   - FutureTask的实现涉及到了并发编程中的多个关键概念，如原子操作、状态管理、阻塞队列等。\n   - 它通过内部维护的状态变量和等待/通知机制来协调生产者和消费者线程之间的交互。\n7. 使用场景：\n   - 当需要异步执行某个计算任务，并且需要获取任务执行的结果时，可以使用FutureTask。\n   - 它可以提高程序的响应性，使得在等待耗时任务完成的同时，可以继续执行其他任务。\n\n### 2、使用\n\n```\npublic class CompletableFutureDemo\n{\n    public static void main(String[] args) throws ExecutionException, InterruptedException\n    {\n        FutureTask<String> futureTask = new FutureTask<>(new MyThread());\n\n        Thread t1 = new Thread(futureTask,\"t1\");\n        t1.start();\n        try { TimeUnit.MILLISECONDS.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); }\n        System.out.println(futureTask.get());\n    }\n}\n\nclass MyThread implements Callable<String>\n{\n    @Override\n    public String call() throws Exception\n    {\n\n        System.out.println(\"-----come in call() \" );\n        try { TimeUnit.MILLISECONDS.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); }\n        return \"hello Callable\";\n    }\n}\n\n```\n\n### 3、优缺点\n\n优点：Future+线程池异步多线程任务配合，能显著提高程序的运行效率。\n\n缺点：\n\n- get()阻塞---一旦调用get()方法求结果，一旦调用不见不散，非要等到结果才会离开，不管你是否计算完成，如果没有计算完成容易程序堵塞。\n- isDone()轮询---轮询的方式会耗费无谓的cpu资源，而且也不见得能及时得到计算结果，如果想要异步获取结果，通常会以轮询的方式去获取结果，尽量不要阻塞。\n\n结论：Future对于结果的获取不是很友好，只能通过**阻塞或轮询**的方式得到任务的结果。\n\n对于简单的业务场景使用Future完全ok\n\n回调通知：\n\n- 应对Future的完成时间，完成了可以告诉我，也就是我们的回调通知\n- 通过轮询的方式去判断任务是否完成这样非常占cpu并且代码也不优雅\n\n创建异步任务：Future+线程池组合\n\n- 多个任务前后依赖可以组合处理（水煮鱼--->买鱼--->调料--->下锅）：\n\n  - 想将多个异步任务的结果组合起来，后一个异步任务的计算结果需要钱一个异步任务的值\n\n  - 想将两个或多个异步计算合并成为一个异步计算，这几个异步计算互相独立，同时后面这个又依赖前一个处理的结果\n\n对计算速度选最快的：\n\n- 当Future集合中某个任务最快结束时，返回结果，返回第一名处理结果\n\n**结论**：\n\n- 使用Future之前提供的那点API就囊中羞涩，处理起来不够优雅，这时候还是让CompletableFuture以声明式的方式优雅的处理这些需求。\n- 从i到i++\n- Future能干的，CompletableFuture都能干\n\n## CompletableFuture（异步回调）\n\n### 理论\n\n![](http://liyiru.site/upload/20240528_23553739.png)\n\n\n#### Future \n\nFuture是Java5新加的一个接口，它提供一种异步并行计算的功能，如果主线程需要执行一个很耗时的计算任务，我们会就可以通过Future把这个任务放进异步线程中执行，主线程继续处理其他任务或者先行结束，再通过Future获取计算结果。\n\nFutrue 在 Java 里面，通常用来表示一个异步任务的引用，比如我们将任务提交到线程池里面，然后我们会得到一个 Futrue，在 Future 里面有 isDone 方法来 判断任务是否处理结束，还有 get 方法可以一直阻塞直到任务结束然后获取结果，但整体来说这种方式，还是同步的，因为需要客户端不断阻塞等待或者不断轮询才能知道任务是否完成。\n\n##### Future 缺点\n\n（1）不支持手动完成\n我提交了一个任务，但是执行太慢了，我通过其他路径已经获取到了任务结果，现在没法把这个任务结果通知到正在执行的线程，所以必须主动取消或者一直等待它执行完成\n（2）不支持进一步的非阻塞调用\n通过 Future 的 get 方法会一直阻塞到任务完成，但是想在获取任务之后执行额外的任务，因为 Future 不支持回调函数，所以无法实现这个功能\n（3）不支持链式调用\n对于 Future 的执行结果，我们想继续传到下一个 Future 处理使用，从而形成一个链式的 pipline 调用，这在 Future 中是没法实现的。\n（4）不支持多个 Future 合并\n比如我们有 10 个 Future 并行执行，我们想在所有的 Future 运行完毕之后，执行某些函数，是没法通过 Future 实现的。\n（5）不支持异常处理\nFuture 的 API 没有任何的异常处理的 api，所以在异步运行时，如果出了问题是不好定位的。\n\n#### CompletionStage\n\n用于**异步执行中的阶段处理**。这个接口定义了一组方法，这些方法使得在一个阶段执行结束后，可以继续执行下一个阶段，或者对结果进行转换以产生新的结果。\n\n具体来说，CompletionStage的接口方法可以分为几类：\n\n基于结果的转换：\n\n- `apply` 和 `combine` 方法允许将上一阶段的结果作为参数传递给指定的函数，并返回新的结果。这些方法在Function或BiFunction类型的接口参数下工作。\n\n基于结果的消费：\n\n- `accept` 方法允许将上一阶段的结果作为参数传递给指定的函数，但不返回结果。这种方法在Consumer或BiConsumer类型的接口参数下工作。\n\n不依赖结果的执行：\n\n- `run` 方法允许在上一阶段执行结束后，执行指定的操作，但不依赖于一阶段的结果。这个方法的接口参数为Runnable类型。\n\n异步执行：\n\n- `async` 方法允许异步执行阶段任务，可以选择指定线程池或不指定。\n\n组合多个阶段：\n\n- `both` 方法表示当前两个阶段都完成后才执行下一阶段。\n- `either` 方法表示当前两个阶段中任一完成后就执行下一阶段。\n- `compose` 方法基于上阶段的执行完状态，执行下一阶段。\n\n异常处理：\n\n- `handle` 和 `exceptionally` 方法允许基于上阶段的执行完状态和结果，消费其正常或异常结果。\n\nCompletionStage的实现类，如CompletableFuture，扩展了这个接口，提供了更多的功能和灵活性。通过使用CompletionStage和它的实现类，你可以更轻松地创建复杂的异步执行流程和任务组合。\n\n总之，CompletionStage是Java 8中用于处理异步执行阶段和结果的重要接口，它提供了一组强大的方法来定义和管理异步任务之间的关系和转换。\n\n#### CompletableFuture 简介\n\nCompletableFuture 在 Java 里面被用于异步编程，异步通常意味着非阻塞，可以使得我们的任务单独运行在与主线程分离的其他线程中，并且通过回调可以在主线程中得到异步任务的执行状态，是否完成，和是否异常等信息。CompletableFuture 实现了 Future, CompletionStage 接口，实现了 Future接口就可以兼容现在有线程池框架，而 CompletionStage 接口才是异步编程的接口抽象，里面定义多种异步方法，通过这两者集合，从而打造出了强大的CompletableFuture 类。\n\n####  CompletableFuture对Future的改进\n\nget()方法在Future计算完成之前会一直处在阻塞状态下，阻塞的方式和异步编程的设计理念相违背。\n\nisDene()方法容易耗费cpu资源（cpu空转）\n\n对于真正的异步处理我们希望是可以通过传入回调函数，在Future结束时自动调用该回调函数，这样，我们就不用等待结果\n\njdk8设计出CompletableFuture，CompletableFuture提供了一种观察者模式类似的机制，可以让任务执行完成后通知监听的一方。\n\n#### CompletableFuture和CompletionStage\n\n**接口CompletionStage**\n\n- 代表异步计算过程中的某一个阶段，一个阶段完成以后可能会触发另外一个阶段。\n- 一个阶段的执行可能是被单个阶段的完成触发，也可能是由多个阶段一起触发\n\n**类CompletableFuture**\n\n- 提供了非常强大的Future的扩展功能，可以帮助我们简化异步编程的复杂性，并且提供了函数式编程的能力，可以通过回调的方式处理计算结果，也提供了转换和组合CompletableFuture的方法\n- 它可能代表一个明确完成的Future，也可能代表一个完成阶段（CompletionStage），它支持在计算完成以后触发一些函数或执行某些动作\n\n### 语法\n\nJava 8 引入的一个类，用于支持异步编程和构建异步操作的结果。它提供了一种简洁的方式来处理异步任务，并且能够方便地进行任务之间的组合、串行执行、并行执行以及异常处理。\n\n**创建 CompletableFuture：**\n\n- `static CompletableFuture<Void> runAsync(Runnable runnable)`：异步执行一个没有返回值的任务。\n- `static <U> CompletableFuture<U> supplyAsync(Supplier<U> supplier)`：异步执行一个有返回值的任务。\n\n**处理异步结果：**\n\n- `CompletableFuture<T> thenApply(Function<? super T,? extends U> fn)`：当上一个任务完成时，对其结果执行给定的函数。\n- `CompletableFuture<Void> thenAccept(Consumer<? super T> action)`：当上一个任务完成时，对其结果执行给定的操作，但不返回任何结果。\n- `CompletableFuture<Void> thenRun(Runnable action)`：当上一个任务完成时，执行给定的操作，但不接收上一个任务的结果。\n- `CompletableFuture<U> thenCompose(Function<? super T,? extends CompletionStage<U>> fn)`：当上一个任务完成时，对其结果执行给定的函数，返回一个新的 `CompletableFuture`。\n\n**组合多个 CompletableFuture：**\n\n- `CompletableFuture<U> thenCombine(CompletionStage<? extends V> other, BiFunction<? super T,? super U,? extends V> fn)`：当当前任务和另一个任务都完成时，对它们的结果执行给定的函数。\n- `CompletableFuture<Void> thenAcceptBoth(CompletionStage<? extends U> other, BiConsumer<? super T,? super U> action)`：当当前任务和另一个任务都完成时，对它们的结果执行给定的操作，但不返回任何结果。\n- `CompletableFuture<Void> runAfterBoth(CompletionStage<?> other, Runnable action)`：当当前任务和另一个任务都完成时，执行给定的操作，但不接收任何结果。\n- `CompletableFuture<Void> acceptEither(CompletionStage<? extends T> other, Consumer<? super T> action)`：当任意一个任务完成时，对其结果执行给定的操作，但不返回任何结果。\n- `CompletableFuture<Void> runAfterEither(CompletionStage<?> other, Runnable action)`：当任意一个任务完成时，执行给定的操作，但不接收任何结果。\n\n**异常处理：**\n\n- `CompletableFuture<T> exceptionally(Function<Throwable,? extends T> fn)`：当异常发生时，执行给定的函数。\n- `CompletableFuture<T> handle(BiFunction<? super T,Throwable,? extends T> fn)`：当任务完成时，对其结果执行给定的函数，或者在出现异常时执行另一个函数。\n\n**等待所有任务完成：**\n\n- `static CompletableFuture<Void> allOf(CompletableFuture<?>... cfs)`：等待所有 `CompletableFuture` 都完成后返回一个新的 `CompletableFuture`。\n\n**等待任意任务完成：**\n\n- `static CompletableFuture<Object> anyOf(CompletableFuture<?>... cfs)`：等待任意一个 `CompletableFuture` 完成后返回一个新的 `CompletableFuture`。\n\n**取消任务：**\n\n- `boolean cancel(boolean mayInterruptIfRunning)`：尝试取消任务的执行。\n\n### 创建方法\n\n#### 基本使用\n\n```\n//同步调用\nCompletableFuture<Void> completableFuture1 = CompletableFuture.runAsync(()->{\n    System.out.println(Thread.currentThread().getName()+\" : CompletableFuture1\");\n});\ncompletableFuture1.get();\n\n//mq消息队列\n//异步调用\nCompletableFuture<Integer> completableFuture2 = CompletableFuture.supplyAsync(()->{\n    System.out.println(Thread.currentThread().getName()+\" : CompletableFuture2\");\n    //模拟异常\n    int i = 10/0;\n    return 1024;\n});\ncompletableFuture2.whenComplete((t,u)->{\n    System.out.println(\"------t=\"+t);\n    System.out.println(\"------u=\"+u);\n}).get();\n```\n\n#### runAsync\n\n方法用于异步地执行一个不返回结果的`Runnable`任务。\n\n```\nrunAsync(Runnable runnable)\n```\n\n- 接收一个`Runnable`对象作为参数。\n- 使用`ForkJoinPool.commonPool()`作为默认的线程池来异步执行这个任务。\n- 返回一个`CompletableFuture<Void>`，因为`Runnable`不返回任何值（即返回`void`）。\n\n```\nrunAsync(Runnable runnable, Executor executor)\n```\n\n- 除了接收一个`Runnable`对象作为参数外，还接收一个`Executor`对象来指定执行任务的线程池。\n- 使用指定的`Executor`来异步执行这个任务。\n- 同样返回一个`CompletableFuture<Void>`。\n\n#### supplyAsync\n\n方法用于异步地执行一个返回结果的`Supplier`任务。\n\n```\nsupplyAsync(Supplier<U> supplier)\n```\n\n- 接收一个`Supplier`对象作为参数，`Supplier`是一个函数式接口，它的`get()`方法返回一个结果。\n- 使用`ForkJoinPool.commonPool()`作为默认的线程池来异步执行这个任务。\n- 返回一个`CompletableFuture<U>`，其中`U`是`Supplier`的`get()`方法返回的类型。\n\n```\nsupplyAsync(Supplier<U> supplier, Executor executor)\n```\n\n- 除了接收一个`Supplier`对象作为参数外，还接收一个`Executor`对象来指定执行任务的线程池。\n- 使用指定的`Executor`来异步执行这个任务。\n- 返回一个`CompletableFuture<U>`。\n\n对于上述Executor参数说明：若没有指定，则使用默认的ForkJoinPoolcommonPool（）作为它的线程池执行异步代码，如果指定线程池，则使用我们自定义的或者特别指定的线程池执行异步代码\n\n```\npublic class CompletableFutureBuildDemo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n\n        CompletableFuture<Void> completableFuture = CompletableFuture.runAsync(() -> {\n            System.out.println(Thread.currentThread().getName());\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        },executorService);\n\n        System.out.println(completableFuture.get()); //null\n\n        CompletableFuture<String> objectCompletableFuture = CompletableFuture.supplyAsync(()->{\n            System.out.println(Thread.currentThread().getName());\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"hello supplyAsync\";\n        },executorService);\n\n        System.out.println(objectCompletableFuture.get());//hello supplyAsync\n\n        executorService.shutdown();\n\n    }\n}\n```\n\nCompletableFuture减少阻塞和轮询，可以传入回调对象，当异步任务完成或者发生异常时，自动调用回调对象的回调方法。\n\n```\npublic class CompletableFutureUseDemo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        CompletableFuture<Integer> completableFuture = CompletableFuture.supplyAsync(() -> {\n            System.out.println(Thread.currentThread().getName() + \"---come in\");\n            int result = ThreadLocalRandom.current().nextInt(10);\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            if (result > 5) { //模拟产生异常情况\n                int i = 10 / 0;\n            }\n            System.out.println(\"----------1秒钟后出结果\" + result);\n            return result;\n        }, executorService).whenComplete((v, e) -> {\n            if (e == null) {\n                System.out.println(\"计算完成 更新系统\" + v);\n            }\n        }).exceptionally(e -> {\n            e.printStackTrace();\n            System.out.println(\"异常情况：\" + e.getCause() + \" \" + e.getMessage());\n            return null;\n        });\n        System.out.println(Thread.currentThread().getName() + \"先去完成其他任务\");\n        executorService.shutdown();\n    }\n}\n\n/**\n * 无异常情况\n * pool-1-thread-1---come in\n * main先去完成其他任务\n * ----------1秒钟后出结果9\n * 计算完成 更新系统9\n */\n\n/**\n * 有异常情况\n *pool-1-thread-1---come in\n * main先去完成其他任务\n * java.util.concurrent.CompletionException: java.lang.ArithmeticException: / by zero\n * 异常情况：java.lang.ArithmeticException: / by zero java.lang.ArithmeticException: / by zero\n */\n```\n\nCompletableFuture优点：\n\n- 异步任务**结束**时，会自动回调某个对象的方法\n- 主线程设置好回调后，不用关心异步任务的执行，异步任务之间可以顺序执行\n- 异步任务**出错**时，会自动回调某个对象的方法\n\n#### 案例（电商网站比价）\n\n电商网站比价需求分析：\n\n1. 需求说明：\n\n2. 同一款产品，同时搜索出同款产品在各大电商平台的售价\n3. 同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少\n\n4. 输出返回：\n\n5. 出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<String>\n\n例如：《Mysql》 in jd price is 88.05  《Mysql》 in taobao price is 90.43\n\n1. 解决方案，对比同一个产品在各个平台上的价格，要求获得一个清单列表\n\n2. step by step，按部就班，查完淘宝查京东，查完京东查天猫....\n3. all in，万箭齐发，一口气多线程异步任务同时查询\n\n```\npackage com.bilibili.juc.cf;\n\nimport lombok.*;\nimport lombok.experimental.Accessors;\n\nimport java.awt.print.Book;\nimport java.math.BigDecimal;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\n/**\n *\n * 案例说明：电商比价需求，模拟如下情况：\n *\n * 1需求：\n *  1.1 同一款产品，同时搜索出同款产品在各大电商平台的售价;\n *  1.2 同一款产品，同时搜索出本产品在同一个电商平台下，各个入驻卖家售价是多少\n *\n * 2输出：出来结果希望是同款产品的在不同地方的价格清单列表，返回一个List<String>\n * 《mysql》 in jd price is 88.05\n * 《mysql》 in dangdang price is 86.11\n * 《mysql》 in taobao price is 90.43\n *\n * 3 技术要求\n *   3.1 函数式编程\n *   3.2 链式编程\n *   3.3 Stream流式计算\n */\npublic class CompletableFutureMallDemo\n{\n    static List<NetMall> list = Arrays.asList(\n            new NetMall(\"jd\"),\n            new NetMall(\"dangdang\"),\n            new NetMall(\"taobao\"),\n            new NetMall(\"pdd\"),\n            new NetMall(\"tmall\")\n    );\n\n    /**\n     * step by step 一家家搜查\n     * List<NetMall> ----->map------> List<String>\n     * @param list\n     * @param productName\n     * @return\n     */\n    public static List<String> getPrice(List<NetMall> list,String productName)\n    {\n        //《mysql》 in taobao price is 90.43\n        return list\n                .stream()\n                .map(netMall ->\n                        String.format(productName + \" in %s price is %.2f\",\n                                netMall.getNetMallName(),\n                                netMall.calcPrice(productName)))\n                .collect(Collectors.toList());\n    }\n\n    /**\n     * List<NetMall> ----->List<CompletableFuture<String>>------> List<String>\n     * @param list\n     * @param productName\n     * @return\n     */\n    public static List<String> getPriceByCompletableFuture(List<NetMall> list,String productName)\n    {\n        return list.stream().map(netMall ->\n                CompletableFuture.supplyAsync(() -> String.format(productName + \" in %s price is %.2f\",\n                netMall.getNetMallName(),\n                netMall.calcPrice(productName))))\n                .collect(Collectors.toList())\n                .stream()\n                .map(s -> s.join())\n                .collect(Collectors.toList());\n    }\n\n\n    public static void main(String[] args)\n    {\n        long startTime = System.currentTimeMillis();\n        List<String> list1 = getPrice(list, \"mysql\");\n        for (String element : list1) {\n            System.out.println(element);\n        }\n        long endTime = System.currentTimeMillis();\n        System.out.println(\"----costTime: \"+(endTime - startTime) +\" 毫秒\");\n\n        System.out.println(\"--------------------\");\n\n        long startTime2 = System.currentTimeMillis();\n        List<String> list2 = getPriceByCompletableFuture(list, \"mysql\");\n        for (String element : list2) {\n            System.out.println(element);\n        }\n        long endTime2 = System.currentTimeMillis();\n        System.out.println(\"----costTime: \"+(endTime2 - startTime2) +\" 毫秒\");\n    }\n}\n\nclass NetMall\n{\n    @Getter\n    private String netMallName;\n\n    public NetMall(String netMallName)\n    {\n        this.netMallName = netMallName;\n    }\n\n    public double calcPrice(String productName)\n    {\n        try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\n\n        return ThreadLocalRandom.current().nextDouble() * 2 + productName.charAt(0);\n    }\n}\n```\n\n\n\n### 常用方法\n\n#### 获得结果和触发计算\n\n- 获取结果\n\n  - public T get()\n\n  - public T get(long timeout,TimeUnit unit)\n\n  - public T join() --->和get一样的作用，只是不需要抛出异常\n\n  - public T getNow(T valuelfAbsent) --->计算完成就返回正常值，否则返回备胎值（传入的参数），立即获取结果不阻塞\n\n- 主动触发计算\n  - public boolean complete(T value) ---->是否打断get方法立即返回括号值\n\n#### 对计算结果进行处理\n\n- thenApply --->计算结果存在依赖关系，这两个线程串行化---->由于存在依赖关系（当前步错，不走下一步），当前步骤有异常的话就叫停\n- handle --->计算结果存在依赖关系，这两个线程串行化---->有异常也可以往下走一步\n\n#### 对计算结果进行消费\n\n- 接受任务的处理结果，并消费处理，无返回结果\n\n```\npublic class CompletableFutureApi2Demo {\n    public static void main(String[] args) {\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);\n        CompletableFuture.supplyAsync(() -> {\n            return 1;\n        }, threadPool).thenApply(f -> {\n            return f + 2;\n        }).thenApply(f -> {\n            return f + 2;\n        }).thenAccept(r -> {\n            System.out.println(r);//5\n        });\n    }\n}\n```\n\n- thenRun(Runnable runnable) :任务A执行完执行B，并且不需要A的结果\n- thenAccept(Consumer action): 任务A执行完执行B，B需要A的结果，但是任务B没有返回值\n- thenApply(Function fn): 任务A执行完执行B，B需要A的结果，同时任务B有返回值\n\n```\npublic class CompletableFutureApi2Demo {\n    public static void main(String[] args) {\n        System.out.println(CompletableFuture.supplyAsync(() -> \"result\").thenRun(() -> {}).join());//null\n        System.out.println(CompletableFuture.supplyAsync(() -> \"result\").thenAccept(r -> System.out.println(r)).join());//result null\n        System.out.println(CompletableFuture.supplyAsync(() -> \"result\").thenApply(f -> f + 2).join());//result2\n    }\n}\n```\n\nCompletableFuture和线程池说明\n\n- 如果没有传入自定义线程池，都用默认线程池ForkJoinPool\n\n- 传入一个线程池，如果你执行第一个任务时，传入了一个自定义线程池\n\n  - 调用thenRun方法执行第二个任务时，则第二个任务和第一个任务时共用同一个线程池\n\n  - 调用thenRunAsync执行第二个任务时，则第一个任务使用的是你自定义的线程池，第二个任务使用的是ForkJoin线程池\n\n- 备注：可能是线程处理太快，系统优化切换原则， 直接使用main线程处理，thenAccept和thenAcceptAsync，thenApply和thenApplyAsync等，之间的区别同理。\n\n#### 对计算速度进行选用\n\n- 谁快用谁\n- applyToEither\n\n```\npublic class CompletableFutureApiDemo {\n    public static void main(String[] args) {\n        ExecutorService threadPool = Executors.newFixedThreadPool(3);\n        CompletableFuture<String> playA = CompletableFuture.supplyAsync(() -> {\n            try {\n                System.out.println(\"A come in\");\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"playA\";\n        }, threadPool);\n\n\n        CompletableFuture<String> playB = CompletableFuture.supplyAsync(() -> {\n            try {\n                System.out.println(\"B come in\");\n                TimeUnit.SECONDS.sleep(3);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return \"playB\";\n        }, threadPool);\n\n        CompletableFuture<String> result = playA.applyToEither(playB, f -> {\n            return f + \" is winner\";\n        });\n\n        /**\n         * A come in\n         * B come in\n         * main-----------winner:playA is winner\n         */\n        System.out.println(Thread.currentThread().getName() + \"-----------winner:\" + result.join());\n    }\n}\n```\n\n\n\n#### 对计算结果进行合并\n\n- 两个CompletableStage任务都完成后，最终能把两个任务的结果一起交给thenCombine来处理\n- 先完成的先等着，等待其他分支任务\n\n```\npublic class CompletableFutureApi3Demo {\n    public static void main(String[] args) {\n        CompletableFuture<Integer> completableFuture1 = CompletableFuture.supplyAsync(() -> {\n            System.out.println(Thread.currentThread().getName() + \" 启动\");\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return 10;\n        });\n\n        CompletableFuture<Integer> completableFuture2 = CompletableFuture.supplyAsync(() -> {\n            System.out.println(Thread.currentThread().getName() + \" 启动\");\n            try {\n                TimeUnit.SECONDS.sleep(2);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            return 20;\n        });\n\n        CompletableFuture<Integer> finalResult = completableFuture1.thenCombine(completableFuture2, (x, y) -> {\n            System.out.println(\"----------开始两个结果合并\");\n            return x + y;\n        });\n        System.out.println(finalResult.join());\n\n    }\n}\n```',32,'JUC','juc',1,41,0,0,'2024-05-28 23:57:24','2024-05-28 23:57:24'),(37,'集合线程安全','','http://liyiru.site/upload/20240529_00123484.jpg','## 集合线程安全\n\n### 理论\n\n#### （1）“动态数组”机制\n\no 它内部有个“volatile 数组”(array)来保持数据。在“添加/修改/删除”数据时，都会新建一个数组，并将更新后的数据拷贝到新建的数组中，最后再将该数组赋值给“volatile 数组”, 这就是它叫做 CopyOnWriteArrayList 的原因\no 由于它在“添加/修改/删除”数据时，都会新建数组，所以涉及到修改数据的操作，CopyOnWriteArrayList 效率很低；但是单单只是进行遍历查找的话，效率比较高。\n\n#### （2）“线程安全”机制\n\no 通过 volatile 和互斥锁来实现的。\no 通过“volatile 数组”来保存数据的。一个线程读取 volatile 数组时，总能看到其它线程对该 volatile 变量最后的写入；就这样，通过 volatile 提供了“读取到的数据总是最新的”这个机制的保证。\no 通过互斥锁来保护数据。在“添加/修改/删除”数据时，会先“获取互斥锁”，再修改完毕之后，先将数据更新到“volatile 数组”中，然后再“释放互斥锁”，就达到了保护数据的目的。\n\n### 语法\n\n#### Vector\n\nVector 是矢量队列，它是 JDK1.0 版本添加的类。继承于 AbstractList，实现了 List, RandomAccess, Cloneable 这些接口。 Vector 继承了 AbstractList，实现了 List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。 Vector 实现了 RandmoAccess 接口，即提供了随机访问功能。RandmoAccess 是 java 中用来被 List 实现，为 List 提供快速访问功能的。在Vector 中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。 Vector 实现了 Cloneable 接口，即实现 clone()函数。它能被克隆。\n\n```\nList<String> list = new Vector<>();\n```\n\n#### Collections\n\nCollections 提供了方法 synchronizedList 保证 list 是同步线程安全的\n\n```\nList list = Collections.synchronizedList(new ArrayList<>());\n```\n\n#### CopyOnWriteArrayList\n\n它相当于线程安全的 ArrayList。和 ArrayList 一样，它是个可变数组；但是和ArrayList 不同的时，它具有以下特性：\n\n1. 它最适合于具有以下特征的应用程序：List 大小通常保持很小，只读操作远多于可变操作，需要在遍历期间防止线程间的冲突。\n2. 它是线程安全的。\n3. 因为通常需要复制整个基础数组，所以可变操作（add()、set() 和 remove()等等）的开销很大。\n4. 迭代器支持 hasNext(), next()等不可变操作，但不支持可变 remove()等操作。\n5. 使用迭代器进行遍历的速度很快，并且不会与其他线程发生冲突。在构造迭代器时，迭代器依赖于不变的数组快照。\n6. 独占锁效率低：采用读写分离思想解决。\n7. 写线程获取到锁，其他写线程阻塞。\n\n复制思想：当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行 Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这时候会抛出来一个新的问题，也就是数据不一致的问题。如果写线程还没来得及写回内存，其他的线程就会读到了脏数据。\n\n```\nList<String> list = new CopyOnWriteArrayList<>();\n```',32,'JUC','juc',1,40,0,0,'2024-05-29 00:12:35','2024-05-29 00:12:35'),(38,'强引用、软引用、弱引用、虚引用、终结器引用','','http://liyiru.site/upload/20240530_20204822.jpg','## 基本概念\n\n1. 强引用（Strong Reference）：\n   - 定义：最常见的引用类型，通过普通变量名对对象的引用即为强引用。\n   - 特性：只要强引用存在，垃圾回收器就不会回收被引用的对象。即使内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，也不会靠回收具有强引用的对象来解决内存不足的问题。\n   - 示例：`Object obj = new Object();`\n2. 软引用（Soft Reference）：\n   - 定义：如果内存空间足够，垃圾回收器就不会回收被软引用指向的对象；如果内存空间不足，就会回收这些对象的内存。\n   - 特性：可以用来实现内存敏感的高速缓存。\n   - 示例：软引用常常和引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n3. 弱引用（Weak Reference）：\n   - 定义：与软引用的主要区别在于，只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间是否充足，都会回收它的内存。\n   - 特性：弱引用同样可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n4. 虚引用（Phantom Reference）：\n   - 定义：形同虚设，并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。\n   - 特性：虚引用主要用来跟踪对象被垃圾回收器回收的活动。与软引用和弱引用的一个主要区别在于，虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\n5. 终结器引用（Finalizer Reference）：\n   - 定义：当对象变得不可达时，如果对象重写了finalize方法，它会被加入到一个由垃圾回收器维护的特殊队列中，这是通过终结器引用实现的。\n   - 特性：主要用于在对象被垃圾回收前执行一些清理资源的操作。但需要注意的是，过度依赖finalize方法可能导致性能问题和资源泄漏，因为finalize方法的执行时机是不确定的，并且Java 9开始已经不建议使用finalize方法了。\n\n## 基础使用\n\n### 1. 强引用 (Strong Reference)\n\n强引用是Java中最常见的引用类型。当一个对象具有强引用时，垃圾回收器（GC）永远不会回收它，即使系统出现内存不足的情况，也不会通过回收具有强引用的对象来解决内存问题。这意味着只要强引用存在，对象就会一直存在于内存中。\n\n**示例**：\n\n```java\nObject strongRef = new Object(); // 创建一个强引用\n```\n\n### 2. 软引用 (Soft Reference)\n\n软引用是用来描述一些还有用但并非必需的对象。当系统内存足够时，垃圾回收器不会回收软引用指向的对象；但是当系统内存不足时，垃圾回收器会回收这些对象的内存。软引用常常用于实现内存敏感的高速缓存。\n\n**示例**：\n\n```java\nSoftReference<Object> softRef = new SoftReference<>(new Object()); // 创建一个软引用  \nObject referent = softRef.get(); // 获取软引用指向的对象，如果对象已经被回收则返回null\n```\n\n### 3. 弱引用 (Weak Reference)\n\n弱引用也是用来描述非必需对象的，但与软引用不同，弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾回收器工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。\n\n**示例**：\n\n```java\nWeakReference<Object> weakRef = new WeakReference<>(new Object()); // 创建一个弱引用  \nObject referent = weakRef.get(); // 获取弱引用指向的对象，如果对象已经被回收则返回null\n```\n\n### 4. 虚引用 (Phantom Reference)\n\n虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。虚引用必须和引用队列（ReferenceQueue）联合使用。\n\n**示例**：\n\n```java\nReferenceQueue<Object> queue = new ReferenceQueue<>();  \nPhantomReference<Object> phantomRef = new PhantomReference<>(new Object(), queue);  \n// 注意：你不能通过phantomRef.get()来获取对象实例，因为总是返回null  \n  \n// 要检测对象是否被回收，需要轮询检查引用队列  \nReference<? extends Object> ref = queue.poll();  \nif (ref != null) {  \n    // 对象被回收了  \n}\n```\n\n### 5. 终结器引用 (Finalizer Reference)\n\n终结器引用是Java内部用来在对象被垃圾收集之前调用其`finalize()`方法的一个机制。但请注意，从Java 9开始，`finalize()`方法已被弃用，因为它可能会导致不可预测的行为和性能问题。现代的Java应用程序应该避免使用`finalize()`方法，并使用try-with-resources语句、AutoCloseable接口或其他清理机制来管理资源。\n\n**示例**（不推荐使用）：\n\n```java\n@Deprecated  \npublic class MyClass {  \n    @Override  \n    protected void finalize() throws Throwable {  \n        super.finalize();  \n        // 清理资源的代码（不推荐使用）  \n    }  \n}\n```\n\n\n\n## 案例分析\n\n```\npackage com.liyiru;\n\nimport java.lang.ref.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\nclass MyObject\n{\n    //这个方法一般不用复写，我们只是为了教学给大家演示案例做说明\n    @Override\n    protected void finalize() throws Throwable\n    {\n        // finalize的通常目的是在对象被不可撤销地丢弃之前执行清理操作。\n        System.out.println(\"-------invoke finalize method~!!!\");\n    }\n}\n\n\npublic class ReferenceDemo\n{\n	//虚引用\n    public static void main(String[] args)\n    {\n        MyObject myObject = new MyObject();\n        ReferenceQueue<MyObject> referenceQueue = new ReferenceQueue<>();\n        PhantomReference<MyObject> phantomReference = new PhantomReference<>(myObject,referenceQueue);\n        //System.out.println(phantomReference.get());\n\n        List<byte[]> list = new ArrayList<>();\n\n        new Thread(() -> {\n            while (true){\n                list.add(new byte[1 * 1024 * 1024]);\n                try { TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); }\n                System.out.println(phantomReference.get()+\"\\t\"+\"list add ok\");\n            }\n        },\"t1\").start();\n\n        new Thread(() -> {\n            while (true){\n                Reference<? extends MyObject> reference = referenceQueue.poll();\n                if(reference != null){\n                    System.out.println(\"-----有虚对象回收加入了队列\");\n                    break;\n                }\n            }\n        },\"t2\").start();\n\n    }\n\n\n	//弱引用\n    private static void weakReference()\n    {\n        WeakReference<MyObject> weakReference = new WeakReference<>(new MyObject());\n        System.out.println(\"-----gc before 内存够用： \"+weakReference.get());\n\n        System.gc();\n        //暂停几秒钟线程\n        try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\n\n        System.out.println(\"-----gc after 内存够用： \"+weakReference.get());\n    }\n\n	//软引用\n    private static void softReference()\n    {\n        SoftReference<MyObject> softReference = new SoftReference<>(new MyObject());\n        //System.out.println(\"-----softReference:\"+softReference.get());\n\n        System.gc();\n        try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }\n        System.out.println(\"-----gc after内存够用: \"+softReference.get());\n\n        try\n        {\n            byte[] bytes = new byte[20 * 1024 * 1024];//20MB对象\n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            System.out.println(\"-----gc after内存不够: \"+softReference.get());\n        }\n    }\n	\n	//强引用\n    private static void strongReference()\n    {\n        MyObject myObject = new MyObject();\n        System.out.println(\"gc before: \"+myObject);\n\n        myObject = null;\n        System.gc();//人工开启GC，一般不用\n\n        //暂停毫秒\n        try { TimeUnit.MILLISECONDS.sleep(500); } catch (InterruptedException e) { e.printStackTrace(); }\n\n        System.out.println(\"gc after: \"+myObject);\n    }\n}\n\n```',31,'JVM','垃圾回收机制',1,70,0,0,'2024-05-30 20:20:49','2024-05-30 20:20:49'),(39,'线程创建','','http://liyiru.site/upload/20240603_20445234.jpg','## 线程创建方式\n\n##### **继承Thread类**：\n\n这种方式需要创建一个类，继承自Thread类，并重写其run()方法来定义线程的执行逻辑。然后可以创建该类的实例并调用start()方法启动线程。\n\n```\nclass MyThread extends Thread {\n    public void run() {\n        // 线程执行的逻辑\n    }\n}\n\nMyThread thread = new MyThread();\nthread.start();\n```\n\n##### **实现Runnable接口**：\n\n这种方式需要创建一个类，实现Runnable接口，并实现其run()方法来定义线程的执行逻辑。然后可以创建该类的实例并将其作为参数传递给Thread类的构造函数，最后调用start()方法启动线程。\n\n```\nclass MyRunnable implements Runnable {\n    public void run() {\n        // 线程执行的逻辑\n    }\n}\n\nThread thread = new Thread(new MyRunnable());\nthread.start();\n```\n\n##### **实现Callable接口**：\n\n与Runnable接口类似，但Callable接口的call()方法可以返回结果或抛出异常。可以通过FutureTask类包装Callable对象，然后传递给Thread类进行启动。\n\n```\nclass MyCallable implements Callable<Integer> {\n    public Integer call() {\n        // 线程执行的逻辑\n        return result;\n    }\n}\n\nFutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());\nThread thread = new Thread(futureTask);\nthread.start();\n```\n\n##### **线程池创建**：\n\n使用线程池可以管理和复用线程，避免频繁创建和销毁线程带来的性能开销。可以通过Executors工厂类来创建不同类型的线程池，如FixedThreadPool、CachedThreadPool、ScheduledThreadPool等。\n\n```\nExecutorService executor = Executors.newFixedThreadPool(5);\nexecutor.execute(new MyRunnable());\nexecutor.shutdown();\n```\n\n\n\n## Object类\n\n**wait()方法**：使当前线程进入等待状态，直到其他线程调用notify()或notifyAll()方法唤醒它。wait()方法通常与synchronized关键字一起使用，在同步块中调用。\n\n```\nsynchronized(obj) {\n    obj.wait(); // 当前线程等待\n}\n```\n\n**wait(long timeout)**和**wait(long timeout, int nanos)**方法：与wait()方法类似，但是可以指定等待的时间，超过指定时间后会自动唤醒线程。\n\n```\nsynchronized(obj) {\n    obj.wait(1000); // 等待1秒钟，超时后自动唤醒\n}\n```\n\n\n\n**notify()方法**：唤醒在该对象上等待的单个线程。如果多个线程在对象上等待，那么只会唤醒其中一个线程，具体唤醒哪个线程是不确定的。\n\n```\nsynchronized(obj) {\n    obj.notify(); // 唤醒等待的线程\n}\n```\n\n**notifyAll()方法**：唤醒在该对象上等待的所有线程。这样所有等待的线程都有机会继续执行，但是只有一个线程能够获取对象的锁。\n\n```\nsynchronized(obj) {\n    obj.notifyAll(); // 唤醒所有等待的线程\n}\n```\n\n\n\n**stop()**：终止线程（已过时）、这种方式存在很大的缺点：容易丢失数据、因为这种方式是直接将线程杀死了，线程没有保存的数据将会丢失。不建议使用\n\n\n\n\n\n## Thread类\n\n\n\n### Thread类属性\n\n- ApartmentState：	获取或设置该线程的单元状态\n\n- CurrentContext：	获取线程正在其中执行的当前上下文\n\n- CurrentThread：	获取当前正在运行的线程\n\n- IsAlive：	获取一个值，该值指示当前线程的执行状态\n\n- ManagedThreadId：	获取当前托管线程的唯一标识符\n\n- Name：	获取或设置线程的名称\n\n- Priority：	获取或设置一个值，该值指示x线程的调度优先级\n\n  - 最低优先级1\n\n  - 默认优先级是5\n\n  - 最高优先级10\n\n- ThreadState：	获取一个值，该值包含当前线程的状态\n\n\n\n### Thread类方法\n\n**start()**：启动线程，使其进入可执行状态，当CPU调度到该线程时，会执行其run()方法。\n\n```\nThread thread = new Thread(new MyRunnable());\nthread.start();\n```\n\n**run()**：定义线程的执行逻辑，需要在自定义的Thread类中重写该方法。\n\n```\nclass MyThread extends Thread {\n    public void run() {\n        // 线程执行的逻辑\n    }\n}\n```\n\n**join()**：等待该线程终止。在当前线程中调用另一个线程的join()方法，会使当前线程阻塞，直到另一个线程执行完毕。\n\n```\nThread thread = new Thread(new MyRunnable());\nthread.start();\nthread.join(); // 等待thread线程执行完毕\n```\n\n**sleep(long millis)和sleep(long millis, int nanos)**：使当前线程暂停执行指定的时间。注意，sleep()方法不会释放对象锁。\n\n```\nThread.sleep(1000); // 暂停1秒钟\n```\n\n**interrupt()**：中断该线程。通常与线程的中断机制一起使用，通过设置线程的中断状态来请求线程停止执行。\n\n```\nthread.interrupt(); // 中断线程\n```\n\n**isInterrupted()和interrupted()**：用于检查线程的中断状态。isInterrupted()检查指定线程的中断状态，而interrupted()检查当前线程的中断状态，并清除中断状态。\n\n```\nif (Thread.currentThread().isInterrupted()) {\n    // 线程已被中断\n}\n```\n\n**yield()**：暂停当前正在执行的线程，并允许其他线程执行。该方法会提示线程调度器当前线程愿意让出CPU资源，但不保证线程调度器一定会满足这一愿望。\n\n```\nThread.yield(); // 暂停当前线程，让出CPU资源\n```\n\n\n\n## Callable\n\n### 理论\n\n#### （1）callable原理分析\n\n##### Future 接口\n\n当 call（）方法完成时，结果必须存储在主线程已知的对象中，以便主线程可以知道该线程返回的结果。为此，可以使用 Future 对象。\n将 Future 视为保存结果的对象–它可能暂时不保存结果，但将来会保存（一旦Callable 返回）。Future 基本上是主线程可以跟踪进度以及其他线程的结果的一种方式。要实现此接口，必须重写 5 种方法，这里列出了重要的方法,如下:\n• public boolean cancel（boolean mayInterrupt）：用于停止任务。如果尚未启动，它将停止任务。如果已启动，则仅在mayInterrupt 为 true时才会中断任务。\n• public Object get（）抛出 InterruptedException，ExecutionException：用于获取任务的结果。如果任务完成，它将立即返回结果，否则将等待任务完成，然后返回结果。\n\n• public boolean isDone（）：如果任务完成，则返回 true，否则返回 false可以看到 Callable 和 Future 做两件事-Callable 与 Runnable 类似，因为它封装了要在另一个线程上运行的任务，而 Future 用于存储从另一个线程获得的结果。实际上，future 也可以与 Runnable 一起使用。要创建线程，需要 Runnable。为了获得结果，需要 future。\n\n##### FutureTask\n\nJava 库具有具体的 FutureTask 类型，该类型实现 Runnable 和 Future，并方便地将两种功能组合在一起。 可以通过为其构造函数提供 Callable 来创建FutureTask。然后，将 FutureTask 对象提供给 Thread 的构造函数以创建Thread 对象。因此，间接地使用 Callable 创建线程。\n\n#### （2）callable应用场景\n\n• 在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成, 当主线程将来需要时，就可以通过 Future对象获得后台作业的计算结果或者执行状态\n• 一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果\n• 仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法。一旦计算完成，就不能再重新开始或取消计算。get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常。\n• 只计算一次\n\n#### （3）核心原理:\n\n在主线程中需要执行比较耗时的操作时，但又不想阻塞主线程时，可以把这些作业交给 Future 对象在后台完成\n• 当主线程将来需要时，就可以通过 Future 对象获得后台作业的计算结果或者执行状态\n• 一般 FutureTask 多用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。\n• 仅在计算完成时才能检索结果；如果计算尚未完成，则阻塞 get 方法\n• 一旦计算完成，就不能再重新开始或取消计算\n• get 方法而获取结果只有在计算完成时获取，否则会一直阻塞直到任务转入完成状态，然后会返回结果或者抛出异常\n• get 只计算一次,因此 get 方法放到最后\n\n### 语法\n\n与Runnable接口类似，但Callable接口的call()方法可以返回结果或抛出异常。可以通过FutureTask类包装Callable对象，然后传递给Thread类进行启动。\n\n```\nclass MyCallable implements Callable<Integer> {\n    public Integer call() {\n        // 线程执行的逻辑\n        return result;\n    }\n}\n\nFutureTask<Integer> futureTask = new FutureTask<>(new MyCallable());\nThread thread = new Thread(futureTask);\nthread.start();\n```\n\n\n\n## 线程池\n\n### 理论\n\n#### （1）线程池\n\n一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。\n\n#### （2）线程池的优势\n\n 线程池做的工作只要是控制运行的线程数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量，超出数量的线程排队等候，等其他线程执行完毕，再从队列中取出任务来执行。\n\n#### （3）线程池的特点\n\n• 降低资源消耗: 通过重复利用已创建的线程降低线程创建和销毁造成的销耗。\n• 提高响应速度: 当任务到达时，任务可以不需要等待线程创建就能立即执行。\n• 提高线程的可管理性: 线程是稀缺资源，如果无限制的创建，不仅会销耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n#### （4）线程池底层工作原理(重要)\n\n![](http://liyiru.site/upload/20240603_20435359.png)\n\n\n1. 在创建了线程池后，线程池中的线程数为零\n\n2. 当调用 execute()方法添加一个请求任务时，线程池会做出如下判断： \n\n  2.1 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务；\n  2.2 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入\n  队列； \n\n  2.3 如果这个时候队列满了且正在运行的线程数量还小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； \n\n  2.4 如果队列满了且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会启动饱和拒绝策略来执行。\n\n3. 当一个线程完成任务时，它会从队列中取下一个任务来执行\n\n4. 当一个线程无事可做超过一定的时间（keepAliveTime）时，线程会判断：\n   4.1 如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。 \n\n  4.2所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。\n\n#### （5）创建线程池推荐 ThreadPoolExecutor而不是 Executors\n\n项目中创建多线程时，使用常见的三种线程池创建方式，单一、可变、定长都有一定问题，原因是 FixedThreadPool 和 SingleThreadExecutor 底层都是用LinkedBlockingQueue 实现的，这个队列最大长度为 Integer.MAX_VALUE，容易导致 OOM。所以实际生产一般自己通过 ThreadPoolExecutor 的 7 个参数，自定义线程池\n\n### 线程池相关类\n\nJava 中的线程池是通过 Executor 框架实现的，该框架中用到了 Executor，Executors，ExecutorService，ThreadPoolExecutor 这几个类\n\n\n![](http://liyiru.site/upload/20240603_20441474.png)\n\n\n#### Executor\n\n一个执行提交的任务的对象的简单接口。它提供了一种将任务提交与执行策略分离的方式，使得可以方便地实现不同的任务调度和执行策略。\n\n**void execute(Runnable command)**：用于执行传入的任务。具体任务的执行方式可以由 `Executor` 的实现类来决定，例如同步执行、异步执行、并行执行等。\n\n#### Executors\n\n用于创建各种类型的线程池。它提供了一系列静态工厂方法，用于创建不同配置的线程池，从而简化了线程池的创建和管理过程。\n\n1. **`newCachedThreadPool()`：** 创建一个可缓存的线程池，线程数量根据需求动态调整。如果线程池的线程数量超过了任务需求，多余的线程将会被回收，如果需要，线程池将会创建新的线程。\n2. **`newFixedThreadPool(int nThreads)`：** 创建一个固定大小的线程池，线程数量固定，不会随着任务的增加而增加。当所有线程都处于活动状态时，新任务将会在队列中等待。\n3. **`newSingleThreadExecutor()`：** 创建一个单线程的线程池，该线程池只有一个工作线程，保证所有任务按顺序执行。\n4. **`newScheduledThreadPool(int corePoolSize)`：** 创建一个固定大小的线程池，可以执行定时任务或者周期性任务。\n\n#### ExecutorService\n\n扩展了 `Executor` 接口，提供了更丰富的任务提交、执行和管理功能。相比于 `Executor` 接口，`ExecutorService` 接口更适合于需要管理任务执行状态、获取任务执行结果等场景。\n\n1. **`submit(Runnable task)`：** 提交一个 Runnable 任务给线程池执行，并返回一个表示该任务执行情况的 Future 对象。\n2. **`submit(Callable<T> task)`：** 提交一个 Callable 任务给线程池执行，并返回一个表示该任务执行情况的 Future 对象，可以通过该对象获取任务执行的结果。\n3. **`invokeAll(Collection<? extends Callable<T>> tasks)`：** 执行给定的任务集合，并返回一个包含 Future 对象的列表，每个 Future 对象表示相应任务的执行情况。\n4. **`invokeAny(Collection<? extends Callable<T>> tasks)`：** 执行给定的任务集合，返回其中某一个任务的执行结果，无法保证返回的是哪个任务的结果。\n5. **`shutdown()`：** 立即关闭线程池，并拒绝接受新任务，但会等待已提交的任务执行完毕。\n6. **`shutdownNow()`：** 尝试立即关闭线程池，取消所有正在执行的任务，并且不再处理等待中的任务。\n7. **`isShutdown()`：** 判断线程池是否已经关闭。\n8. **`isTerminated()`：** 判断所有任务是否已经执行完毕，或者线程池是否已经被关闭。\n\n#### ThreadPoolExecutor\n\n提供了一个灵活而强大的线程池管理机制，可以用来管理和复用线程，从而有效地处理并发任务。\n\n通过合理地配置这些参数，可以根据实际情况创建出满足需求的线程池。`ThreadPoolExecutor` 提供了非常灵活和强大的线程池管理机制，适用于各种多线程场景下的任务调度和执行。\n\n##### 参数：\n\n1. **corePoolSize（核心线程数）：** 线程池中始终保持的活动线程数，即使它们处于空闲状态。如果提交的任务数多于核心线程数，线程池会根据情况创建新的线程来处理任务，直到达到最大线程数。\n2. **maximumPoolSize（最大线程数）：** 线程池允许的最大线程数，包括核心线程数和额外创建的线程数。当队列满了且当前线程数小于最大线程数时，线程池会创建新的线程来处理任务，直到达到最大线程数。\n3. **keepAliveTime（线程空闲时间）：** 当线程池中的线程数量超过核心线程数时，多余的空闲线程在被终止之前等待新任务的最长时间。超过这个时间后，空闲线程将被终止直到线程池中的线程数等于核心线程数。\n4. **unit（时间单位）：** 空闲时间的时间单位。\n5. **workQueue（工作队列）：** 用于保存等待执行的任务的阻塞队列。当线程池中的线程数达到核心线程数时，新提交的任务会被放入工作队列中等待执行。\n6. **threadFactory（线程工厂）：** 用于创建新线程的工厂。\n7. **handler（拒绝策略）：** 当线程池和工作队列都满了，无法继续处理新任务时，如何处理新任务的策略。\n\n### 创建线程池方式（ThreadPoolExecutor对象）\n\n##### 参数\n\n• corePoolSize 线程池的核心线程数\n• maximumPoolSize 能容纳的最大线程数\n• keepAliveTime 空闲线程存活时间\n• unit 存活的时间单位\n• workQueue 存放提交但未执行任务的队列\n• threadFactory 创建线程的工厂类\n• handler 等待队列满后的拒绝策略\n\n##### **原理**\n\n线程池中，有三个重要的参数，决定影响了拒绝策略：corePoolSize - 核心线程数，也即最小的线程数、workQueue - 阻塞队列 、maximumPoolSize -最大线程数。\n当提交任务数大于 corePoolSize 的时候，会优先将任务放到 workQueue 阻塞队列中。当阻塞队列饱和后，会扩充线程池中线程数，直到达到maximumPoolSize 最大线程数配置。此时，再多余的任务，则会触发线程池的拒绝策略了。\n总结起来，也就是一句话，当提交的任务数大于（workQueue.size() +maximumPoolSize ），就会触发线程池的拒绝策略。\n\n##### **拒绝策略**(重点)\n\n**CallerRunsPolicy**: 当触发拒绝策略，只要线程池没有关闭的话，则使用调用线程直接运行任务。一般并发比较小，性能要求不高，不允许失败。但是，由于调用者自己运行任务，如果任务提交速度过快，可能导致程序阻塞，性能效率上必然的损失较大\n**AbortPolicy**: 丢弃任务，并抛出拒绝执行 RejectedExecutionException 异常信息。线程池默认的拒绝策略。必须处理好抛出的异常，否则会打断当前的执行流程，影响后续的任务执行。\n**DiscardPolicy**: 直接丢弃，其他啥都没有\n**DiscardOldestPolicy**: 当触发拒绝策略，只要线程池没有关闭的话，丢弃阻塞队列 workQueue 中最老的一个任务，并将新任务加入\n\n##### 使用\n\n```\n//自定义线程池创建\npublic class ThreadPoolDemo2 {\n    public static void main(String[] args) {\n        ExecutorService threadPool = new ThreadPoolExecutor(\n                2,\n                5,\n                2L,\n                TimeUnit.SECONDS,\n                new ArrayBlockingQueue<>(3),\n                Executors.defaultThreadFactory(),\n                new ThreadPoolExecutor.AbortPolicy()\n        );\n        //10个顾客请求\n        try {\n            for (int i = 1; i <=10; i++) {\n                //执行\n                threadPool.execute(()->{\n                    System.out.println(Thread.currentThread().getName()+\" 办理业务\");\n                });\n            }\n        }catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            //关闭\n            threadPool.shutdown();\n        }\n    }\n}\n```\n\n### 创建线程池方式（Executors静态方法）\n\n#### newCachedThreadPool(常用)\n\n**作用**：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程.\n**特点**:\n• 线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）\n• 线程池中的线程可进行缓存重复利用和回收（回收默认时间为 1 分钟）\n• 当线程池中，没有可用线程，会重新创建一个线程\n\n##### 场景: \n\n适用于创建一个可无限扩大的线程池，服务器负载压力较轻，执行时间较短，任务多的场景\n\n##### 使用：\n\n```\nExecutorService threadPool1 = Executors.newCachedThreadPool(5); \n\npublic static ExecutorService newCachedThreadPool(){\n/**\n* corePoolSize 线程池的核心线程数\n* maximumPoolSize 能容纳的最大线程数\n* keepAliveTime 空闲线程存活时间\n* unit 存活的时间单位\n* workQueue 存放提交但未执行任务的队列\n* threadFactory 创建线程的工厂类:可以省略\n* handler 等待队列满后的拒绝策略:可以省略\n*/\nreturn new ThreadPoolExecutor(0,\nInteger.MAX_VALUE,\n60L,\nTimeUnit.SECONDS,\nnew SynchronousQueue<>(),\nExecutors.defaultThreadFactory(),\nnew ThreadPoolExecutor.AbortPolicy());\n}\n```\n\n\n\n#### newFixedThreadPool(常用)\n\n##### 作用：\n\n创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。\n\n##### 特征：\n\n• 线程池中的线程处于一定的量，可以很好的控制线程的并发量\n• 线程可以重复被使用，在显示关闭之前，都将一直存在\n• 超出一定量的线程被提交时候需在队列中等待\n\n##### 场景: \n\n适用于可以预测线程数量的业务中，或者服务器负载较重，对线程数有严格限制的场景\n\n##### 使用：\n\n```\nExecutorService threadPool1 = Executors.newFixedThreadPool(5); //5个窗口\n\npublic static ExecutorService newFixedThreadPool(){\n/**\n* corePoolSize 线程池的核心线程数\n* maximumPoolSize 能容纳的最大线程数\n* keepAliveTime 空闲线程存活时间\n* unit 存活的时间单位\n* workQueue 存放提交但未执行任务的队列\n* threadFactory 创建线程的工厂类:可以省略\n* handler 等待队列满后的拒绝策略:可以省略\n*/\nreturn new ThreadPoolExecutor(10,\n10,\n0L,\nTimeUnit.SECONDS,\nnew LinkedBlockingQueue<>(),\nExecutors.defaultThreadFactory(),\nnew ThreadPoolExecutor.AbortPolicy());\n}\n```\n\n#### newSingleThreadExecutor(常用)\n\n##### 作用：\n\n创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的newFixedThreadPool 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。\n特征： 线程池中最多执行 1 个线程，之后提交的线程活动将会排在队列中以此执行\n\n##### 场景: \n\n适用于需要保证顺序执行各个任务，并且在任意时间点，不会同时有多个线程的场景\n\n##### 使用：\n\n```\npublic static ExecutorService newSingleThreadExecutor(){\n/**\n* corePoolSize 线程池的核心线程数\n* maximumPoolSize 能容纳的最大线程数\n* keepAliveTime 空闲线程存活时间\n* unit 存活的时间单位\n* workQueue 存放提交但未执行任务的队列\n* threadFactory 创建线程的工厂类:可以省略\n* handler 等待队列满后的拒绝策略:可以省略\n*/\nreturn new ThreadPoolExecutor(1,\n1,\n0L,\nTimeUnit.SECONDS,\nnew LinkedBlockingQueue<>(),\nExecutors.defaultThreadFactory(),\nnew ThreadPoolExecutor.AbortPolicy());\n}\n```\n\n#### newScheduleThreadPool(了解)\n\n作用: 线程池支持定时以及周期性执行任务，创建一个 corePoolSize 为传入参数，最大线程数为整形的最大数的线程池\n特征:\n（1）线程池中具有指定数量的线程，即便是空线程也将保留 \n\n（2）可定时或者延迟执行线程活动\n\n场景: 适用于需要多个后台线程执行周期任务的场景\n\n##### 创建方式:\n\n```\npublic static ScheduledExecutorService newScheduledThreadPool(int\ncorePoolSize,\nThreadFactory threadFactory) {\nreturn new ScheduledThreadPoolExecutor(corePoolSize,\nthreadFactory);\n}\n```\n\n#### newWorkStealingPool（了解）\n\njdk1.8 提供的线程池，底层使用的是 ForkJoinPool 实现，创建一个拥有多个任务队列的线程池，可以减少连接数，创建当前可用 cpu 核数的线程来并行执行任务\n\n场景: 适用于大耗时，可并行执行的场景\n\n创建方式:\n\n```\npublic static ExecutorService newWorkStealingPool(int parallelism) {\n/**\n\n* parallelism：并行级别，通常默认为 JVM 可用的处理器个数\n* factory：用于创建 ForkJoinPool 中使用的线程。\n* handler：用于处理工作线程未处理的异常，默认为 null\n* asyncMode：用于控制 WorkQueue 的工作模式:队列---反队列\n  */\n  return new ForkJoinPool(parallelism,\n  ForkJoinPool.defaultForkJoinWorkerThreadFactory,\n  null,\n  true);\n  }\n```',32,'JUC','juc',1,20,0,0,'2024-06-03 20:44:54','2024-06-03 20:44:54'),(40,'线程状态及转换','','http://liyiru.site/upload/20240603_20463589.jpg','# 线程状态\n\n## （1）线程状态\n\n![](http://liyiru.site/upload/20240603_20460071.png)\n\n- 初始(NEW)：新创建了一个线程对象，但还没有调用start()方法\n\n- 运行(RUNNABLE)：Java线程中将就绪（ready）和运行中（running）两种状态笼统的称为“运行”\n\n  - 线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取CPU的使用权，此时处于就绪状态（ready）\n\n  - 就绪状态的线程在获得CPU时间片后变为运行中状态（running）\n\n- 阻塞(BLOCKED)：表示线程阻塞于锁\n\n- 等待(WAITING)：进入该状态的线程需要等待其他线程做出一些特定动作（通知或中断）\n\n- 超时等待(TIMED_WAITING)：该状态不同于WAITING，它可以在指定的时间后自行返回\n\n- 终止(TERMINATED)：表示该线程已经执行完毕\n\n## （2）runnable 和 callable 区别\n\nRunnable 接口run方法没有返回值\n\nCallable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果\n\nCallable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛\n\n\n\n\n\n# 线程中断机制\n\n### 什么是中断机制\n\n首先，一个线程不应该由其他线程来强制中断或停止，而是应该由**线程自己自行停止**，自己来决定自己的命运，所以，Thread.stop,Thread.suspend,Thread.resume都已经被废弃了\n\n其次，在Java中没   有办法立即停止一条线程，然而停止线程却显得尤为重要，如取消一个耗时操作。因此，Java提供了一种用于停止线程的协商机制----中断，也即中断标识协商机制\n\n- 中断只是一种协作协商机制，Java没有给中断增加任何语法，中断的过程完全需要程序员自行实现。若要中断一个线程，你需要手动调用该线程interrupt方法，该方法也仅仅是将该线程对象的中断标识设置为true，接着你需要自己写代码不断检测当前线程的标识位，如果为true，表示别的线程请求这条线程中断，此时究竟应该做什么需要你自己写代码实现。\n- 每个线程对象都有一个中断标识位，用于表示线程是否被中断；该标识位为true表示中断，为false表示未中断；通过调用线程对象的interrupt方法将该线程的标识位设置为true；可以在别的线程中调用，也可以在自己的线程中调用。\n\n### 中断的相关API方法之三大方法说明\n\n##### `interrupt()` 方法：\n\n- 这是`Thread`类的一个方法，用于请求中断线程。\n- 调用一个线程的`interrupt()`方法只是设置该线程的中断状态为`true`，并不会立即停止线程的执行。\n- 如果线程在调用`interrupt()`方法时正在等待、睡眠或执行某些阻塞操作（如`Object.wait()`, `Thread.sleep()`, `Thread.join()`, `BlockingQueue.take()`, `Selector.select()`, `LockSupport.park()`等），那么它将收到一个`InterruptedException`。\n\n##### `isInterrupted()` 方法：\n\n- 这也是`Thread`类的一个方法，用于检查线程的中断状态。\n- 如果线程的中断状态为`true`，则返回`true`。\n- 需要注意的是，如果线程在调用`isInterrupted()`后收到中断请求（即`interrupt()`被调用），`isInterrupted()`将返回`true`，但中断状态不会被清除。这意味着你需要连续检查中断状态或捕获`InterruptedException`。\n\n##### `interrupted()` 方法：\n\n- 这是`Thread`类的一个静态方法，用于检查当前线程的中断状态，并清除中断状态。\n- 如果当前线程的中断状态为`true`，则返回`true`，并清除中断状态。\n- 如果线程在调用`interrupted()`后收到中断请求，再次调用`interrupted()`将返回`false`，因为中断状态已经被清除。\n\n\n\n对于静态方法Thread.interrupted()和实例方法isInterrupted()区别在于：\n\n- 静态方法interrupted将会清除中断状态（传入的参数ClearInterrupted为true）\n- 实例方法isInterrupted则不会（传入的参数ClearInterrupted为false）\n\n\n\n##### 处理`InterruptedException`：\n\n- 当线程在等待、睡眠或执行某些阻塞操作时收到中断请求，它将抛出`InterruptedException`。\n- 你应该总是捕获这个异常，并适当地处理它。通常的做法是清除中断状态（通过调用`Thread.currentThread().interrupt()`），然后要么重新抛出异常（如果当前方法也是声明抛出`InterruptedException`的），要么设置一个中断标志并返回。\n\n##### 响应中断：\n\n- 线程应该定期检查中断状态（通过调用`isInterrupted()`或捕获`InterruptedException`），并在收到中断请求时采取适当的行动。\n- 响应中断的具体方式取决于线程的任务和上下文。例如，一个正在执行长时间计算的线程可能在收到中断请求时停止计算并返回结果，而一个正在等待I/O操作的线程可能在收到中断请求时取消I/O操作并抛出异常。\n\n\n\n### 如何停止中断运行中的线程\n\n#### 通过一个volatile变量实现\n\n```\n/**\n * \n * 使用volatile修饰一个标识符来决定是否结束线程\n */\npublic class InterruptDemo {\n    static volatile boolean isStop = false; //volatile表示的变量具有可见性\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            while (true) {\n                if (isStop) {\n                    System.out.println(Thread.currentThread().getName() + \" isStop的值被改为true，t1程序停止\");\n                    break;\n                }\n                System.out.println(\"-----------hello volatile\");\n            }\n        }, \"t1\").start();\n        try {\n            TimeUnit.MILLISECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(() -> {\n            isStop = true;\n        }, \"t2\").start();\n\n    }\n}\n/**\n * -----------hello volatile\n * -----------hello volatile\n * -----------hello volatile\n * -----------hello volatile\n * -----------hello volatile\n * -----------hello volatile\n * t1 isStop的值被改为true，t1程序停止\n */\n\n```\n\n#### 通过AutomicBoolean\n\n```\n/**\n * \n * 使用AtomicBoolean\n */\npublic class InterruptDemo {\n    static AtomicBoolean atomicBoolean = new AtomicBoolean(false);\n\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            while (true) {\n                if (atomicBoolean.get()) {\n                    System.out.println(Thread.currentThread().getName() + \" atomicBoolean的值被改为true，t1程序停止\");\n                    break;\n                }\n                System.out.println(\"-----------hello atomicBoolean\");\n            }\n        }, \"t1\").start();\n        try {\n            TimeUnit.MILLISECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(() -> {\n            atomicBoolean.set(true);\n        }, \"t2\").start();\n\n    }\n}\n\n/**\n * -----------hello atomicBoolean\n * -----------hello atomicBoolean\n * -----------hello atomicBoolean\n * -----------hello atomicBoolean\n * -----------hello atomicBoolean\n * t1 atomicBoolean的值被改为true，t1程序停止\n */\n\n```\n\n#### 通过Thread类自带的中断API实例方法实现\n\n在需要中断的线程中不断监听中断状态，一旦发生中断，就执行相应的中断处理业务逻辑stop线程。\n\n```\n/**\n * \n * 使用interrupt() 和isInterrupted()组合使用来中断某个线程\n */\npublic class InterruptDemo {\n    static AtomicBoolean atomicBoolean = new AtomicBoolean(false);\n\n\n    public static void main(String[] args) {\n        Thread t1 = new Thread(() -> {\n            while (true) {\n                if (Thread.currentThread().isInterrupted()) {\n                    System.out.println(Thread.currentThread().getName() + \" isInterrupted()的值被改为true，t1程序停止\");\n                    break;\n                }\n                System.out.println(\"-----------hello isInterrupted()\");\n            }\n        }, \"t1\");\n        t1.start();\n\n        try {\n            TimeUnit.MILLISECONDS.sleep(10);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        //t2向t1放出协商，将t1中的中断标识位设为true，希望t1停下来\n        new Thread(() -> t1.interrupt(), \"t2\").start();\n\n        //当然，也可以t1自行设置\n        t1.interrupt();\n\n    }\n}\n/**\n * -----------hello isInterrupted()\n * -----------hello isInterrupted()\n * -----------hello isInterrupted()\n * -----------hello isInterrupted()\n * t1 isInterrupted()的值被改为true，t1程序停止\n */\n```\n\n#### Thread线程中断原理\n\n- 当前线程的中断标识为true，是不是线程就立刻停止？\n\n答案是不立刻停止，具体来说，当对一个线程，调用interrupt时：\n\n- 如果线程处于正常活动状态，那么会将该线程的中断标志设置为true，仅此而已，被设置中断标志的线程将继续正常运行，不受影响，所以interrupt()并不能真正的中断线程，需要被调用的线程自己进行配合才行，对于不活动的线程没有任何影响。\n- 如果线程处于阻塞状态（例如sleep,wait,join状态等），在别的线程中调用当前线程对象的interrupt方法，那么线程将立即退出被阻塞状态（interrupt状态也将被清除），并抛出一个InterruptedException异常。\n\n```\n/**\n * \n * 执行interrupt方法将t1标志位设置为true后，t1没有中断，仍然完成了任务后再结束\n * 在2000毫秒后，t1已经结束称为不活动线程，设置状态为没有任何影响\n */\npublic class InterruptDemo2 {\n    public static void main(String[] args) {\n        //实例方法interrupt()仅仅是设置线程的中断状态位为true，不会停止线程\n        Thread t1 = new Thread(() -> {\n            for (int i = 1; i <= 300; i++) {\n                System.out.println(\"------: \" + i);\n            }\n            /**\n             * ------: 298\n             * ------: 299\n             * ------: 300\n             * t1线程调用interrupt()后的中断标志位02：true\n             */\n            System.out.println(\"t1线程调用interrupt()后的中断标志位02：\" + Thread.currentThread().isInterrupted());\n        }, \"t1\");\n        t1.start();\n\n        System.out.println(\"t1线程默认的中断标志位：\" + t1.isInterrupted());//false\n\n        try {\n            TimeUnit.MILLISECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        t1.interrupt();//true\n        /**\n         * ------: 251\n         * ------: 252\n         * ------: 253\n         * t1线程调用interrupt()后的中断标志位01：true\n         */\n        System.out.println(\"t1线程调用interrupt()后的中断标志位01：\" + t1.isInterrupted());//true\n\n        try {\n            TimeUnit.MILLISECONDS.sleep(2000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        //2000毫秒后，t1线程已经不活动了，不会产生任何影响\n        System.out.println(\"t1线程调用interrupt()后的中断标志位03：\" + t1.isInterrupted());//false\n\n    }\n}\n```\n\n```\n/**\n * \n *1. 中断标志位默认为false\n * 2.t2对t1发出中断协商  t1.interrupt();\n * 3. 中断标志位为true： 正常情况 程序停止\n *     中断标志位为true  异常情况，.InterruptedException ，将会把中断状态清楚，中断标志位为false\n * 4。需要在catch块中，再次调用interrupt()方法将中断标志位设置为false;\n */\npublic class InterruptDemo3 {\n    public static void main(String[] args) {\n        Thread t1 = new Thread(() -> {\n            while (true) {\n                if (Thread.currentThread().isInterrupted()) {\n                    System.out.println(Thread.currentThread().getName() + \" 中断标志位为：\" + Thread.currentThread().isInterrupted() + \" 程序停止\");\n                    break;\n                }\n                //sleep方法抛出InterruptedException后，中断标识也被清空置为false，如果没有在\n                //catch方法中调用interrupt方法再次将中断标识置为true，这将导致无限循环了\n                try {\n                    Thread.sleep(200);\n                } catch (InterruptedException e) {\n                    //Thread.currentThread().interrupt(); \n                    e.printStackTrace();\n                }\n                System.out.println(\"-------------hello InterruptDemo3\");\n\n            }\n        }, \"t1\");\n        t1.start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(() -> {\n            t1.interrupt();\n        }, \"t2\").start();\n    }\n}\n```\n\n\n\n\n\n\n\n# 线程等待唤醒机制\n\n## 三种让线程等待和唤醒的方法\n\n方式一：使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程\n\n方式二：使用JUC包中的Condition的await()方法让线程等待，使用signal()方法唤醒线程\n\n方式三：LockSupport类可以阻塞当前线程以及唤醒指定被阻塞的线程\n\n\n\n## Object类中的wait和notify方法实现线程等待和唤醒\n\n- wait和notify方法必须要在同步代码块或者方法里面，且成对出现使用\n- 先wait再notify才ok\n\n```\n/**\n * @author Guanghao Wei\n * @create 2023-04-11 12:13\n */\npublic class LockSupportDemo {\n\n    public static void main(String[] args) {\n        Object objectLock = new Object();\n        /**\n         * t1	 -----------come in\n         * t2	 -----------发出通知\n         * t1	 -------被唤醒\n         */\n        new Thread(() -> {\n            synchronized (objectLock) {\n                System.out.println(Thread.currentThread().getName() + \"\\t -----------come in\");\n                try {\n                    objectLock.wait();\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                System.out.println(Thread.currentThread().getName() + \"\\t -------被唤醒\");\n            }\n        }, \"t1\").start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(() -> {\n            synchronized (objectLock) {\n                objectLock.notify();\n                System.out.println(Thread.currentThread().getName() + \"\\t -----------发出通知\");\n            }\n\n        }, \"t2\").start();\n    }\n}\n```\n\n## Condition接口中的await和signal方法实现线程的等待和唤醒\n\n- Condition中的线程等待和唤醒方法，需要先获取锁\n- 一定要先await后signal，不要反了\n\n```\n/**\n * @author Guanghao Wei\n * @create 2023-04-11 12:13\n */\npublic class LockSupportDemo {\n\n    public static void main(String[] args) {\n        Lock lock = new ReentrantLock();\n        Condition condition = lock.newCondition();\n        /**\n         * t1	 -----------come in\n         * t2	 -----------发出通知\n         * t1	 -----------被唤醒\n         */\n        new Thread(() -> {\n            lock.lock();\n            try {\n                System.out.println(Thread.currentThread().getName() + \"\\t -----------come in\");\n                condition.await();\n                System.out.println(Thread.currentThread().getName() + \"\\t -----------被唤醒\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            } finally {\n                lock.unlock();\n            }\n        }, \"t1\").start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(() -> {\n            lock.lock();\n            try {\n                condition.signal();\n                System.out.println(Thread.currentThread().getName() + \"\\t -----------发出通知\");\n            } finally {\n                lock.unlock();\n            }\n        }, \"t2\").start();\n\n    }\n}\n```\n\n\n\n**上述两个对象Object和Condition使用的限制条件**\n\n- 线程需要先获得并持有锁，必须在锁块（synchronized或lock）中\n- 必须要先等待后唤醒，线程才能够被唤醒\n\n\n\n## LockSupport\n\nLockSupport是用来创建锁和其他同步类的基本线程阻塞原语，其中park()和unpack()而作用分别是阻塞线程和解除阻塞线程\n\n**用于阻塞和唤醒线程的功能**\n\n### 一、定义和用途\n\n**定义**：LockSupport是Java并发包（java.util.concurrent.locks）中的一个工具类，专门用于实现线程的阻塞和唤醒操作。\n\n**用途**：LockSupport是创建锁和其他同步组件的基础工具，常用于构建复杂的线程同步和协作模式。\n\n### 二、主要方法和原理\n\n主要方法：\n\n- `public static void park();`：阻塞当前线程，直到它被其他线程通过`unpark`方法唤醒、线程被中断，或者已经过了一个不可预知的时间。\n- `public static void park(Object blocker);`：带有阻塞对象的版本，主要用于线程监控和诊断。\n- `public static void parkNanos(long nanos);` 和 `public static void parkNanos(Object blocker, long nanos);`：阻塞当前线程，但最多只阻塞指定的纳秒数。\n- `public static void parkUntil(long deadline);` 和 `public static void parkUntil(Object blocker, long deadline);`：阻塞当前线程，直到指定的绝对时间。\n- `public static void unpark(Thread thread);`：唤醒处于阻塞状态的指定线程。\n\n原理：\n\n- LockSupport使用类似信号量的机制，为每个线程准备一个许可（permit）。当线程调用`park`方法时，如果许可可用则`park`方法立即返回，否则线程将被阻塞直到许可可用。\n- `unpark`方法用于使一个许可变为可用，但许可不能累加，永远只有一个。这意味着即使`unpark`发生在`park`之前，它也可以使下一个`park`操作立即返回。\n\n### 三、特点\n\n**灵活性**：与传统的使用`synchronized`关键字或`Object`类的`wait()`和`notify()`方法不同，LockSupport提供了更灵活的线程阻塞和唤醒控制。\n\n**精确性**：LockSupport提供了更精确的线程阻塞和唤醒控制，使得开发者能够更精确地控制线程的行为。\n\n**可移植性和可维护性**：LockSupport具有更好的可移植性和可维护性，可以在不同的Java平台上保持一致的行为。\n\n### 四、使用注意事项\n\n- 在调用`park`之前，应确保当前线程没有持有任何可能导致死锁的锁。\n- 与`Object.wait()`和`Object.notify()`或`Object.notifyAll()`相比，LockSupport提供了一种更灵活的线程挂起和恢复方法，但它不会释放任何锁资源。\n- 某个线程可以先被`unpark`（这时，该线程就获得了一个许可），然后这个线程调用`LockSupport.park()`时，如果发现有许可可用，则使用此许可而不会阻塞。\n\nLockSupport在Java并发编程中是一个非常重要的工具，它提供了灵活且精确的线程阻塞和唤醒控制，使得开发者能够更好地管理线程的行为和状态。\n\n\n\n\n\n### LockSupport类中的park等待和unpark唤醒\n\n是什么\n\n- LockSupport 是用于创建锁和其他同步类的基本线程阻塞原语\n- LockSupport类使用了一种名为Permit（许可）的概念来做到阻塞和唤醒线程的功能，每个线程都有一个许可（Permit），许可证只能有一个，累加上限是1。\n\n\n主要方法\n\n- 阻塞: Peimit许可证默认没有不能放行，所以一开始调用park()方法当前线程会阻塞，直到别的线程给当前线程发放peimit，park方法才会被唤醒。\n\n- park/park(Object blocker)-------阻塞当前线程/阻塞传入的具体线程\n\n- 唤醒: 调用unpack(thread)方法后 就会将thread线程的许可证peimit发放，会自动唤醒park线程，即之前阻塞中的LockSupport.park()方法会立即返回。\n\n- unpark(Thread thread)------唤醒处于阻塞状态的指定线程\n\n```\n/**\n * \n */\npublic class LockSupportDemo {\n\n    public static void main(String[] args) {\n        /**\n         * t1	 -----------come in\n         * t2	 ----------发出通知\n         * t1	 ----------被唤醒\n         */\n        Thread t1 = new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \"\\t -----------come in\");\n            LockSupport.park();\n            System.out.println(Thread.currentThread().getName() + \"\\t ----------被唤醒\");\n        }, \"t1\");\n        t1.start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(() -> {\n            LockSupport.unpark(t1);\n            System.out.println(Thread.currentThread().getName() + \"\\t ----------发出通知\");\n        }, \"t2\").start();\n\n    }\n}\n```\n\n重点说明（重要）\n\n- LockSupport是用来创建锁和其他同步类的基本线程阻塞原语，所有的方法都是静态方法，可以让线程再任意位置阻塞，阻塞后也有对应的唤醒方法。归根结底，LockSupport时调用Unsafe中的native代码\n- LockSupport提供park()和unpark()方法实现阻塞线程和解除线程阻塞的过程，LockSupport和每个使用它的线程都有一个许可（Peimit）关联，每个线程都有一个相关的permit，peimit最多只有一个，重复调用unpark也不会积累凭证。\n- 形象理解：线程阻塞需要消耗凭证（Permit），这个凭证最多只有一个\n\n- 当调用park时，如果有凭证，则会直接消耗掉这个凭证然后正常退出。如果没有凭证，则必须阻塞等待凭证可用；\n- 当调用unpark时，它会增加一个凭证，但凭证最多只能有1各，累加无效。\n\n面试题\n\n- 为什么LockSupport可以突破wait/notify的原有调用顺序？\n\n- 因为unpark获得了一个凭证，之后再调用park方法，就可以名正言顺的凭证消费，故不会阻塞，先发放了凭证后续可以畅通无阻。\n\n- 为什么唤醒两次后阻塞两次，但最终结果还会阻塞线程？\n\n- 因为凭证的数量最多为1，连续调用两次unpark和调用一次unpark效果一样，只会增加一个凭证，而调用两次park却需要消费两个凭证，证不够，不能放行。',32,'JUC','juc',1,31,0,0,'2024-06-03 20:46:36','2024-06-03 20:46:36'),(41,'锁','','http://114.132.41.159/upload/20240604_01075227.jpg','## synchronized \n\n### 理论\n\n#### （1）继承\n\n虽然可以使用 synchronized 来定义方法，但 synchronized 并不属于方法定义的一部分，因此，synchronized 关键字不能被继承。如果在父类中的某个方法使用了 synchronized 关键字，而在子类中覆盖了这个方法，在子类中的这个方法默认情况下并不是同步的，而必须显式地在子类的这个方法中加上synchronized 关键字才可以。当然，还可以在子类方法中调用父类中相应的方法，这样虽然子类中的方法不是同步的，但子类调用了父类的同步方法，因此，子类的方法也就相当于同步了。\n\n#### （2）线程阻塞\n\n如果一个代码块被 synchronized 修饰了，当一个线程获取了对应的锁，并执行该代码块时，其他线程便只能一直等待，等待获取锁的线程释放锁，而这里获取锁的线程释放锁只会有两种情况：\n1）获取锁的线程执行完了该代码块，然后线程释放对锁的占有；\n2）线程执行发生异常，此时 JVM 会让线程自动释放锁。\n那么如果这个获取锁的线程由于要等待 IO 或者其他原因（比如调用 sleep方法）被阻塞了，但是又没有释放锁，其他线程便只能干巴巴地等待，试想一下，这多么影响程序执行效率。因此就需要有一种机制可以不让等待的线程一直无期限地等待下去（比如只等待一定的时间或者能够响应中断），通过 Lock 就可以办到。\n\n#### （3）线程虚假唤醒\n\n不使用while循环，而是使用if语句导致虚假唤醒\n\n#### （4）锁的问题\n\n一个对象里面如果有多个 synchronized 方法，某一个时刻内，只要一个线程去调用其中的一个 synchronized 方法了，其它的线程都只能等待，换句话说，某一个时刻内，只能有唯一一个线程去访问这些synchronized 方法锁的是当前对象 this，被锁定后，其它的线程都不能进入到当前对象的其它的synchronized 方法加个普通方法后发现和同步锁无关换成两个对象后，不是同一把锁了，情况立刻变化。\nsynchronized 实现同步的基础：Java 中的每一个对象都可以作为锁。\n具体表现为以下 3 种形式：\n	对于普通同步方法，锁是当前实例对象。\n	对于静态同步方法，锁是当前类的 Class 对象。\n	对于同步方法块，锁是 Synchonized 括号里配置的对象\n当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。也就是说如果一个实例对象的非静态同步方法获取锁后，该实例对象的其他非静态同步方法必须等待获取锁的方法释放锁后才能获取锁，可是别的实例对象的非静态同步方法因为跟该实例对象的非静态同步方法用的是不同的锁，所以毋须等待该实例对象已获取锁的非静态同步方法释放锁就可以获取他们自己的锁。所有的静态同步方法用的也是同一把锁——类对象本身，这两把锁是两个不同的对象，所以静态同步方法与非静态同步方法之间是不会有竞态条件的。但是一旦一个静态同步方法获取锁后，其他的静态同步方法都必须等待该方法释放锁后才能获取锁，而不管是同一个实例对象的静态同步方法之间，还是不同的实例对象的静态同步方法之间，只要它们同一个类的实例对象！\n\n\n\n### 语法\n\n#### 修饰方法\n\n**实例方法**：当synchronized修饰一个实例方法时，它将锁定该方法所属对象的实例，确保同一时刻只有一个线程可以执行该方法。\n\n```\npublic synchronized void method() {\n    // 方法体\n}\n```\n\n**静态方法**：当synchronized修饰一个静态方法时，它将锁定该方法所属的类的Class对象，确保同一时刻只有一个线程可以执行该静态方法。\n\n```\npublic static synchronized void staticMethod() {\n    // 方法体\n}\n```\n\n#### 修饰代码块\n\n**对象**：synchronized还可以用来修饰代码块，锁定指定的对象，确保同一时刻只有一个线程可以访问代码块中的代码（this、对象属性）\n\n```\nObject obj = new Object();\nsynchronized (obj) {\n    // 代码块\n}\n```\n\n**类字面常量**：在静态方法或静态代码块中，可以使用类字面常量来锁定整个类，即类的Class对象。\n\n```\n//类对象\npublic static void staticMethod() {\n    synchronized (MyClass.class) {\n        // 同步的代码块\n    }\n}\n\n//静态属性\npublic class MyClass {\n    private static Object lock = new Object();\n    private static int count;\n    public static void method() {\n        synchronized (lock) {\n            // 同步的代码块\n        }\n    }\n}\n```\n\n\n\n\n\n## Lock\n\n### 理论\n\n#### 1、定义\n\nLock 锁实现提供了比使用同步方法和语句可以获得的更广泛的锁操作。它们允许更灵活的结构，可能具有非常不同的属性，并且可能支持多个关联的条件对象。Lock 提供了比 synchronized 更多的功能。\n\n#### 2、Lock 与的 Synchronized 区别\n\n• Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问；\n• Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。\n\n#### 3、lock() 与 unlock()\n\nlock()方法是平常使用得最多的一个方法，就是用来获取锁。如果锁已被其他线程获取，则进行等待。\n采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用 Lock 必须在 try{}catch{}块中进行，并且将释放锁的操作放在finally 块中进行，以保证锁一定被被释放，防止死锁的发生。通常使用 Lock来进行同步的话，是以下面这种形式去使用的：\n\n```\nLock lock = ...;\nlock.lock();\ntry{\n//处理任务\n}catch(Exception ex){\n}finally{\nlock.unlock(); //释放锁\n}\n```\n\n#### 4、newCondition\n\n关键字 synchronized 与 wait()/notify()这两个方法一起使用可以实现等待/通知模式， Lock 锁的 newContition()方法返回 Condition 对象，Condition 类也可以实现等待/通知模式。用 notify()通知时，JVM 会随机唤醒某个等待的线程， 使用 Condition 类可以进行选择性通知， Condition 比较常用的两个方法：\n• await()会使当前线程等待,同时会释放锁,当其他线程调用 signal()时,线程会重新获得锁并继续执行。\n• signal()用于唤醒一个等待的线程。\n注意：在调用 Condition 的 await()/signal()方法前，也需要线程持有相关的 Lock 锁，调用 await()后线程会释放这个锁，在 singal()调用后会从当前Condition 对象的等待队列中，唤醒 一个线程，唤醒的线程尝试获得锁， 一旦获得锁成功就继续执行。\n\n#### 5、Condition与Lock比较\n\n虽然 `Lock` 接口提供了基本的互斥访问控制，但是它并没有提供线程间的等待和通知机制，这在某些情况下是不够的。`Condition` 接口的存在弥补了这一缺陷，它可以与 `Lock` 对象配合使用，提供了更灵活、更强大的线程间通信机制。\n\n以下是使用 `Condition` 接口的一些优势和用途：\n\n1. **精确的等待和通知机制**：`Condition` 接口提供了 `await()`、`signal()` 和 `signalAll()` 方法，可以实现精确的线程等待和通知。相比较于 `Object` 类的 `wait()`、`notify()` 和 `notifyAll()` 方法，`Condition` 接口更加灵活，可以更精确地控制线程的等待和唤醒。\n2. **支持多个等待队列**：每个 `Condition` 对象都可以管理一个独立的等待队列，这意味着你可以在不同的条件下等待不同的线程。这种多个等待队列的支持使得线程间的通信更加灵活，可以更好地满足复杂的线程通信需求。\n3. **避免虚假唤醒**：使用 `Condition` 接口可以避免虚假唤醒的问题。虚假唤醒指的是在没有调用 `signal()` 或 `signalAll()` 方法的情况下，等待中的线程被唤醒。`Condition` 接口提供的 `await()` 方法会在等待之前检查条件，如果条件不满足，则线程会真正地等待，而不会发生虚假唤醒。\n4. **可组合性**：`Lock` 接口和 `Condition` 接口的组合使用提供了更高级的同步控制机制。你可以使用 `Lock` 接口来实现互斥访问控制，同时使用 `Condition` 接口来实现线程间的等待和通知，从而更灵活地控制多个线程的行为。\n\n综上所述，虽然 `Lock` 接口提供了基本的互斥访问控制，但是 `Condition` 接口的存在使得线程间的通信更加灵活、精确，并且可以避免一些常见的并发编程问题，因此它们通常会一起使用。\n\n#### 6、Lock 和 synchronized 有以下几点不同：\n\n1. Lock 是一个接口，而 synchronized 是 Java 中的关键字，synchronized 是内置的语言实现；\n2. synchronized 在发生异常时，会自动释放线程占有的锁，因此不会导致死锁现象发生；而 Lock 在发生异常时，如果没有主动通过 unLock()去释放锁，则很可能造成死锁现象，因此使用 Lock 时需要在 finally 块中释放锁；\n3. Lock 可以让等待锁的线程响应中断，而 synchronized 却不行，使用synchronized 时，等待的线程会一直等待下去，不能够响应中断；\n4. 通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。\n5. Lock 可以提高多个线程进行读操作的效率。在性能上来说，如果竞争资源不激烈，两者的性能是差不多的，而当竞争资源非常激烈时（即有大量线程同时竞争），此时 Lock 的性能要远远优于synchronized。\n\n#### 7、公平锁与非公平锁\n\n**公平锁（效率低、线程平等）：** 公平锁是指当多个线程请求锁时，按照请求的顺序来获取锁。即先来先得，线程按照请求锁的顺序排队等待。在公平锁中，所有的线程都有公平竞争获取锁的机会，不会出现饥饿现象。但是由于需要维护一个有序的等待队列，可能会导致性能下降。\n\n**非公平锁（效率高、线程饿死）：** 非公平锁是指当多个线程请求锁时，不考虑线程请求的顺序，直接尝试获取锁。如果获取不到，才会进行排队等待。非公平锁可能会导致某些线程长时间无法获取到锁，产生饥饿现象，但是由于不需要维护有序的等待队列，可能会比公平锁有更高的吞吐量和更低的延迟。\n\n```\nprivate Lock fairLock = new ReentrantLock(true); // 使用公平锁 \nprivate Lock nonfairLock = new ReentrantLock(false); // 使用非公平锁\n```\n\n#### 8、可重入锁/递归锁\n\n同一个线程在持有锁的情况下，可以重复地对同一个锁进行加锁，而不会造成死锁。可重入锁是通过记录当前锁的持有者和持有次数来实现的。（只要某个线程拥有锁之后，再次调用该方法依然可以调用，即是无限递归锁方法）\n\n显式：ReentrantLock\n\n隐士：synchronized\n\n1. **避免死锁：** 可重入锁允许同一个线程多次获取同一个锁，因此可以避免因为锁的持有者在等待自己释放锁而导致的死锁问题。\n2. **更灵活的锁获取和释放操作：** 可重入锁提供了灵活的锁获取和释放方法，可以在不同的代码块中多次获取和释放锁，而不受限于同步方法或同步代码块的范围。\n3. **高性能：** 与内置锁（synchronized）相比，可重入锁通常具有更好的性能，尤其是在高并发的情况下。\n\n### 语法\n\n\n\n#### Lock类\n\n它提供了比传统的`synchronized`关键字更加灵活和强大的锁机制。与`synchronized`块或方法相比，`Lock`接口提供了更多的操作和功能，例如可中断锁、定时锁、尝试非阻塞地获取锁等。\n\n`Lock`接口的常见实现类是`ReentrantLock`，它是一个可重入的锁，意味着同一个线程可以多次获取同一个锁而不会出现死锁。除了`ReentrantLock`，还有一些其他的实现类，例如`ReadWriteLock.ReadLock`和`ReadWriteLock.WriteLock`，用于实现读写锁。\n\n使用`Lock`接口可以更加灵活地控制线程之间的同步，但也需要开发者手动管理锁的获取和释放，以及处理可能的异常情况。因此，在选择使用`Lock`接口时需要谨慎考虑，并根据具体情况进行权衡。\n\n```\npublic interface Lock {\nvoid lock();\nvoid lockInterruptibly() throws InterruptedException;\nboolean tryLock();\nboolean tryLock(long time, TimeUnit unit) throws InterruptedException;\nvoid unlock();\nCondition newCondition();\n}\n```\n\n**lock()**：获取锁。如果锁已经被其他线程获取，当前线程会被阻塞，直到获取到锁为止。如果线程在等待锁的过程中被中断，它会继续等待，直到获取到锁或者抛出`InterruptedException`。\n\n**tryLock()**：尝试获取锁，如果锁是可用的，则立即返回`true`，否则立即返回`false`，不会等待。这个方法不会导致线程阻塞。\n\n**tryLock(long time, TimeUnit unit)**：尝试在指定的时间内获取锁。如果在指定的时间内获取到了锁，则返回`true`，否则返回`false`。如果线程在等待锁的过程中被中断，它会继续等待，直到获取到锁或者抛出`InterruptedException`。\n\n**lockInterruptibly()**：获取锁，但允许被中断。如果锁已经被其他线程获取，当前线程会被阻塞，直到获取到锁或者被其他线程中断。\n\n**unlock()**：释放锁。必须在`lock()`之后、成功获取到锁之后调用，用于释放锁资源。\n\n**newCondition()** 用于创建一个与该锁相关联的 `Condition` 对象，这个 `Condition` 对象可以用于线程间的等待和通知。\n\n\n\n#### Condition类\n\nJava并发编程中用于等待和通知的机制之一，它通常与锁（如`ReentrantLock`）一起使用。`Condition`接口提供了类似于`Object`的`wait()`和`notify()`方法的功能，但更加灵活和强大。\n\n1. **await()**：使当前线程等待，并释放与之关联的锁。当另一个线程调用了相应锁的`signal()`或`signalAll()`方法时，该线程才会被唤醒并重新获取锁。通常在一个循环中使用`await()`方法，以防止虚假唤醒。\n2. **awaitUninterruptibly()**：与`await()`类似，但不会响应中断。即使当前线程被中断，也会继续等待。\n3. **signal()**：唤醒一个等待的线程。如果有多个线程在等待，那么只有一个会被唤醒。被唤醒的线程会尝试重新获取与之关联的锁，一旦成功获取锁，它就可以从`await()`方法中返回。\n4. **signalAll()**：唤醒所有等待的线程。调用`signalAll()`后，所有等待的线程都会尝试重新获取与之关联的锁。\n\n```\n1、获取锁：首先，你需要使用 Lock 对象的 lock() 方法获取锁。\n2、创建 Condition 对象：然后，通过调用 Lock 对象的 newCondition() 方法来创建一个与该锁相关联的 Condition 对象。\n3、使用 Condition 对象进行线程间的等待和通知：\n	等待（await）：调用 Condition 对象的 await() 方法来让当前线程等待某个条件的发生。调用该方法会释放锁，并将当前线程置于等待状态，直到其他线程调用了 Condition 对象的 signal() 或 signalAll() 方法。\n	通知（signal）：当某个条件满足时，你可以调用 Condition 对象的 signal() 方法来唤醒一个等待的线程，或者调用 signalAll() 方法来唤醒所有等待的线程。\n4、释放锁：在使用完 Condition 对象后，记得调用 Lock 对象的 unlock() 方法释放锁。\n\npublic class ConditionExample {\n    private final Lock lock = new ReentrantLock();\n    private final Condition condition = lock.newCondition();\n    private boolean isConditionMet = false;\n\n    public void waitForCondition() throws InterruptedException {\n        lock.lock();\n        try {\n            // 如果条件未满足，则等待\n            while (!isConditionMet) {\n                condition.await(); // 线程等待，同时释放锁\n            }\n            // 条件满足后执行的代码\n            System.out.println(\"Condition is met, continue...\");\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void fulfillCondition() {\n        lock.lock();\n        try {\n            // 设置条件为满足\n            isConditionMet = true;\n            // 唤醒等待的线程\n            condition.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public static void main(String[] args) {\n        ConditionExample example = new ConditionExample();\n\n        // 创建一个线程等待条件\n        Thread waitingThread = new Thread(() -> {\n            try {\n                example.waitForCondition();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n\n        // 创建一个线程来满足条件\n        Thread fulfillingThread = new Thread(example::fulfillCondition);\n\n        // 启动两个线程\n        waitingThread.start();\n        fulfillingThread.start();\n    }\n}\n```\n\n\n\n#### ReentrantLock\n\n**构造方法：**\n\n- `ReentrantLock()`: 创建一个新的 ReentrantLock 实例。\n\n**获取锁方法：**\n\n- `lock()`: 获取锁，如果锁已经被其他线程获取，则当前线程会被阻塞，直到获取到锁。\n- `lockInterruptibly() throws InterruptedException`: 获取锁，如果锁已经被其他线程获取，则当前线程会被阻塞，直到获取到锁或者被中断。\n- `tryLock()`: 尝试获取锁，如果锁是可用的，则立即返回 true，否则立即返回 false，不会被阻塞。\n- `tryLock(long timeout, TimeUnit unit) throws InterruptedException`: 在指定的时间内尝试获取锁，如果锁是可用的，则立即返回 true，否则等待指定的时间，如果在等待的时间内获取到了锁，则返回 true，否则返回 false。\n\n**释放锁方法：**\n\n- `unlock()`: 释放锁。\n\n**其他方法：**\n\n- `boolean isLocked()`: 查询锁是否被任意线程持有。\n- `boolean isHeldByCurrentThread()`: 查询锁是否被当前线程持有。\n- `int getHoldCount()`: 查询当前线程持有该锁的次数。\n\n\n\n### 应用\n\n##### 线程间通信（按条件执行）\n\n```\n//第一步 创建资源类，定义属性和操作方法\nclass Share {\n    //初始值\n    private int number = 0;\n    //+1的方法\n    public synchronized void incr() throws InterruptedException {\n        //第二步 判断 干活 通知\n        while(number != 0) { //判断number值是否是0，如果不是0，等待\n            this.wait(); //在哪里睡，就在哪里醒\n        }\n        //如果number值是0，就+1操作\n        number++;\n        System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n        //通知其他线程\n        this.notifyAll();\n    }\n\n    //-1的方法\n    public synchronized void decr() throws InterruptedException {\n        //判断\n        while(number != 1) {\n            this.wait();\n        }\n        //干活\n        number--;\n        System.out.println(Thread.currentThread().getName()+\" :: \"+number);\n        //通知其他线程\n        this.notifyAll();\n    }\n}\n\npublic class ThreadDemo1 {\n    //第三步 创建多个线程，调用资源类的操作方法\n    public static void main(String[] args) {\n        Share share = new Share();\n        //创建线程\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr(); //+1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr(); //-1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.incr(); //+1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"CC\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    share.decr(); //-1\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"DD\").start();\n    }\n}\n```\n\n##### 线程间定制通信（按一定顺序）\n\n```\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.UUID;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n//第一步 创建资源类\nclass ShareResource {\n    //定义标志位\n    private int flag = 1;  // 1 AA     2 BB     3 CC\n\n    //创建Lock锁\n    private Lock lock = new ReentrantLock();\n\n    //创建三个condition\n    private Condition c1 = lock.newCondition();\n    private Condition c2 = lock.newCondition();\n    private Condition c3 = lock.newCondition();\n\n    //打印5次，参数第几轮\n    public void print5(int loop) throws InterruptedException {\n        //上锁\n        lock.lock();\n        try {\n            //判断\n            while(flag != 1) {\n                //等待\n                c1.await();\n            }\n            //干活\n            for (int i = 1; i <=5; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //通知\n            flag = 2; //修改标志位 2\n            c2.signal(); //通知BB线程\n        }finally {\n            //释放锁\n            lock.unlock();\n        }\n    }\n\n    //打印10次，参数第几轮\n    public void print10(int loop) throws InterruptedException {\n        lock.lock();\n        try {\n            while(flag != 2) {\n                c2.await();\n            }\n            for (int i = 1; i <=10; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //修改标志位\n            flag = 3;\n            //通知CC线程\n            c3.signal();\n        }finally {\n            lock.unlock();\n        }\n    }\n\n    //打印15次，参数第几轮\n    public void print15(int loop) throws InterruptedException {\n        lock.lock();\n        try {\n            while(flag != 3) {\n                c3.await();\n            }\n            for (int i = 1; i <=15; i++) {\n                System.out.println(Thread.currentThread().getName()+\" :: \"+i+\" ：轮数：\"+loop);\n            }\n            //修改标志位\n            flag = 1;\n            //通知AA线程\n            c1.signal();\n        }finally {\n            lock.unlock();\n        }\n    }\n}\n\npublic class ThreadDemo3 {\n    public static void main(String[] args) {\n        ShareResource shareResource = new ShareResource();\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print5(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"AA\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print10(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"BB\").start();\n\n        new Thread(()->{\n            for (int i = 1; i <=10; i++) {\n                try {\n                    shareResource.print15(i);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        },\"CC\").start();\n    }\n}\n```\n\n## 读写锁\n\n### 理论\n\n#### （1）应用场景\n\n对共享资源有读和写的操作，且写操作没有读操作那么频繁。在没有写操作的时候，多个线程同时读一个资源没有任何问题，所以\n应该允许多个线程同时读取共享资源；但是如果一个线程想去写这些共享资源，就不应该允许其他线程对该资源进行读和写的操作了。\n\n针对这种场景，JAVA 的并发包提供了读写锁 ReentrantReadWriteLock，它表示两个锁，一个是读操作相关的锁，称为共享锁；一个是写相关的锁，称为排他锁\n\n##### 线程进入读锁的前提条件：\n\n• 没有其他线程的写锁\n• 没有写请求, 或者有写请求，但调用线程和持有锁的线程是同一个(可重入锁)。\n\n##### 线程进入写锁的前提条件：\n\n• 没有其他线程的读锁\n• 没有其他线程的写锁\n\n##### 读写锁三个重要的特性：\n\n（1）公平选择性：支持非公平（默认）和公平的锁获取方式，吞吐量还是非公平优于公平。\n（2）重进入：读锁和写锁都支持线程重进入。\n（3）锁降级：遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级成为读锁。\n\n#### （2）锁降级\n\n在线程持有读锁的情况下，该线程不能取得写锁(因为获取写锁的时候，如果发现当前的读锁被占用，就马上获取失败，不管读锁是不是被当前线程持有)。\n在线程持有写锁的情况下，该线程可以继续获取读锁（获取读锁时如果发现写锁被占用，只有写锁没有被当前线程占用的情况才会获取失败）。\n原因: 当线程获取读锁的时候，可能有其他线程同时也在持有读锁，因此不能把获取读锁的线程“升级”为写锁；而对于获得写锁的线程，它一定独占了读写锁，因此可以继续让它获取读锁，当它同时获取了写锁和读锁后，还可以先释放写锁继续持有读锁，这样一个写锁就“降级”为了读锁。\n\n```\n//可重入读写锁对象\nReentrantReadWriteLock rwLock = new ReentrantReadWriteLock();\nReentrantReadWriteLock.ReadLock readLock = rwLock.readLock();//读锁\nReentrantReadWriteLock.WriteLock writeLock = rwLock.writeLock();//写锁\n\n//1 获取写锁\nwriteLock.lock();\nSystem.out.println(\"writing\");\n\n//锁降级\n//2 获取读锁\nreadLock.lock();\nSystem.out.println(\"read\");\n\n//3 释放写锁\nwriteLock.unlock();\n\n//4 释放读锁\nreadLock.unlock();\n```\n\n### 语法\n\n#### ReadWriteLock\n\n**Read Lock（读锁）：** 用于支持多个线程同时读取共享资源，不互斥。\n\n- `Lock readLock()`: 返回一个读锁实例。\n\n**Write Lock（写锁）：** 用于独占地写入共享资源，当一个线程持有写锁时，其他线程无法获取读锁或写锁。\n\n- `Lock writeLock()`: 返回一个写锁实例。\n\n#### ReentrantReadWriteLock\n\n##### 特点：\n\n1. **可重入性：** 与 `ReentrantLock` 类似，读写锁也是可重入的，允许同一个线程在持有锁的情况下多次获取该锁。\n2. **读写分离：** 读写锁在设计上允许多个线程同时获取读锁，而在写锁被持有时不允许其他线程获取读锁或写锁，从而实现了读写分离，提高了并发性能。\n3. **公平性选择：** `ReentrantReadWriteLock` 支持公平和非公平的锁获取方式。公平锁会按照请求的顺序分配锁，而非公平锁则允许插队获取锁，可以提高整体吞吐量。\n\n##### 方法：\n\n- `readLock()`: 返回一个读锁实例，用于读取共享资源。\n- `writeLock()`: 返回一个写锁实例，用于写入共享资源。\n- `isFair()`: 判断锁是否是公平锁。\n- `getQueueLength()`: 返回正在等待获取写锁的线程数。\n- `getReadHoldCount()`: 返回当前线程持有读锁的个数。\n- `getReadLockCount()`: 返回当前读锁的数量。\n- `getWriteHoldCount()`: 返回当前线程持有写锁的个数。\n- `isWriteLocked()`: 判断写锁是否被某个线程持有。\n\n### 应用\n\n```\n//资源类\nclass MyCache {\n    //创建map集合\n    private volatile Map<String,Object> map = new HashMap<>();\n\n    //创建读写锁对象\n    private ReadWriteLock rwLock = new ReentrantReadWriteLock();\n\n    //放数据\n    public void put(String key,Object value) {\n        //添加写锁\n        rwLock.writeLock().lock();\n\n        try {\n            System.out.println(Thread.currentThread().getName()+\" 正在写操作\"+key);\n            //暂停一会\n            TimeUnit.MICROSECONDS.sleep(300);\n            //放数据\n            map.put(key,value);\n            System.out.println(Thread.currentThread().getName()+\" 写完了\"+key);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            //释放写锁\n            rwLock.writeLock().unlock();\n        }\n    }\n\n    //取数据\n    public Object get(String key) {\n        //添加读锁\n        rwLock.readLock().lock();\n        Object result = null;\n        try {\n            System.out.println(Thread.currentThread().getName()+\" 正在读取操作\"+key);\n            //暂停一会\n            TimeUnit.MICROSECONDS.sleep(300);\n            result = map.get(key);\n            System.out.println(Thread.currentThread().getName()+\" 取完了\"+key);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } finally {\n            //释放读锁\n            rwLock.readLock().unlock();\n        }\n        return result;\n    }\n}\n\npublic class ReadWriteLockDemo {\n    public static void main(String[] args) throws InterruptedException {\n        MyCache myCache = new MyCache();\n        //创建线程放数据\n        for (int i = 1; i <=5; i++) {\n            final int num = i;\n            new Thread(()->{\n                myCache.put(num+\"\",num+\"\");\n            },String.valueOf(i)).start();\n        }\n\n        TimeUnit.MICROSECONDS.sleep(300);\n\n        //创建线程取数据\n        for (int i = 1; i <=5; i++) {\n            final int num = i;\n            new Thread(()->{\n                myCache.get(num+\"\");\n            },String.valueOf(i)).start();\n        }\n    }\n}\n\n```\n\n结果分析：读可以有多个线程，写只有一个线程\n\n读写没有优先级，但是当进行读操作时，如果此时又有读操作与写操作同时进来，此时会优先进行读操作；当进行写操作时，如果此时又有读操作与写操作同时进来，此时会优先进行写操作\n\n写完又写\n\n读可以同时读，所以此时只有读完才能写\n\n\n\n## 乐观锁和悲观锁\n\n悲观锁： 认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改，synchronized和Lock的实现类都是悲观锁，适合写操作多的场景，先加锁可以保证写操作时数据正确，显示的锁定之后再操作同步资源-----狼性锁\n\n乐观锁： 认为自己在使用数据的时候不会有别的线程修改数据或资源，不会添加锁，Java中使用无锁编程来实现，只是在更新的时候去判断，之前有没有别的线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写入，如果已经被其他线程更新，则根据不同的实现方式执行不同的操作，比如：放弃修改、重试抢锁等等。判断规则有：版本号机制Version，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。-----适合读操作多的场景，不加锁的特性能够使其读操作的性能大幅提升，乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命\n\n## 从字节码角度分析synchronized实现\n\n### 3.2.1字节码\n\n#### 实现使用的是monitorenter和monitorexit指令\n\n![img](./8.1.2锁.assets/1681111681046-2feb9423-0b8d-4d54-aeab-70d3ae432fe7.png)\n\n#### synchronized普通同步方法\n\n调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程会将现持有monitor锁，然后再执行该方法，最后在方法完成（无论是否正常结束）时释放monitor\n\n![img](./8.1.2锁.assets/1681112009525-6628c636-a35a-420e-b4fd-5980b700de9c.png)\n\n#### synchronized静态同步方法\n\nACC_STATIC、ACC_SYNCHRONIZED访问标志区分该方法是否是静态同步方法\n\n![img](./8.1.2锁.assets/1681112126738-53ea5b8f-aab8-4787-9bad-dcad0c809d8a.png)\n\n### 3.2.2 反编译synchronized锁的是什么\n\n##### 任何一个对象都可以成为一个锁\n\nC++源码：ObjectMonitor.java--->ObjectMonitor.cpp--->ObjectMonitor.hpp\n\n每个对象天生都带着一个对象监视器，每一个被锁住的对象都会和Monitor关联起来\n\n总结：指针指向Monitor对象（也称为管程或监视器）的真实地址。每个对象都存在着一个monitor与之关联，当一个monitor被某个线程持有后，它便处于锁定状态。在Java虚拟机（HotSpot）中，monitor是由OnjectMonitor实现的，其主要的数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现）：\n\n![img](./8.1.2锁.assets/1681116200663-e521f7bf-78b9-49a4-a448-2fd845c37ea0.png)\n\n![img](./8.1.2锁.assets/1681116040902-0b37eada-7c94-4611-a45e-db25c56e390d.png)\n\n## 公平锁和非公平锁\n\n##### 公平锁：\n\n是指多个线程按照申请锁的顺序来获取锁，这里类似于排队买票，先来的人先买，后来的人再队尾排着，这是公平的----- Lock lock = new ReentrantLock(true)---表示公平锁，先来先得。\n\n##### 非公平锁：\n\n是指多个线程获取锁的顺序并不是按照申请的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级反转或者饥饿的状态（某个线程一直得不到锁）---- Lock lock = new  ReentrantLock(false)---表示非公平锁，后来的也可能先获得锁，默认为非公平锁。\n\n##### 为什么会有公平锁/非公平锁的设计？\n\n性能考量：\n\n- 非公平锁：非公平锁的设计允许新进入的线程在不需要等待已有等待队列中的线程的情况下直接尝试获取锁。这种方式能更充分地利用CPU的时间片，减少CPU的空闲时间。同时，当线程释放锁后，该线程再次尝试获取锁的概率增大，从而减少了线程切换的开销，提高了整体的吞吐效率。\n- 公平锁：公平锁需要维护一个等待队列，并根据线程进入队列的顺序来决定哪个线程能够获取到锁。这种方式虽然保证了先来的线程优先获取锁，但也可能导致性能问题，因为需要频繁地进行线程上下文切换，以确保按照正确的顺序处理请求。\n\n公平性考量：\n\n- 公平锁：公平锁严格按照线程等待的顺序来获取锁，确保了先来先服务的原则，为每个线程提供了公平的访问机会。\n- 非公平锁：非公平锁则不考虑线程等待的顺序，每个线程获取锁的概率都是相等的。这种方式可能会导致某些线程长时间处于饥饿状态，因为新加入的竞争者可能会优先获得锁。\n\n适用场景：\n\n- 当需要保证线程间的公平访问时，可以选择公平锁。\n- 当更关注性能和吞吐量时，非公平锁可能是一个更好的选择。\n\n总结来说，公平锁和非公平锁的设计是在多线程编程中对性能和公平性进行权衡的结果。非公平锁通过减少线程切换的开销和充分利用CPU的时间片来提高性能，但可能导致某些线程长时间处于饥饿状态；而公平锁则通过维护等待队列来确保线程间的公平访问，但可能牺牲了一定的性能。在实际应用中，应根据具体的需求和场景来选择使用哪种类型的锁。\n\n##### 为什么默认非公平？\n\n恢复挂起的线程到真正锁的获取还是有时间差的，从开发人员来看这个时间微乎其微，但是从CPU的角度来看，这个时间差存在的还是很明显的。所以非公平锁能更充分地利用CPU的时间片，尽量减少CPU空间状态时间。\n\n使用多线程很重要的考量点是线程切换的开销，当采用非公平锁时，当一个线程请求锁获取同步状态，然后释放同步状态，所以刚释放锁的线程在此刻再次获取同步状态的概率就变得很大，所以就减少了线程的开销。\n\n##### 什么时候用公平？什么时候用非公平？\n\n如果为了更高的吞吐量，很显然非公平锁是比较合适的，因为节省了很多线程切换的时间，吞吐量自然就上去了；否则就用公平锁，大家公平使用。\n\n## 可重入锁（递归锁）\n\n在同一线程在外层方法获取到锁的时侯，在进入该线程的内层方法会自动获取锁（前提，锁对象的是同一个对象），不会因为之前已经获取过还没释放而阻塞---------优点之一就是可一定程度避免死锁。\n\n**隐式锁**（即synchronized关键字使用的锁），默认是可重入锁\n\n在一个synchronized修饰的方法或者代码块的内部调用本类的其他synchronized修饰的方法或者代码块时，是永远可以得到锁。\n\n**显式锁**（即Lock）也有ReentrantLock这样的可重入锁\n\n```\n public static void main(String[] args) {\n        final Object o = new Object();\n        /**\n         * ---------------外层调用\n         * ---------------中层调用\n         * ---------------内层调用\n         */\n        new Thread(() -> {\n            synchronized (o) {\n                System.out.println(\"---------------外层调用\");\n                synchronized (o) {\n                    System.out.println(\"---------------中层调用\");\n                    synchronized (o) {\n                        System.out.println(\"---------------内层调用\");\n                    }\n                }\n            }\n        }, \"t1\").start();\n\n        /**\n         * 注意：加锁几次就需要解锁几次\n         * ---------------外层调用\n         * ---------------中层调用\n         * ---------------内层调用\n         */\n        Lock lock = new ReentrantLock();\n        new Thread(() -> {\n            lock.lock();\n            try {\n                System.out.println(\"---------------外层调用\");\n                lock.lock();\n                try {\n                    System.out.println(\"---------------中层调用\");\n                    lock.lock();\n                    try {\n                        System.out.println(\"---------------内层调用\");\n                    } finally {\n                        lock.unlock();\n                    }\n                } finally {\n                    lock.unlock();\n                }\n            } finally {\n                lock.unlock();\n            }\n        }, \"t2\").start();\n    }\n```\n\n## 死锁及排查\n\n死锁是指两个或两个以上的线程在执行过程中，因抢夺资源而造成的一种互相等待的现象，若无外力干涉，则它们无法再继续推进下去。\n\n### 3.5.1产生原因：\n\n- 系统资源不足\n- 进程运行推进顺序不合适\n- 系统资源分配不当\n\n### 3.5.2死锁案例：\n\n```\npublic class DeadLockDemo {\n    static  Object a=new Object();\n    static  Object b=new Object();\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (a){\n                System.out.println(\"t1线程持有a锁，试图获取b锁\");\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                synchronized (b){\n                    System.out.println(\"t1线程获取到b锁\");\n                }\n            }\n         },\"t1\").start();\n\n        new Thread(() -> {\n            synchronized (b){\n                System.out.println(\"t2线程持有a锁，试图获取a锁\");\n                try {\n                    TimeUnit.SECONDS.sleep(1);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                synchronized (a){\n                    System.out.println(\"t2线程获取到a锁\");\n                }\n            }\n        },\"t2\").start();\n    }\n}\n```\n\n### 3.5.3排查死锁\n\n#### 纯命令：jps -l、jstack 进程编号\n\n1、打开命令行终端。\n\n2、输入 `jps -l` 命令并按下回车键。\n\n```bash\njps -l\n```\n\n3、`jps` 命令会列出所有Java进程的PID（进程ID）和它们的主类名或JAR文件路径。\n\n4、查找你想要分析的Java进程的PID。\n\n5、找到了PID，使用 `jstack` 命令来生成该Java进程的线程堆栈跟踪，并查找死锁信息。\n\n```\njstack <PID>\n```\n\njstack 命令的输出将包含该Java进程的线程堆栈跟踪。如果存在死锁，jstack 的输出中会包含类似于以下内容的部分：\n\n```\nFound one Java-level deadlock:  \n=============================  \n  \n\"Thread-1\":  \n  waiting to lock monitor 0x00007f8d4c0022c8 (object 0x000000076b5e59d0),  \n  which is held by \"Thread-0\"  \n\"Thread-0\":  \n  waiting to lock monitor 0x00007f8d4c002328 (object 0x000000076b5e59e0),  \n  which is held by \"Thread-1\"  \n  \nJava stack information for the threads listed above:  \n===================================================  \n\"Thread-1\":  \n... (省略了堆栈跟踪的其余部分)  \n\"Thread-0\":  \n... (省略了堆栈跟踪的其余部分)\n```\n\n请注意，jps 和 jstack 都是JDK自带的工具，它们位于JDK的 bin 目录下。因此，需要确保 jps 和 jstack 命令的路径已经包含在系统的环境变量 PATH 中，或者可以通过指定完整的路径来运行它们\n\n#### 图形化：jconsole\n\n1. **启动 jconsole**：\n   打开命令行终端，输入 `jconsole` 并按回车键启动 `jconsole` 工具。\n2. **连接到Java进程**：\n   在 `jconsole` 的界面中，你会看到一个本地进程列表，显示了所有正在运行的Java进程。选择你想要连接的Java进程，然后点击“连接”按钮。如果你需要连接到远程Java进程，可以点击右上角的“远程”按钮，并输入远程主机的地址和端口号。\n3. **查看线程信息**：\n   连接成功后，在左侧的导航树中选择“**线程**”选项卡。这将显示Java进程的线程信息，包括线程名称、状态、堆栈跟踪等。\n4. **查找死锁**：\n   在“线程”选项卡中，查找状态为“BLOCKED”的线程。这些线程可能是死锁的一部分，因为它们正在等待获取某个锁，但无法获得。为了更清晰地看到死锁情况，你可以对线程列表进行排序或过滤。\n5. **分析死锁**：\n   点击一个状态为“BLOCKED”的线程，查看其堆栈跟踪信息。堆栈跟踪将显示线程正在等待哪个锁，以及哪个线程持有该锁。通过分析多个线程的堆栈跟踪，你可以确定是否存在死锁，并找出导致死锁的线程和锁。\n6. **解决死锁**：\n   一旦确定了死锁的原因，你可以采取适当的措施来解决它。这可能包括重新设计代码以避免死锁，或者调整线程的优先级和调度策略来减少死锁的可能性。\n\n注意：`jconsole` 是一个强大的工具，但它可能无法直接显示“死锁”这个词。你需要通过分析线程的堆栈跟踪和状态来确定是否存在死锁。此外，`jconsole` 还提供了其他有用的监控功能，如内存使用、垃圾回收等，这些功能也可以帮助你更好地理解Java应用程序的性能和行为。\n\n\n\n\n\n## Synchronized的性能变化\n\nJava5以前，只有Synchronized，这个是操作系统级别的重量级操作\n\n- 重量级锁，假如锁的竞争比较激烈的话，性能下降\n- Java 5之前 用户态和内核态之间的转换\n\n- ![img](./8.1.2锁.assets/1681448109572-488801b7-7a7c-4003-88f8-a10c59b3859d.png)\n\nJava6 之后为了减少获得锁和释放锁所带来的性能消耗，引入了轻量级锁和偏向锁\n\n## Synchronized锁种类及升级步骤\n\n### 多线程访问情况\n\n- 只有一个线程来访问，有且唯一Only One\n- 有两个线程（2个线程交替访问）\n- 竞争激烈，更多线程来访问\n\n###  升级流程\n\n- Synchronized用的锁是存在Java对象头里的MarkWord中，锁升级功能主要依赖MarkWord中锁标志位和释放偏向锁标志位\n- ![img](./8.1.2锁.assets/1681448615179-68918d36-eeaa-4454-b672-0d2eb1ae30fe.png)\n- 锁指向，请牢记\n\n- 偏向锁：MarkWord存储的是偏向的线程ID\n- 轻量锁：MarkWord存储的是指向线程栈中Lock Record的指针\n- 重量锁：MarkWord存储的是指向堆中的monitor对象（系统互斥量指针）\n\n### 无锁\n\n![img](./8.1.2锁.assets/1681449173639-bc332c5c-a510-4b7c-8bc6-336646b5ab00.png)\n\n\n\n### 偏锁\n\n偏向锁：单线程竞争，当线程A第一次竞争到锁时，通过修改MarkWord中的偏向线程ID、偏向模式。如果不存在其他线程竞争，那么持有偏向锁的线程将永远不需要进行同步。\n\n主要作用：\n\n- 当一段同步代码一直被同一个线程多次访问，由于只有一个线程那么该线程在后续访问时便会自动获得锁\n- 同一个老顾客来访，直接老规矩行方便\n\n结论：\n\n- HotSpot的作者经过研究发现，大多数情况下：在多线程情况下，锁不仅不存在多线程竞争，还存在由同一个线程多次获得的情况，偏向锁就是在这种情况下出现的，它的出现是为了解决只有一个线程执行同步时提高性能。\n- 偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他线程访问，则持有偏向锁的线程将永远不需要出发同步。也即偏向锁在资源在没有竞争情况下消除了同步语句，懒得连CAS操作都不做了，直接提高程序性能。\n\n理论落地：\n\n- ![img](./8.1.2锁.assets/1681451836192-5ae30f1e-085d-4c2b-aa8c-1bd47f199116.png)\n\n技术实现：\n\n![img](./8.1.2锁.assets/1681451914425-01aa0721-8f56-4413-a1db-5092fcbfdf06.png)\n\n偏向锁JVM命令：\n\n- ![img](./8.1.2锁.assets/1681452242110-e3b8e768-acfb-4f43-9a50-8699e9952ece.png)\n\n案例\n\n```\n/**\n\n */\npublic class SynchronizedUpDemo {\n\n    public static void main(String[] args) {\n        /**\n         * 这里偏向锁在JDK6以上默认开启，开启后程序启动几秒后才会被激活，可以通过JVM参数来关闭延迟 -XX:BiasedLockingStartupDelay=0\n         */\n//        try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }\n        Object o = new Object();\n        synchronized (o) {\n            System.out.println(ClassLayout.parseInstance(o).toPrintable());\n        }\n    }\n}\n```\n\n![image.png](./8.1.2锁.assets/1681452733726-2fd91d28-effd-48e8-aa2b-9f4521d90f8b.webp)\n\n偏向锁的撤销：\n\n- 当有另外一个线程逐步来竞争锁的时候，就不能再使用偏向锁了，要升级为轻量级锁，使用的是等到竞争出现才释放锁的机制\n- 竞争线程尝试CAS更新对象头失败，会等到全局安全点（此时不会执行任何代码）撤销偏向锁，同时检查持有偏向锁的线程是否还在执行：\n\n- 第一个线程正在执行Synchronized方法（处于同步块），它还没有执行完，其他线程来抢夺，该偏向锁会被取消掉并出现锁升级，此时轻量级锁由原来持有偏向锁的线程持有，继续执行同步代码块，而正在竞争的线程会自动进入自旋等待获得该轻量级锁\n- 第一个线程执行完Synchronized（退出同步块），则将对象头设置为无所状态并撤销偏向锁，重新偏向。\n- ![img](./8.1.2锁.assets/1681453654704-4252f703-ba8d-43c1-90b6-cdf78a965570.png)\n\n题外话：Java15以后逐步废弃偏向锁，需要手动开启------->维护成本高\n\n### 轻锁\n\n概念：多线程竞争，但是任意时候最多只有一个线程竞争，即不存在锁竞争太激烈的情况，也就没有线程阻塞。\n\n主要作用：有线程来参与锁的竞争，但是获取锁的冲突时间极短---------->本质是自旋锁CAS\n\n![img](./8.1.2锁.assets/1681454510407-cde9df3c-e7ed-415f-a459-76f64160035f.png)\n\n轻量锁的获取：\n\n![img](./8.1.2锁.assets/1681454665890-db296f20-69b8-4bd8-8538-0197584c61e5.png)\n\n![img](./8.1.2锁.assets/1681454779796-56f6d99a-8850-44da-ad34-890a738a230c.png)\n\n案例演示：\n\n![img](./8.1.2锁.assets/1681454830354-8d42c5c5-0025-4381-898d-b733317de70a.png)\n\n自旋一定程度和次数（Java8 之后是自适应自旋锁------意味着自旋的次数不是固定不变的）：\n\n- 线程如果自旋成功了，那下次自旋的最大次数会增加，因为JVM认为既然上次成功了，那么这一次也大概率会成功\n- 如果很少会自选成功，那么下次会减少自旋的次数甚至不自旋，避免CPU空转\n\n轻量锁和偏向锁的区别：\n\n- 争夺轻量锁失败时，自旋尝试抢占锁\n- 轻量级锁每次退出同步块都需要释放锁，而偏向锁是在竞争发生时才释放锁\n\n### 重锁\n\n有大量线程参与锁的竞争，冲突性很高\n\n![img](./8.1.2锁.assets/1681455335764-3bb5bb5f-d014-4b25-9755-e0ca2c9aa809.png)\n\n![img](./8.1.2锁.assets/1681455375540-a112e2b5-9e7f-4682-8cd0-885f5cf7957e.png)\n\n### 小总结\n\n- 锁升级的过程\n\n![img](./8.1.2锁.assets/1681459024640-cadca197-5d19-433d-b6d8-abc8965ce494.jpeg)\n\n- 锁升级后，hashcode去哪儿了?\n\n- ![img](./8.1.2锁.assets/1681455960993-7d1f944c-3f3e-47ad-a7e3-83abedc0a8fe.png)\n- ![img](./8.1.2锁.assets/1681455773115-6a73a005-970b-4450-a264-cdec59354184.png)\n\n- 各种锁优缺点、synchronized锁升级和实现原理\n\n- ![img](./8.1.2锁.assets/1681456189232-f2cbc220-e6bc-4854-9a5d-e963623a860a.png)\n\n## 编译器对锁的优化\n\n###  锁消除\n\n```\n/**\n * \n * 锁消除\n * 从JIT角度看想相当于无视他，synchronized(o)不存在了\n * 这个锁对象并没有被共用扩散到其他线程使用\n * 极端的说就是根本没有加锁对象的底层机器码，消除了锁的使用\n */\n\npublic class LockClearUpDemo {\n    static Object object = new Object();\n\n    public void m1() {\n        //锁消除问题，JIT会无视它，synchronized(o)每次new出来的，都不存在了，非正常的\n        Object o = new Object();\n        synchronized (o) {\n            System.out.println(\"-----------hello LockClearUpDemo\" + \"\\t\" + o.hashCode() + \"\\t\" + object.hashCode());\n        }\n    }\n\n    public static void main(String[] args) {\n        LockClearUpDemo lockClearUpDemo = new LockClearUpDemo();\n        for (int i = 0; i < 10; i++) {\n            new Thread(() -> {\n                lockClearUpDemo.m1();\n            }, String.valueOf(i)).start();\n        }\n    }\n}\n/**\n * -----------hello LockClearUpDemo	229465744	57319765\n * -----------hello LockClearUpDemo	219013680	57319765\n * -----------hello LockClearUpDemo	1109337020	57319765\n * -----------hello LockClearUpDemo	94808467	57319765\n * -----------hello LockClearUpDemo	973369600	57319765\n * -----------hello LockClearUpDemo	64667370	57319765\n * -----------hello LockClearUpDemo	1201983305	57319765\n * -----------hello LockClearUpDemo	573110659	57319765\n * -----------hello LockClearUpDemo	1863380256	57319765\n * -----------hello LockClearUpDemo	1119787251	57319765\n */\n```\n\n### 锁粗化\n\n```\n/**\n * \n * 锁粗化\n * 假如方法中首尾相接，前后相邻的都是同一个锁对象，那JIT编译器会把这几个synchronized块合并为一个大块\n * 加粗加大范围，一次申请锁使用即可，避免次次的申请和释放锁，提高了性能\n */\npublic class LockBigDemo {\n    static Object objectLock = new Object();\n\n    public static void main(String[] args) {\n        new Thread(() -> {\n            synchronized (objectLock) {\n                System.out.println(\"111111111111\");\n            }\n            synchronized (objectLock) {\n                System.out.println(\"222222222222\");\n            }\n            synchronized (objectLock) {\n                System.out.println(\"333333333333\");\n            }\n            synchronized (objectLock) {\n                System.out.println(\"444444444444\");\n            }\n            //底层JIT的锁粗化优化\n            synchronized (objectLock) {\n                System.out.println(\"111111111111\");\n                System.out.println(\"222222222222\");\n                System.out.println(\"333333333333\");\n                System.out.println(\"444444444444\");\n            }\n        }, \"t1\").start();\n    }\n}\n```\n\n## 小总结\n\n- 没有锁：自由自在\n\n- 偏向锁：唯我独尊\n\n- 轻量锁：楚汉争霸\n\n- 重量锁：群雄逐鹿\n\n  \n\n## ReentrantReadWriteLock\n\n### 是什么\n\n读写锁说明\n\n一个资源能够被多个读线程访问，或者被一个写线程访问，但是不能同时存在读写线程\n\n再说说演变\n\n无锁无序->加锁->读写锁->邮戳锁\n\n读写锁意义和特点\n\n它只允许读读共存，而读写和写写依然是互斥的，大多实际场景是”读/读“线程间不存在互斥关系，只有”读/写“线程或者”写/写“线程间的操作是需要互斥的，因此引入了 ReentrantReadWriteLock\n\n一个ReentrantReadWriteLock同时只能存在一个写锁但是可以存在多个读锁，但是不能同时存在写锁和读锁，也即资源可以被多个读操作访问，或一个写操作访问，但两者不能同时进行。\n\n只有在读多写少情景之下，读写锁才具有较高的性能体现。\n\n### 特点\n\n可重入\n\n读写兼顾\n\n结论：一体两面，读写互斥，读读共享，读没有完成的时候其他线程写锁无法获得\n\n锁降级：\n\n- 将写锁降级为读锁------>遵循获取写锁、获取读锁再释放写锁的次序，写锁能够降级为读锁\n\n- 如果一个线程持有了写锁，在没有释放写锁的情况下，它还可以继续获得读锁。这就是写锁的降级，降级成为了读锁。\n\n- 如果释放了写锁，那么就完全转换为读锁\n\n- 如果有线程在读，那么写线程是无法获取写锁的，是悲观锁的策略\n\n  ![img](./8.1.2锁.assets/1681719044891-56077a92-8f12-49e4-85df-bdffbc21b424.png)\n\n\n\n\n\n\n\n\n\n## StampedLock\n\n###  是什么\n\nStampedLock是JDK1.8中新增的一个读写锁，也是对JDK1.5中的读写锁ReentrantReadWriteLock的优化\n\nstamp 代表了锁的状态。当stamp返回零时，表示线程获取锁失败，并且当释放锁或者转换锁的时候，都要传入最初获取的stamp值。\n\n### 它是由饥饿问题引出\n\n锁饥饿问题：\n\n- ReentrantReadWriteLock实现了读写分离，但是一旦读操作比较多的时候，想要获取写锁就变得比较困难了，因此当前有可能会一直存在读锁，而无法获得写锁。\n\n如何解决锁饥饿问题：\n\n- 使用”公平“策略可以一定程度上缓解这个问题\n- 使用”公平“策略是以牺牲系统吞吐量为代价的\n- StampedLock类的乐观读锁方式--->采取乐观获取锁，其他线程尝试获取写锁时不会被阻塞，在获取乐观读锁后，还需要对结果进行校验\n\n### StampedLock的特点\n\n所有获取锁的方法，都返回一个邮戳，stamp为零表示失败，其余都表示成功\n\n所有释放锁的方法，都需要一个邮戳，这个stamp必须是和成功获取锁时得到的stamp一致\n\nStampedLock是不可重入的，危险（如果一个线程已经持有了写锁，在去获取写锁的话会造成死锁）\n\nStampedLock有三种访问模式：\n\n- Reading（读模式悲观）：功能和ReentrantReadWriteLock的读锁类似\n- Writing（写模式）：功能和ReentrantReadWriteLock的写锁类似\n- Optimistic reading（乐观读模式）：无锁机制，类似与数据库中的乐观锁，支持读写并发，很乐观认为读时没人修改，假如被修改在实现升级为悲观读模式\n\n- 一句话：读的过程中也允许写锁介入\n\n### 乐观读模式Code演示\n\n传统的读写锁模式----读的时候写锁不能获取\n\n```\n/**\n * \n */\npublic class StampedLockDemo {\n    static int number = 37;\n    static StampedLock stampedLock = new StampedLock();\n\n    public void write() {\n        long stamp = stampedLock.writeLock();\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"写线程准备修改\");\n        try {\n            number = number + 13;\n        } finally {\n            stampedLock.unlockWrite(stamp);\n        }\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"写线程结束修改\");\n    }\n\n    public void read() {\n        long stamp = stampedLock.readLock();\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \" come in readLock codeBlock\");\n        for (int i = 0; i < 4; i++) {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \" 正在读取中\");\n        }\n        try {\n            int result = number;\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \"获得成员变量值result: \" + result);\n            System.out.println(\"写线程没有修改成功，读锁时候写锁无法介入，传统的读写互斥\");\n        } finally {\n            stampedLock.unlockRead(stamp);\n        }\n\n    }\n\n    public static void main(String[] args) {\n        StampedLockDemo resource = new StampedLockDemo();\n        new Thread(() -> {\n            resource.read();\n        }, \"readThread\").start();\n\n        try {\n            TimeUnit.SECONDS.sleep(1);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName()+\"\\t\"+\" come in\");\n            resource.write();\n        }, \"writeThread\").start();\n    }\n}\n/**\n * readThread	 come in readLock codeBlock\n * readThread	 正在读取中\n * writeThread	 come in\n * readThread	 正在读取中\n * readThread	 正在读取中\n * readThread	 正在读取中\n * readThread	获得成员变量值result: 37\n * 写线程没有修改成功，读锁时候写锁无法介入，传统的读写互斥\n * writeThread	写线程准备修改\n * writeThread	写线程结束修改\n */\n```\n\n- 乐观读模式----读的过程中也允许写锁介入\n\n```\n/**\n * \n */\npublic class StampedLockDemo {\n    static int number = 37;\n    static StampedLock stampedLock = new StampedLock();\n\n    public void write() {\n        long stamp = stampedLock.writeLock();\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"写线程准备修改\");\n        try {\n            number = number + 13;\n        } finally {\n            stampedLock.unlockWrite(stamp);\n        }\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"写线程结束修改\");\n    }\n\n    public void read() {\n        long stamp = stampedLock.tryOptimisticRead();\n\n        int result = number;\n\n        System.out.println(\"4秒前 stampedLock.validate方法值（true 无修改 false有修改）\" + \"\\t\" + stampedLock.validate(stamp));\n        for (int i = 0; i < 4; i++) {\n            try {\n                TimeUnit.SECONDS.sleep(1);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \" 正在读取....\" + i + \"秒后\" + \"stampedLock.validate方法值（true 无修改 false有修改）\" + \"\\t\" + stampedLock.validate(stamp));\n        }\n        if (!stampedLock.validate(stamp)) {\n            System.out.println(\"有人修改----------有写操作\");\n            stamp = stampedLock.readLock();\n            try {\n                System.out.println(\"从乐观读升级为悲观读\");\n                result = number;\n                System.out.println(\"重新悲观读后result：\" + result);\n            } finally {\n                stampedLock.unlockRead(stamp);\n            }\n        }\n        System.out.println(Thread.currentThread().getName() + \"\\t\" + \"finally value: \" + result);\n\n    }\n\n\n    public static void main(String[] args) {\n        StampedLockDemo resource = new StampedLockDemo();\n        new Thread(() -> {\n            resource.read();\n        }, \"readThread\").start();\n\n        try {\n            TimeUnit.SECONDS.sleep(2);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        new Thread(() -> {\n            System.out.println(Thread.currentThread().getName() + \"\\t\" + \" come in\");\n            resource.write();\n        }, \"writeThread\").start();\n    }\n}\n/**\n * 4秒前 stampedLock.validate方法值（true 无修改 false有修改）	true\n * readThread	 正在读取....0秒后stampedLock.validate方法值（true 无修改 false有修改）	true\n * readThread	 正在读取....1秒后stampedLock.validate方法值（true 无修改 false有修改）	true\n * writeThread	 come in\n * writeThread	写线程准备修改\n * writeThread	写线程结束修改\n * readThread	 正在读取....2秒后stampedLock.validate方法值（true 无修改 false有修改）	false\n * readThread	 正在读取....3秒后stampedLock.validate方法值（true 无修改 false有修改）	false\n * 有人修改----------有写操作\n * 从乐观读升级为悲观读\n * 重新悲观读后result：50\n * readThread	finally value: 50\n */\n```\n\n### StampedLock的缺点\n\n●StampedLock不支持重入，没有Re开头\n●StampedLock的悲观读锁和写锁都不支持条件变量，这个也需要主要\n●使用StampedLock一定不要调用中断操作，即不要调用interrupt()方法',32,'JUC','juc',1,19,0,0,'2024-06-04 01:07:53','2024-06-04 01:07:53'),(42,'AQS','','http://114.132.41.159/upload/20240604_01123055.jpg','# AbstractQueuedSynchronizer之AQS\n\n## 前置知识\n\n- 公平锁和非公平锁\n\n- 公平锁：锁被释放以后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁\n- 非公平锁：锁被释放以后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁\n\n- 可重入锁\n\n- 也叫做递归锁，指的是线程可以再次获取自己的内部锁，比如一个线程获取到了对象锁，此时这个对象锁还没有释放，当其想再次获取这个对象锁的时候还是可以获取的，如果不可重入的话，会导致死锁。\n\n- 自旋思想\n\n- 当线程请求锁时，如果锁已经被其他线程持有，那么该线程会不断地重试获取锁，而不是被挂起等待，这种不断尝试获取锁的行为称为自旋\n\n- LockSupport\n\n- 一个工具类，用于线程的阻塞和唤醒操作，类似于wait()和notify()方法，但是更加灵活和可控\n- 提供了park()和unpark()两个静态方法用于线程阻塞和唤醒操作。\n- 优点在于可以在任意时刻阻塞和唤醒线程而不需要事先获取锁或监视器对象。\n\n- 数据结构之双向链表\n\n- 双向链表（Doubly Linked List）是一种常见的数据结构，它是由一系列结点（Node）组成的，每个结点包含三个部分：数据域、前驱指针和后继指针。其中，数据域存储结点的数据，前驱指针指向前一个结点，后继指针指向后一个结点。通过这种方式，双向链表可以实现双向遍历和插入、删除操作。\n\n- 设计模式之模板设计模式\n\n- 模板设计模式是一种行为型设计模式，定义了一种算法的框架，并将某些步骤延迟到子类中事先，这种设计模式的主要目的是允许子类在不改变算法结构的情况下重新定义算法中的某些步骤。\n- 优点是能够提高代码复用性和可维护性。\n\n## AQS入门理论\n\n### AQS是什么？\n\n抽象的队列同步器\n\n![img](./8.1.3AQS.assets/1681462615181-7a080983-aba2-4362-a60e-b6cd2f3f385e.png)\n\n技术解释\n\n- 是用来实现锁或者其他同步器组件的公共基础部分的抽象实现\n- 是重量级基础框架及整个JUC体系的基石，只要用于解决锁分配给”谁“的问题。\n- 整体就是一个抽象的FIFO队列来完成资源获取线程的排队工作，并通过一个int类变量表示持有锁的状态\n\n![img](./8.1.3AQS.assets/1681462962192-d1aaba76-dc90-4e8c-abbf-ee9b6dfeb339.png)\n\n![img](./8.1.3AQS.assets/1681463110554-9897b98c-fbd0-4b6f-a2ea-823cae280c79.png)\n\n### AQS为什么是JUC内容中最重要的基石？\n\n- 和AQS有关的\n\n- ![img](./8.1.3AQS.assets/1681463320987-a8675735-806a-4111-b540-1744b40b2cdf.png)\n- ReentrantLock\n\n- ![img](./8.1.3AQS.assets/1681463492324-b22562a9-d247-4c52-b3c1-8f0bf72d8b02.png)\n\n- CountDownLatch\n\n- ![img](./8.1.3AQS.assets/1681463501078-095749f5-19e8-4eff-a039-5e65cfb774fc.png)\n\n- ReentrantReadWriteLock\n\n- ![img](./8.1.3AQS.assets/1681463508752-430d08be-760f-49ee-aabf-c75543b3bbb6.png)\n\n- Semaphore\n\n- ![img](./8.1.3AQS.assets/1681463515146-849f9a76-5b5f-468f-8749-e1cd9ba8238e.png)\n\n- 进一步理解锁和同步器的关系\n\n- 锁，面向锁的使用者：定义了程序员和锁交互的使用层API，隐藏了实现细节，你调用即可\n- 同步器，面向锁的实现者：Java并发大神DoungLee，提出了统一规范并简化了锁的实现，将其抽象出来，屏蔽了同步状态管理、同步队列的管理和维护、阻塞线程排队和通知、唤醒机制等，是一切锁和同步组件实现的----公共基础部分\n\n### 能干嘛？\n\n加锁会导致阻塞------有阻塞就需要排队，实现排队必然需要队列\n\n- 抢到资源的线程直接使用处理业务，抢不到资源的必然涉及一种排队等候机制。抢占失败的线程继续去等待（类似于银行办理窗口都满了，暂时没有受理窗口的顾客只能去候客区排队等待），但等候线程仍然保留获取锁的可能且获取锁流程仍在继续（候客区的顾客也在等着叫号，轮到了再去受理窗口办理业务）\n- 既然说到了排队等候机制，那么就一定会有某种队列形成，这样的队列是什么数据结构呢？\n\n- 如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中，这个队列就是AQS同步队列的抽象表现。它将要请求共享资源的线程及自身的等待状态封装成队列的节点对象（Node），通过CAS、自旋以及LockSupport.park()的方式，维护着state变量的状态，使其达到同步的状态。\n- ![img](./8.1.3AQS.assets/1681464739076-a012f721-6fb6-4e4d-a37f-58087ccace1c.png)\n\n### 小总结\n\nAQS同步队列的基本结构\n\n![img](./8.1.3AQS.assets/1681464797821-57493597-fe4f-4b36-b642-5700fb3391af.png)\n\n## AQS源码分析\n\n### AQS内部体系架构----AQS自身\n\n- AQS的int类型变量state\n\n- AQS的同步状态State成员变量\n\n- ![img](./8.1.3AQS.assets/1681465319285-a6cf8348-bcf6-47ac-aba9-2262ba1a304c.png)\n\n- 银行办理业务的受理窗口状态\n\n- 零就是没人，自由状态可以去办理\n- 大于等于1，有人占用窗口，等着去\n\n- AQS的CLH队列\n\n- CLH（三个大牛的名字组成）队列为一个双向队列\n\n- ![img](./8.1.3AQS.assets/1681465485315-4d8ae807-6640-4be3-acd1-647ebfed99da.png)\n\n- 银行候客区的等待顾客\n\n- 小总结\n\n- 有阻塞就需要排队，实现排队必然需要队列\n- State变量+CLH双端队列\n\n### AQS内部体系架构----内部类Node\n\n- Node的int变量\n\n- Node的等待状态waitState成员变量\n\n- ![img](./8.1.3AQS.assets/1681465816752-04931358-ef60-4cf5-922c-f0190eb6e969.png)\n\n- 说人话\n\n- 等候区其他顾客（其他线程）的等待状态\n- 队列中每个排队的个体就是一个Node\n\n- Node此类的讲解\n\n- 内部结构\n\n- ![img](./8.1.3AQS.assets/1681466335871-7b8ba42c-7e65-4b87-ae93-022db4a9e46b.png)\n\n- 属性说明\n\n- ![img](./8.1.3AQS.assets/1681466320982-866b0d0b-e9fe-45f0-92a2-46404b93adde.png)\n\n## AQS源码深度讲解和分析\n\n### ReentrantLock的原理\n\nLock接口的实现类，基本都是通过聚合了一个队列同步器的子类完成线程访问控制的\n\n![img](./8.1.3AQS.assets/1681708942433-24863784-4adb-4c77-887d-4bf93d7b68da.png)\n\n### 从最简单的lock方法开始看看公平和非公平\n\n![img](./8.1.3AQS.assets/1681709439030-81798c4b-ced7-4ca8-a77b-cfd401909593.png)\n\n![img](./8.1.3AQS.assets/1681709370911-49da32ec-5035-49aa-bb8e-91d4c3c8975e.png)\n\n![img](./8.1.3AQS.assets/1681709650075-ef5304ee-ac73-4253-a8f7-84c98da9cdda.png)\n\n![img](./8.1.3AQS.assets/1681709787379-b3ff74c7-0112-462f-9e17-b2cfa6d1fee5.png)\n\n公平锁和非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个限制条件：hasQueuedPredecessors()-----公平锁加锁时判断等待队列中是否存在有效节点的方法\n\n### 以非公平锁ReentrantLock()为例作为突破走起---方法lock()\n\n对比公平锁和非公平锁的tryAcquire()方法的实现代码，其实差异就在于非公平锁获取锁时比公平锁中少了一个判断!hasQueuedPredecessors()，hasQueuedPredecessors()中判断了是否需要排队，导致公平锁和非公平锁的差异如下：\n\n- 公平锁：公平锁讲究先来后到，线程在获取锁时，如果这个锁的等待队列中已经有线程在等待，那么当前线程就会进入到等待队列中；\n- 非公平锁：不管是否有等待队列，如果可以获取到锁，则立刻占有锁对象。也就是说队列的第一个排队线程苏醒后，不一定就是排头的这个线程获得锁，它还需要参加竞争锁（存在线程竞争的情况下），后来的线程可能不讲武德插队夺锁了。\n\n![img](./8.1.3AQS.assets/1681710488888-4480bfac-991b-4c7a-8478-8bf5aa70b438.png)\n\n![img](./8.1.3AQS.assets/1681710546972-3bd553ee-b9fd-49cd-9e1c-21c3e6b346f0.png)\n\n**正式开始源码解读：**\n\n- lock()\n\n- ![img](./8.1.3AQS.assets/1681710807464-69fe3f14-c4b9-4c2a-a6aa-9306f552d21f.png)\n- ![img](./8.1.3AQS.assets/1681710825148-dd7e96ea-e0c0-4b10-8645-3d057acd5bd0.png)\n\n- acquire()\n\n- ![img](./8.1.3AQS.assets/1681711454995-05e9dc6b-1e2a-4be5-9bc4-377aad3b739d.png)\n\n- tryAcquire(arg)\n\n- ![img](./8.1.3AQS.assets/1681712020967-c262aac4-5875-4bbc-a38f-4ff3f5251079.png)\n- return false：继续推进条件，走下一个方法\n- return true：结束\n\n- addwaiter(Node.EXCLUSIVE)\n\n- ![img](./8.1.3AQS.assets/1681712641453-cce21764-ca76-4f9c-93ed-f14a448d6659.png)\n- 注意：在双向链表中，第一个节点为虚节点（也叫做哨兵节点），其实不存储任何信息，只是占位。真正的第一个有数据的节点，是从第二个节点开始的\n- 假如此时有线程C进入：\n- ![img](./8.1.3AQS.assets/1681712960816-a469c5dc-9314-4a22-8e40-d27b14f420c9.png)\n\n- acquireQueued(addWeiter(Node.EXCLUSIVE), arg)-----坐稳队列\n\n- ![img](./8.1.3AQS.assets/1681714066377-9cf09409-c2de-4d43-a482-c3d608686f97.png)\n\n### unlock()\n\n![img](./8.1.3AQS.assets/1681714888755-4fcc4f71-3217-4326-b545-f0b7ffb5fcf5.png)',32,'JUC','juc',1,19,0,0,'2024-06-04 01:12:31','2024-06-04 01:12:31'),(43,'RMI与IIOP','','http://liyiru.site/upload/20240606_00030456.jpg','RMI（Remote Method Invocation，远程方法调用）与IIOP（Internet Inter-ORB Protocol，互联网内部对象请求代理协议）在分布式计算中扮演着不同的角色，但它们之间有着密切的联系。\n\n## RMI概述：\n\n定义：RMI是一种用于Java的远程方法调用机制，它允许在分布式系统中的不同Java虚拟机（JVM）上执行方法调用，就像在本地执行一样。\n\n### 特性：\n\n透明性：对于开发人员来说，RMI是透明的，他们可以像调用本地方法一样调用远程方法，无需关心底层的网络通信细节。\n\n传输层独立性：RMI可以在不同的传输层协议上运行，如TCP/IP、HTTP等。\n\n一对一通信：RMI采用点对点的通信方式，即客户端和服务器之间是一对一的通信关系。\n\n远程对象：RMI允许将Java对象作为参数或返回值传递给远程方法调用\n\n安全性：RMI提供了安全机制，包括身份验证和加密，以确保通信的安全性。\n\n通信协议：RMI默认使用JRMP（Java Remote Method Protocol）作为通信协议，但也可以通过RMI-IIOP来使用IIOP协议。\n\n## IIOP概述：\n\n定义：IIOP是一个用于CORBA 2.0及兼容平台上的协议，用于在CORBA对象请求代理（ORB）之间通信。\n\n### 特性：\n\n跨平台性：IIOP支持在不同的操作系统和编程语言之间进行通信。\n\n标准性：IIOP是CORBA规范的一部分，具有广泛的支持和标准化。\n\n用途：IIOP使得不同ORB之间的通信成为可能，从而实现了跨平台、跨语言的分布式计算。\n\n## RMI与IIOP的关系：\n\nRMI-IIOP：RMI-IIOP是RMI和IIOP的结合体，它允许Java应用程序通过IIOP协议访问CORBA服务。这意味着Java应用程序可以使用RMI-IIOP API来直接定义自己的CORBA服务，并且可以使用IIOP协议与其他CORBA服务进行通信。\n\n优势：RMI-IIOP综合了RMI的简单性和CORBA的多语言性（兼容性），使得程序员能更方便的编写分布式程序设计，实现分布式计算。同时，RMI-IIOP克服了RMI只能用于Java的缺点和CORBA的复杂性（可以不用掌握IDL）。\n\n总结来说，RMI是Java中的一种远程方法调用机制，而IIOP是CORBA中的一个通信协议。RMI-IIOP则是结合了RMI和IIOP的优点，使得Java应用程序能够更方便地与其他CORBA服务进行通信。',28,'JAVA','java',1,5,0,0,'2024-06-06 00:03:06','2024-06-06 00:03:06'),(44,'访问修饰符','','http://liyiru.site/upload/20240606_00252168.jpg','public：所有类可以访问\n\nprotected：同包类可以访问，子类也可以访问\n\n默认：同包类可以访问\n\nprivate：只有自己可以访问',28,'JAVA','java',1,4,0,0,'2024-06-06 00:25:22','2024-06-06 00:25:22'),(45,'常量池','','http://liyiru.site/upload/20240606_00543359.jpg','### 运行时常量池（Runtime Constant Pool）与字符串常量池（String Constant Pool）\n\n在Java中虽然都涉及常量的存储，但它们在功能、存储位置、目的等方面存在显著的区别。以下是两者之间的详细区别：\n\n##### 定义与功能\n\n- 运行时常量池：\n  - 是Java虚拟机（JVM）方法区的一部分，用于存储类的版本、字段、方法、接口等描述信息，以及编译时期生成的各种字面量（Literal）和符号引用（Symbolic Reference）。\n  - 它具备动态性，允许在运行期间产生新的常量并存储在池中。\n  - 存储的常量类型包括基本类型包装类（限定范围）、String等。\n- 字符串常量池：\n  - 是JVM为了提升性能和减少内存消耗，针对String类专门在堆空间开辟的一块区域。\n  - 主要目的是为了避免重复创建相同的字符串，实现字符串的唯一性和不可变性。\n\n##### 存储位置\n\n- 运行时常量池：\n  - 在JVM的方法区中，具体实现可以是永久代（在JDK 1.7及以前）或元空间（Meta Space，在JDK 1.8及以后）。\n  - 使用的内存不是堆空间，而是直接内存或元空间。\n- 字符串常量池：\n  - 位于Java堆内存中。\n  - 当通过字面量方式（如String s = \"hello\";）创建一个字符串时，JVM会首先检查字符串常量池中是否存在相同内容的字符串，如果存在则直接返回引用，否则在池中创建并返回引用。\n\n##### 目的与特点\n\n- 运行时常量池：\n  - 旨在提供一种高效的常量存储机制，减少内存使用，提高程序执行效率。\n  - 存储的常量类型丰富，包括字符串、整数、浮点数等。\n- 字符串常量池：\n  - 主要针对String类型，实现字符串的唯一性和不可变性。\n  - 通过字符串常量池，可以避免重复创建相同的字符串，从而节省内存空间和提高比较效率。\n\n##### 总结\n\n运行时常量池和字符串常量池在Java中各自扮演着不同的角色。运行时常量池是JVM方法区的一部分，用于存储多种类型的常量；而字符串常量池则专门针对String类型，在堆空间中实现字符串的唯一性和不可变性。两者在存储位置、目的和特点上均有显著区别。',31,'JVM','jvm',1,13,0,0,'2024-06-06 00:54:34','2024-06-06 00:54:34');
/*!40000 ALTER TABLE `tb_blog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_blog_category`
--

DROP TABLE IF EXISTS `tb_blog_category`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_blog_category` (
  `category_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '分类表主键',
  `category_name` varchar(50) NOT NULL COMMENT '分类的名称',
  `category_icon` varchar(50) NOT NULL COMMENT '分类的图标',
  `category_rank` int(11) NOT NULL DEFAULT '1' COMMENT '分类的排序值 被使用的越多数值越大',
  `is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`category_id`)
) ENGINE=InnoDB AUTO_INCREMENT=41 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_blog_category`
--

LOCK TABLES `tb_blog_category` WRITE;
/*!40000 ALTER TABLE `tb_blog_category` DISABLE KEYS */;
INSERT INTO `tb_blog_category` VALUES (26,'作者','/admin/dist/img/category/06.png',29,0,'2024-05-17 00:43:21'),(27,'开发工具','/admin/dist/img/category/06.png',9,0,'2024-05-17 01:27:18'),(28,'JAVA','/admin/dist/img/category/02.png',18,0,'2024-05-17 16:06:43'),(29,'算法','/admin/dist/img/category/09.png',11,0,'2024-05-19 15:46:21'),(30,'计算机','/admin/dist/img/category/00.png',2,0,'2024-05-19 15:59:20'),(31,'JVM','/admin/dist/img/category/02.png',17,0,'2024-05-21 11:18:41'),(32,'JUC','/admin/dist/img/category/00.png',10,0,'2024-05-21 11:18:48'),(33,'Redis','/admin/dist/img/category/00.png',2,0,'2024-05-21 11:19:01'),(34,'SpringCloud','/admin/dist/img/category/08.png',1,0,'2024-05-29 19:38:57'),(35,'Spring','/admin/dist/img/category/00.png',1,0,'2024-05-29 19:39:12'),(36,'SpringBoot','/admin/dist/img/category/00.png',1,0,'2024-05-29 19:39:21'),(37,'消息队列','/admin/dist/img/category/00.png',1,0,'2024-05-29 19:40:07'),(38,'数据库','/admin/dist/img/category/05.png',1,0,'2024-05-29 19:40:27'),(39,'Linux','/admin/dist/img/category/13.png',1,0,'2024-05-29 19:40:53'),(40,'Git','/admin/dist/img/category/00.png',1,0,'2024-05-29 19:41:05');
/*!40000 ALTER TABLE `tb_blog_category` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_blog_comment`
--

DROP TABLE IF EXISTS `tb_blog_comment`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_blog_comment` (
  `comment_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键id',
  `blog_id` bigint(20) NOT NULL DEFAULT '0' COMMENT '关联的blog主键',
  `commentator` varchar(50) NOT NULL DEFAULT '' COMMENT '评论者名称',
  `email` varchar(100) NOT NULL DEFAULT '' COMMENT '评论人的邮箱',
  `website_url` varchar(50) NOT NULL DEFAULT '' COMMENT '网址',
  `comment_body` varchar(200) NOT NULL DEFAULT '' COMMENT '评论内容',
  `comment_create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '评论提交时间',
  `commentator_ip` varchar(20) NOT NULL DEFAULT '' COMMENT '评论时的ip地址',
  `reply_body` varchar(200) NOT NULL DEFAULT '' COMMENT '回复内容',
  `reply_create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '回复时间',
  `comment_status` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否审核通过 0-未审核 1-审核通过',
  `is_deleted` tinyint(4) DEFAULT '0' COMMENT '是否删除 0-未删除 1-已删除',
  PRIMARY KEY (`comment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=51 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_blog_comment`
--

LOCK TABLES `tb_blog_comment` WRITE;
/*!40000 ALTER TABLE `tb_blog_comment` DISABLE KEYS */;
INSERT INTO `tb_blog_comment` VALUES (29,9,'lee','3329482804@qq.com','','哇~','2024-05-17 14:37:19','','','2024-05-17 14:37:19',1,0),(30,1,'lily','3329482804@qq.com','','耶~','2024-05-17 15:07:02','','','2024-05-17 15:07:02',1,0),(31,9,'lee','3329482804@qq.com','','666','2024-05-18 01:07:05','','','2024-05-18 01:07:05',0,0),(32,9,'lee','3329482804@qq.com','','666','2024-05-18 01:12:54','','','2024-05-18 01:12:54',0,0),(33,11,'lee','3329482804@qq.com','','666','2024-05-18 01:41:05','','','2024-05-18 01:41:05',0,0),(34,11,'lily','3329482804@qq.com','','666','2024-05-18 16:46:36','','','2024-05-18 16:46:36',0,0),(35,11,'lee','3329482804@qq.com','','666','2024-05-18 16:49:54','','','2024-05-18 16:49:54',0,0),(36,11,'lee','3329482804@qq.com','','666','2024-05-18 16:59:21','','','2024-05-18 16:59:21',0,0),(37,11,'lee','3329482804@qq.com','','666~','2024-05-18 17:01:17','','','2024-05-18 17:01:17',0,0),(38,11,'lee','3329482804@qq.com','','888','2024-05-18 17:17:06','','','2024-05-18 17:17:06',0,0),(39,11,'lee','3329482804@qq.com','','可以，可以。','2024-05-18 17:24:47','','','2024-05-18 17:24:47',1,0),(40,11,'lee','3329482804@qq.com','','哈哈~','2024-05-18 17:25:24','','嘻嘻~','2024-05-22 08:02:15',1,0),(41,11,'lee','3329482804@qq.com','','nb','2024-05-18 17:26:21','','','2024-05-18 17:26:21',1,0),(42,11,'lee','3329482804@qq.com','','666666','2024-05-18 17:26:33','','','2024-05-18 17:26:33',1,0),(43,11,'lee','3329482804@qq.com','','nice','2024-05-21 19:09:18','','en','2024-05-22 05:34:27',1,0),(44,32,'小李','332534156@qq.com','','aa','2024-05-28 21:35:10','','','2024-05-28 21:35:10',1,1),(45,30,'白板','3329482804@qq.com','','总结的好','2024-05-28 22:35:17','','','2024-05-28 22:35:17',1,0),(46,30,'白板','3329482804@qq.com','','总结的好','2024-05-28 22:35:17','','','2024-05-28 22:35:17',1,1),(47,30,'牛牛','3329482804@qq.com','','哈哈','2024-05-28 22:38:04','','','2024-05-28 22:38:04',1,0),(48,38,'球会俄方还给我i发货','1A@b.com','','我是你爹','2024-06-03 14:57:32','','','2024-06-03 14:57:32',1,1),(49,38,'lee','3329482804@qq.com','','666','2024-06-03 15:35:55','','','2024-06-03 15:35:55',1,0),(50,38,'ss','3329482804@qq.com','','~','2024-06-03 15:41:13','','','2024-06-03 15:41:13',1,0);
/*!40000 ALTER TABLE `tb_blog_comment` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_blog_tag`
--

DROP TABLE IF EXISTS `tb_blog_tag`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_blog_tag` (
  `tag_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '标签表主键id',
  `tag_name` varchar(100) NOT NULL COMMENT '标签名称',
  `is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否删除 0=否 1=是',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`tag_id`)
) ENGINE=InnoDB AUTO_INCREMENT=157 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_blog_tag`
--

LOCK TABLES `tb_blog_tag` WRITE;
/*!40000 ALTER TABLE `tb_blog_tag` DISABLE KEYS */;
INSERT INTO `tb_blog_tag` VALUES (139,'博客',0,'2024-05-17 00:55:10'),(140,'docker',0,'2024-05-17 01:32:07'),(141,'作者',0,'2024-05-17 01:37:36'),(142,'git',0,'2024-05-17 14:14:08'),(143,'工具使用',0,'2024-05-17 16:02:42'),(144,'jvm',0,'2024-05-17 16:07:20'),(145,'字符串',0,'2024-05-19 15:46:01'),(146,'计算机基础',0,'2024-05-19 15:57:45'),(147,'双指针',0,'2024-05-19 17:02:42'),(148,'数组',0,'2024-05-20 20:25:28'),(149,'redis',0,'2024-05-21 11:21:02'),(150,'垃圾回收器',0,'2024-05-22 15:42:39'),(151,'jdk',0,'2024-05-22 17:10:26'),(152,'GC',0,'2024-05-24 15:04:16'),(153,'jvm问题',0,'2024-05-28 01:29:16'),(154,'java',0,'2024-05-28 19:17:33'),(155,'juc',0,'2024-05-28 23:41:19'),(156,'垃圾回收机制',0,'2024-05-30 20:20:49');
/*!40000 ALTER TABLE `tb_blog_tag` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_blog_tag_relation`
--

DROP TABLE IF EXISTS `tb_blog_tag_relation`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_blog_tag_relation` (
  `relation_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '关系表id',
  `blog_id` bigint(20) NOT NULL COMMENT '博客id',
  `tag_id` int(11) NOT NULL COMMENT '标签id',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  PRIMARY KEY (`relation_id`)
) ENGINE=InnoDB AUTO_INCREMENT=392 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_blog_tag_relation`
--

LOCK TABLES `tb_blog_tag_relation` WRITE;
/*!40000 ALTER TABLE `tb_blog_tag_relation` DISABLE KEYS */;
INSERT INTO `tb_blog_tag_relation` VALUES (269,2,127,'2019-05-13 09:56:49'),(274,3,66,'2019-05-13 10:07:27'),(275,3,67,'2019-05-13 10:07:27'),(276,3,68,'2019-05-13 10:07:27'),(277,3,69,'2019-05-13 10:07:27'),(278,3,128,'2019-05-13 10:07:27'),(279,4,130,'2024-05-15 02:10:53'),(280,4,131,'2024-05-15 02:10:53'),(281,4,132,'2024-05-15 02:10:53'),(282,4,133,'2024-05-15 02:10:53'),(283,5,135,'2024-05-15 17:02:04'),(284,6,136,'2024-05-15 17:07:27'),(301,8,138,'2024-05-16 21:35:58'),(310,9,140,'2024-05-17 15:29:20'),(311,10,142,'2024-05-17 15:29:35'),(314,11,143,'2024-05-17 16:02:42'),(315,12,144,'2024-05-17 16:07:20'),(317,13,144,'2024-05-17 16:21:20'),(330,15,146,'2024-05-19 15:59:34'),(332,14,145,'2024-05-19 16:27:14'),(333,16,147,'2024-05-19 17:02:42'),(336,17,147,'2024-05-20 00:16:21'),(339,18,148,'2024-05-20 20:45:47'),(340,19,149,'2024-05-21 11:21:02'),(344,20,150,'2024-05-22 16:07:21'),(345,21,151,'2024-05-22 17:10:26'),(347,22,152,'2024-05-24 15:04:16'),(349,23,144,'2024-05-24 17:04:59'),(350,24,144,'2024-05-24 17:06:21'),(351,25,144,'2024-05-27 16:15:13'),(353,26,153,'2024-05-28 01:31:16'),(354,27,153,'2024-05-28 01:35:29'),(355,28,153,'2024-05-28 01:42:57'),(356,29,154,'2024-05-28 19:17:33'),(360,30,154,'2024-05-28 19:48:48'),(361,31,154,'2024-05-28 19:52:32'),(362,32,154,'2024-05-28 20:39:03'),(364,7,139,'2024-05-28 22:33:16'),(365,33,155,'2024-05-28 23:41:19'),(366,34,155,'2024-05-28 23:51:47'),(367,35,155,'2024-05-28 23:53:03'),(368,36,155,'2024-05-28 23:57:24'),(369,37,155,'2024-05-29 00:12:35'),(370,38,156,'2024-05-30 20:20:49'),(372,40,155,'2024-06-03 20:46:36'),(373,39,155,'2024-06-03 20:47:15'),(374,41,155,'2024-06-04 01:07:53'),(375,42,155,'2024-06-04 01:12:31'),(385,1,141,'2024-06-05 22:36:56'),(388,43,154,'2024-06-06 00:05:19'),(390,44,154,'2024-06-06 00:25:43'),(391,45,144,'2024-06-06 00:54:34');
/*!40000 ALTER TABLE `tb_blog_tag_relation` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_config`
--

DROP TABLE IF EXISTS `tb_config`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_config` (
  `config_name` varchar(100) NOT NULL DEFAULT '' COMMENT '配置项的名称',
  `config_value` varchar(200) NOT NULL DEFAULT '' COMMENT '配置项的值',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '修改时间',
  PRIMARY KEY (`config_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_config`
--

LOCK TABLES `tb_config` WRITE;
/*!40000 ALTER TABLE `tb_config` DISABLE KEYS */;
INSERT INTO `tb_config` VALUES ('footerAbout','绿叶随笔','2018-11-11 20:33:23','2024-05-28 02:49:50'),('footerCopyRight','LYR','2018-11-11 20:33:31','2024-05-28 02:49:50'),('footerICP','粤ICP备2024256512号-1','2018-11-11 20:33:27','2024-05-28 02:49:50'),('footerPoweredBy','https://github.com/iceliyr','2018-11-11 20:33:36','2024-05-28 02:49:50'),('footerPoweredByURL','https://github.com/leeyr','2018-11-11 20:33:39','2024-05-28 02:49:50'),('websiteDescription','LYR个人博客网站','2018-11-11 20:33:04','2024-05-21 13:20:10'),('websiteIcon','/admin/dist/img/logo.png','2018-11-11 20:33:11','2024-05-21 13:20:10'),('websiteLogo','/admin/dist/img/logo.png','2018-11-11 20:33:08','2024-05-21 13:20:10'),('websiteName','绿叶随笔','2018-11-11 20:33:01','2024-05-21 13:20:10'),('yourAvatar','/admin/dist/img/person.jpg','2018-11-11 20:33:14','2024-05-17 15:21:41'),('yourEmail','3329482804@qq.com','2018-11-11 20:33:17','2024-05-17 15:21:41'),('yourName','LYR','2018-11-11 20:33:20','2024-05-17 15:21:41');
/*!40000 ALTER TABLE `tb_config` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_link`
--

DROP TABLE IF EXISTS `tb_link`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_link` (
  `link_id` int(11) NOT NULL AUTO_INCREMENT COMMENT '友链表主键id',
  `link_type` tinyint(4) NOT NULL DEFAULT '0' COMMENT '友链类别 0-友链 1-推荐 2-个人网站',
  `link_name` varchar(50) NOT NULL COMMENT '网站名称',
  `link_url` varchar(100) NOT NULL COMMENT '网站链接',
  `link_description` text,
  `link_rank` int(11) NOT NULL DEFAULT '0' COMMENT '用于列表排序',
  `is_deleted` tinyint(4) NOT NULL DEFAULT '0' COMMENT '是否删除 0-未删除 1-已删除',
  `create_time` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  PRIMARY KEY (`link_id`)
) ENGINE=InnoDB AUTO_INCREMENT=50 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_link`
--

LOCK TABLES `tb_link` WRITE;
/*!40000 ALTER TABLE `tb_link` DISABLE KEYS */;
INSERT INTO `tb_link` VALUES (6,1,'CSDN','https://www.csdn.net/','CSDN-专业IT技术社区官网',4,0,'2018-10-22 19:56:47'),(20,3,'redis','https://redis.io/','缓存',0,0,'2024-05-15 15:26:14'),(23,8,'电影网站','https://github.com/iceliyr/film','<strong>项目技术：</strong><br> springboot、mybatis、mysql、redis、jquery、thymeleaf、ajax。<br> <strong>项目介绍：</strong><br> 实现电影观看，搜索分类，后台管理等功能。<br> <strong>项目功能：</strong><br> 1）使用mybatis-plus分页进行搜索分类，redis缓存最近查询信息，session保存用户信息。<br>',3,0,'2024-05-17 01:18:37'),(24,8,'人人选好物','https://github.com/iceliyr/everyone-shopping','<strong>项目技术：</strong><br> springboot、springcloud、Mybatis、MySQL、Minio、redis、docker、vue3、Nginx。 <br>   <strong>项目介绍：</strong><br> 一个电商购物平台，同时具备后台管理系统。后台管理部分：用户管理、角色管理、权限管理、分类管理、商品管理、日志管理；后端：使用gateway管理前端请求，每个服务在nacos注册供访问，通过openfeign进行服务调用，在数据修改部分使用分布式事务，同时使用redis提高访问效率。<br>   <strong>项目功能：</strong><br> threadlocal解决线程安全、gateway过滤或拦截前端请求、日志收集与查看、全局异常处理、使用MInio文件服务器存储图片、使用配置文件动态配置属性值、解决跨域问题、进行多表联查。<br>',5,0,'2024-05-17 13:50:35'),(26,3,'AIchatOS','https://chat18.aichatos8.com/','一款无需vpn的chatgpt免费网站',0,0,'2024-05-17 13:56:48'),(27,3,'文心一言','https://yiyan.baidu.com/','百度开发的gpt网站',0,0,'2024-05-17 13:57:52'),(28,3,'讯飞星火','https://xinghuo.xfyun.cn/','讯飞开发的gpt网站',0,0,'2024-05-17 13:58:48'),(29,1,'bilibili','https://www.bilibili.com/','免费技术学习视频网站',0,0,'2024-05-17 13:59:47'),(30,1,'牛客网','https://www.nowcoder.com/','IT在线学习和招聘平台，提供在线课程、题库练习、社区问答、面经分享等多种形式进行学习和交流，并可通过平台招聘服务找到合适的工作。',0,0,'2024-05-17 14:01:39'),(31,2,'spring 中文文档','https://springdoc.cn/docs/','spring在线学习文档',0,0,'2024-05-17 14:04:02'),(32,0,'帅地玩编程','https://www.iamshuaidi.com/','一个发布面试文章的博客',0,0,'2024-05-17 15:58:17'),(33,1,'力扣','https://leetcode.cn/','刷算法网站',0,0,'2024-05-17 23:13:10'),(34,1,'stackoverflow','https://stackoverflow.com/questions','查询报错，代码问题网站',0,0,'2024-05-17 23:14:42'),(35,1,'稀土掘金','https://juejin.cn/','交流学习网站',0,0,'2024-05-17 23:15:16'),(36,3,'MYSQL','https://dev.mysql.com/downloads/mysql/','下载mysql数据库',0,0,'2024-05-17 23:15:47'),(37,2,'SpringCloudAlibaba','https://sca.aliyun.com/','SpringCloudAlibaba相关技术文档',0,0,'2024-05-17 23:16:51'),(38,1,'Github','https://github.com/','代码托管和开源代码网站',10,0,'2024-05-17 23:17:39'),(39,1,'Gitee','https://gitee.com/','国内代码托管与开源代码网站',20,0,'2024-05-17 23:18:38'),(40,2,'Vue3','https://cn.vuejs.org/','前端框架vue3在线学习文档',0,0,'2024-05-22 16:49:50'),(41,8,'绿叶随笔','https://github.com/iceliyr/blog','<b>项目环境：</b><br> （1）后端  JDk17、Springboot3.1.0、Mybatis-plus3.5.3.1、Mysql.5.7.36 <br> （2）前端  Thymeleaf、Bootstrap、Jquery、AJax。<br>  <b>项目介绍：</b>  <br> 本项目为个人博客系统，功能包括文章发布、文章分类、文章标签、文章评论、个人项目介绍、学习网站推荐、作者介绍、后台管理（文章、评论、网站管理）等功能。<br>  <b>项目功能：</b><br> （1）后台登录  使用拦截器拦截后台请求，只有通过前端传入账号密码及通过（hutool工具）验证码验证后，方可进入后台管理界面进行处理数据。 <br> （2）文章发布、分类、标签  后台管理使用md编写评论，使用Atlassian CommonMark 库，用于解析和处理 Markdown 格式的文本，并保存到数据库，然后在转化为html文本块，其中涉及到图片上传功能（将图片通过javaIO保存到本地，并保存地址到数据库，前端通过接口访问地址即可获得），功能还使用了图片封面上传、文章分类、文章标签（通过多表连接）。  <br> （3）评论添加、审核、发布  在文章上添加评论，通过文章id与评论连接，在每次访问评论后，通过多表连接，获取文章的每一个评论显示。  <br> （4）学习网站推荐的发布  后台管理发布信息，并添加分类，然后保存到数据库。 <br>     <b>项目未来计划：</b>   <br> （1）阶段一：使用sa-token进行权限验证，便于游客查阅后台管理  <br> （2）阶段二：使用redis，提高访问效率  <br> （3）阶段三：增加社区功能，方便用户交流  <br> （4）阶段四：使用spring cloud升级项目<br>',6,0,'2024-05-22 19:58:43'),(42,3,'文本转html','https://www.iamwawa.cn/text2html.html','文本转html',0,0,'2024-05-22 20:17:12'),(43,3,'md转html','https://lwebapp.com/zh/markdown-to-html','md转html',0,0,'2024-05-22 20:24:28'),(44,8,'基于深度学习的高考大数据志愿引导系统','https://github.com/iceliyr/MajorRec','<strong>项目技术：</strong><br> springboot、mybatis-plus、mysql、jwt、微信小程序<br> <strong>项目介绍：</strong><br> 项目为微信小程序与java服务的前后端分离项目，项目主要是通过爬虫收集各个学校及其专业的高考录取数据，根据灰色预测模型预测未来的分数线，同时还可以使用性格测试测试，并以此提供专业推荐。<br> <strong>项目功能：</strong><br> 1）使用jwt进行验证登录，小程序发送请求后端，进行拦截查验，不通过重定向到登录界面，用户点击登录发送code到后端，后端通过code、APPID、AppSecret到微信验证平台，验证成功后将用户openid经过jwt加密后返回，每次小程序请求携带登录信息，在拦截器中解析openid获取用户信息，保存到HttpServletRequest。<br> 2）使用多表查询，在大学信息查询中，大学基础信息表通过school的id连接到专业分数表，返回基础信息及院校分数信息。<br> （3）分页查询，使用mybatus-plus分页查询，通过current、size参数，返回size大小且页码为current的页面。<br> <strong>演示视频：</strong><br>  <a  href=\"https://www.bilibili.com/video/BV1vw4m1D7Kh\" > https://www.bilibili.com/video/BV1vw4m1D7Kh </a>',10,0,'2024-05-24 19:32:38'),(45,8,'购花商城网站','https://github.com/iceliyr/flower','<strong>项目技术：</strong><br> JDK11<br>  Springboot2.7.16<br>  MyBatis-plus3.5.3.1<br>  Redis<br>  MySQL8.0<br>  Thymeleaf<br>   <strong>项目介绍：</strong><br> 该项目为购花网站，分为用户部分和管理员部分，功能包括分页查询，查找商品，分类查询、模糊查询、价格查询，加入购物车功能，添加订单，评价功能，付款功能，后台商品功能，后台商品添加、修改、删除功能。<br>   <strong>项目功能：</strong><br> （1）MD5加密用户密码<br>  （2）redis添加缓存<br>  （3）mybatis-plus分页查询<br>  （4）MultipartFile保存鲜花图片<br>',2,0,'2024-05-28 14:01:53'),(46,9,'一键抠图','http://liyiru.site/matting','一键抠图',3,1,'2024-06-02 21:44:18'),(47,9,'一键抠图','http://liyiru.site/matting','上传人物图片，清除背景，抠取人物图片',0,1,'2024-06-02 22:10:15'),(48,9,'一键扣图','http://liyiru.site/matting','抠取人物信息',0,0,'2024-06-03 15:01:11'),(49,0,'JavaGuide','https://javaguide.cn/','JAVA笔记',0,0,'2024-06-03 22:20:53');
/*!40000 ALTER TABLE `tb_link` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_project`
--

DROP TABLE IF EXISTS `tb_project`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_project` (
  `projectId` int(11) NOT NULL AUTO_INCREMENT,
  `projectRank` int(11) DEFAULT NULL,
  `projectName` varchar(255) DEFAULT NULL,
  `projectUrl` varchar(255) DEFAULT NULL,
  `projectEnvironment` varchar(255) DEFAULT NULL,
  `projectTechnology` varchar(255) DEFAULT NULL,
  `projectIntroduce` text,
  `projectFunctionality` text,
  PRIMARY KEY (`projectId`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_project`
--

LOCK TABLES `tb_project` WRITE;
/*!40000 ALTER TABLE `tb_project` DISABLE KEYS */;
INSERT INTO `tb_project` VALUES (1,1,'项目1','http://example.com/project1','环境1','技术1','这是项目1的介绍。','这是项目1的功能。'),(2,2,'项目2','http://example.com/project2','环境2','技术2','这是项目2的介绍。','这是项目2的功能。'),(3,3,'项目3','http://example.com/project3','环境3','技术3','这是项目3的介绍。','这是项目3的功能。');
/*!40000 ALTER TABLE `tb_project` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `tb_user`
--

DROP TABLE IF EXISTS `tb_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `tb_user` (
  `user_id` int(11) NOT NULL AUTO_INCREMENT,
  `commentator` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `website_url` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `tb_user`
--

LOCK TABLES `tb_user` WRITE;
/*!40000 ALTER TABLE `tb_user` DISABLE KEYS */;
INSERT INTO `tb_user` VALUES (1,'lee','3329482804@qq.com',NULL),(2,'lee','3329482804@qq.com',NULL),(3,'lee','3329482804@qq.com',NULL),(4,'lee','3329482804@qq.com',NULL),(5,'lee','3329482804@qq.com',NULL),(6,'lee','3329482804@qq.com',NULL);
/*!40000 ALTER TABLE `tb_user` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2024-06-06 14:32:21
